---
description: "Execute task list using TDD methodology (streamlined - code generation focused)"
argument-hint: "<task-list-file>"
allowed-tools: "TodoWrite, Read, Write, Edit, Bash(npm:*), Bash(npx:*), Bash(node:*), Bash(cmd.exe:*), Bash(git status:*), Bash(git diff:*), Grep, Glob"
---

# Streamlined Task Executor with TDD

Execute tasks from task list using Test-Driven Development. **Focus on code generation** - no documentation overhead.

**Input**: Task list file at $ARGUMENTS (generated by `/plan-act:plan`)
**Output**: Working code with passing tests

---

## ðŸš¨ YOUR MISSION: GENERATE CODE

**YOU MUST NOW WRITE CODE** for all tasks in the list. This is the EXECUTION phase.

**Your mission**:
1. âœ… Write actual test files
2. âœ… Write actual implementation files
3. âœ… Run tests to verify they pass
4. âœ… Continue until ALL tasks completed or blocked

**DO NOT STOP** after reading the task list.

---

## Input Validation

**Follow Standard Input Validation Pattern** (see @.claude/commands/flow/prd.md - Shared Patterns)

## Architecture Guides

**See Architecture Guide Index** in @.claude/commands/flow/prd.md for full descriptions.

**Critical for execution**:
1. **Lean Development**: Just-in-time infrastructure, user-visible features first
2. **File Organization**: Co-located tests (NO __tests__ folders), NO barrel exports
3. **Working Directory**: You are in `c:\dev\class-one-rapids\frontend\`, NEVER create `frontend/frontend/`
4. **State Management**: useState â†’ custom hook â†’ Legend-State store (in that order)
5. **Testing**: Test hooks through components (per CLAUDE.md), NOT standalone

---

## Phase 1: Setup

### Step 1: Load Task List

1. Read task list file (validated above)
2. Verify task list contains valid tasks
3. Parse tasks and extract embedded exploration results

### Step 2: Initialize TodoWrite Tracking

**USE TodoWrite NOW** to create todo items:

```typescript
TodoWrite({
  todos: [
    {content: "Task 1 description", status: "pending", activeForm: "Working on task 1"},
    {content: "Task 2 description", status: "pending", activeForm: "Working on task 2"},
    // ... for all tasks
  ]
})
```

**Rule**: Only ONE task should be "in_progress" at a time.

---

## Phase 2: Load Cached Exploration Results

**OPTIMIZATION**: Task list (from `/plan-act:plan`) contains embedded exploration results. READ THEM - don't re-explore.

### Step 1: Extract Exploration from Task List

Look for sections in task list:

```markdown
## ðŸ” Codebase Exploration Results
[Component analysis, store properties, integration map]

## Architecture Decisions Summary
- UPDATE: path/to/existing.tsx (reason)
- CREATE: path/to/new.tsx (reason)

Store Properties (verified):
- storeName.property âœ…
```

### Step 2: Create Integration Plan

Document exploration decisions for easy reference:

```markdown
## ðŸ” INTEGRATION PLAN

### Files to UPDATE (existing):
âœï¸ path/to/existing.tsx
   - Reason: [from exploration]
   - Changes: [from task description]

### Files to CREATE (new):
âœ¨ path/to/new.tsx
   - Reason: [from exploration]

### Store Properties (VERIFIED):
âœ… storeName.property (NOT wrongName)

### Integration:
âœ… [How it integrates with app]
```

### Step 3: Fallback (if exploration missing)

**ONLY IF** task list doesn't contain exploration results:

Read the task descriptions for components mentioned, then:
- Use Glob to find existing: `**/*{ComponentName}*.{tsx,ts}`
- Use Read to verify store properties
- Document decisions before proceeding

**Prefer**: Using cached results (faster, consistent with planning phase)

---

## Phase 3: TDD Execution

**For EACH task in sequence**:

### Pre-Task Setup

**BEFORE starting task**:
1. **USE TodoWrite** to mark task as "in_progress"
2. Reference Integration Plan for file decisions
3. Note verified store property names

### Pre-Task Validation (Quick Check)

**Check Integration Plan**:
- Does task want to CREATE a file that plan says UPDATE? â†’ Follow plan (UPDATE)
- Does task use store property not in verified list? â†’ Use verified name from plan
- Missing dependency? â†’ Document "CREATING JUST-IN-TIME: [name]"

**State Management Decision**:
- Multiple components need state? â†’ Legend-State store
- Complex logic, single feature? â†’ Custom hook
- Simple component state? â†’ useState

---

### TDD Cycle: RED Phase

**CRITICAL**: Write tests BEFORE implementation.

#### Hook Testing Strategy (per CLAUDE.md)

**âš ï¸ DO NOT create standalone hook test files** (e.g., `useFeature.test.ts`)

**Why**: Standalone tests can use wrong property names in BOTH test and implementation, hiding bugs. Tests pass but app breaks.

**CORRECT approach**:
- âœ… Test hooks through components (e.g., `FeatureScreen.test.tsx`)
- âœ… Use REAL stores with VERIFIED property names (from Integration Plan)
- âœ… Test will fail immediately if property names don't match

#### Write Failing Test

**1. USE Read tool** to verify store files (if feature uses stores):
```typescript
// Read the store file FIRST
// Document exact property names: scrapStore.scrap (NOT scrapCount)
```

**2. USE Write tool** to create test file:
```typescript
// For components: ComponentName.test.tsx (co-located)
// For hooks: Test through component that uses it

import { render, screen, userEvent } from '@testing-library/react-native';
import { ComponentName } from './ComponentName'; // Same directory

// If using stores, import REAL stores
import { realStore } from '../path/to/real.store';

describe('ComponentName', () => {
  beforeEach(() => {
    // Reset REAL store with VERIFIED property name
    realStore.property.set(initialValue); // Must match actual store
  });

  test('should [specific behavior from requirement]', async () => {
    // Arrange: Set up with real store
    realStore.property.set(testValue);

    // Act: Render component (which uses hook if testing hook)
    const user = userEvent.setup();
    render(<ComponentName />);

    // Assert: Test user-visible behavior
    expect(screen.getByText('Expected Text')).toBeTruthy();
  });
});
```

**3. USE Bash tool** to run test (verify it FAILS):
```bash
# IMPORTANT: Use cmd.exe for Jest on Windows/WSL (per CLAUDE.md)
cmd.exe /c "cd /d C:\dev\class-one-rapids\frontend && node node_modules/jest/bin/jest.js path/to/test.test.tsx"
```

**Expected**: Test should fail (component doesn't exist yet)

---

### TDD Cycle: GREEN Phase

**Write ONLY enough code to make test pass.**

**USE Write/Edit tool** to create implementation:

```typescript
// Create component/hook/store file
// Co-located with test (same directory)
// Minimal implementation
```

**Examples**:
- Component: Render expected text
- Hook: Return expected value/function
- Store: Define observable with verified property name

**NO**:
- Extra features not tested
- Premature optimization
- Additional properties not needed

**USE Bash tool** to run test (verify it PASSES):
```bash
cmd.exe /c "cd /d C:\dev\class-one-rapids\frontend && node node_modules/jest/bin/jest.js path/to/test.test.tsx"
```

**Expected**: Test should pass now

---

### TDD Cycle: REFACTOR Phase

**Improve code quality while keeping tests green.**

**IF refactoring needed**:
1. **USE Edit tool** to improve code (extract constants, better names, etc.)
2. **USE Bash tool** to run tests after each change
3. **Ensure** all tests remain green

---

### TDD Cycle: Iterate

**Repeat RED-GREEN-REFACTOR** for each requirement in the task:

1. Add new failing test for next behavior
2. Implement minimal code to pass
3. Refactor if needed
4. Run tests to verify all green
5. Continue until ALL task requirements tested and implemented

---

## Phase 4: Task Validation

**BEFORE marking task complete, validate**:

### 1. Functional Integration Test

**Run the actual feature end-to-end**:
- Not just unit tests - verify feature works in real app
- Navigation works (if applicable)
- Data flows correctly
- User can actually use the feature

**RED FLAG**:
- âŒ Unit tests pass but feature doesn't work
- âŒ Component renders but not accessible to users
- âŒ Integration points not wired

### 2. Test Coverage

```bash
# Run coverage check
cmd.exe /c "cd /d C:\dev\class-one-rapids\frontend && node node_modules/jest/bin/jest.js --coverage path/to/test.test.tsx"
```

**Required**: Coverage > 80% for new code

### 3. Code Quality Checks

```bash
# TypeScript check
npm run typecheck

# Lint check
npm run lint
```

**Required**: No errors

### 4. Acceptance Criteria

- [ ] Each criterion from task is met
- [ ] All deliverables present
- [ ] Dependencies properly managed

**ONLY AFTER** all validations pass:
1. **USE TodoWrite** to mark task "completed"
2. **Move to next task** (mark it "in_progress")

---

## Phase 5: Continue Execution

**Execute tasks in order** until:
- âœ… All tasks completed, OR
- âš ï¸ Blocked by missing dependency/unclear requirement

**For each task**:
1. Mark "in_progress" with TodoWrite
2. Reference Integration Plan (use cached decisions)
3. Execute TDD cycle (RED-GREEN-REFACTOR)
4. Validate (integration test, coverage, quality)
5. Mark "completed" with TodoWrite
6. Move to next task

---

## Quick Reference: TDD Checklist

**Per Task**:
- [ ] Mark task "in_progress" (TodoWrite)
- [ ] Reference Integration Plan for file decisions
- [ ] Use verified store property names
- [ ] RED: Write failing test FIRST (use real stores)
- [ ] GREEN: Write minimal code to pass
- [ ] REFACTOR: Improve while keeping tests green
- [ ] Iterate for all requirements
- [ ] Validate: Integration test, coverage > 80%, quality checks
- [ ] Mark task "completed" (TodoWrite)

**Testing Rules** (per CLAUDE.md):
- âœ… Test hooks through components, NOT standalone
- âœ… Use real stores with verified property names
- âœ… Co-locate tests next to implementation
- âœ… Use cmd.exe for Jest on Windows/WSL

---

## Success Criteria

Execution successful when:
- âœ… All tasks marked "completed" in TodoWrite
- âœ… All tests passing
- âœ… Test coverage > 80% for new code
- âœ… No TypeScript errors
- âœ… No lint errors
- âœ… Features work end-to-end in real app
- âœ… No duplicate files created
- âœ… Store properties match verified names

---

## When Blocked

**If you cannot complete a task**:
1. Document the blocker clearly
2. Mark task as "in_progress" (not completed)
3. Report to user what's needed
4. **DO NOT** mark complete if:
   - Tests are failing
   - Implementation is partial
   - Integration is broken
   - Dependencies are missing

**Ask user for**:
- Clarification on requirements
- Missing dependencies
- Architectural decisions if plan unclear
