# Executable Task List: Core Combat Tap Mechanic
# Generated: 2025-09-20
# Feature: Core Combat Tap Mechanic for Asheron's Call Idler

# ============================================
# PHASE 1: PROJECT SETUP & FOUNDATION
# ============================================

- task_id: setup_001
  name: "Initialize Expo React Native project with TypeScript"
  type: setup
  priority: P0
  dependencies: []
  estimated_time: "30 minutes"

  agent_prompt: |
    # CONTEXT
    You are setting up a new React Native game project using Expo.
    Current state: Empty directory
    This task establishes the foundation for the Asheron's Call Idler mobile game.

    # OBJECTIVE
    Create a new Expo project with TypeScript configuration optimized for game development.
    Success looks like: Runnable Expo app with TypeScript support and proper structure.

    # STYLE & APPROACH
    - Use Expo SDK 49+ with managed workflow
    - Follow React Native best practices
    - Prioritize performance and type safety

    # SPECIFICATIONS
    Input: Empty project directory
    Output: Configured Expo project with TypeScript
    Constraints: Must support iOS 12+ and Android 8.0+

    # IMPLEMENTATION STEPS
    1. Run `npx create-expo-app asheron-idler --template expo-template-blank-typescript`
    2. Navigate to project directory
    3. Update app.json with proper game configuration:
       - Set orientation to portrait
       - Configure splash screen
       - Set bundle identifier
    4. Create directory structure:
       - src/components/
       - src/services/
       - src/types/
       - src/utils/
       - src/assets/
    5. Install core dependencies:
       - expo install react-native-reanimated
       - expo install react-native-gesture-handler
       - expo install expo-haptics
       - expo install expo-audio
    6. Configure babel.config.js for Reanimated
    7. Create src/types/index.ts with basic type definitions

    # VALIDATION
    - [ ] Project runs with `npx expo start`
    - [ ] TypeScript compilation succeeds
    - [ ] Directory structure exists
    - [ ] All dependencies installed

  tools_required: [Bash, Write, Edit]
  files_to_create:
    - app.json
    - tsconfig.json
    - src/types/index.ts
    - babel.config.js

  validation_script: |
    npx expo start --no-dev --minify &
    sleep 10
    kill %1
    tsc --noEmit

- task_id: setup_002
  name: "Install and configure Legend-state for state management"
  type: setup
  priority: P0
  dependencies: [setup_001]
  estimated_time: "20 minutes"

  agent_prompt: |
    # CONTEXT
    You are configuring Legend-state v3 for reactive state management.
    Current state: Basic Expo project exists
    This provides the state management foundation for game mechanics.

    # OBJECTIVE
    Install and configure Legend-state with TypeScript support and persistence.
    Success looks like: Working state management with type-safe observables.

    # STYLE & APPROACH
    - Follow Legend-state v3 patterns
    - Use fine-grained reactivity
    - Prioritize performance

    # SPECIFICATIONS
    Input: Existing Expo project
    Output: Configured Legend-state with game state structure
    Constraints: Must support high-frequency updates

    # IMPLEMENTATION STEPS
    1. Install Legend-state: `npm install @legendapp/state`
    2. Create src/state/gameState.ts with initial structure:
       ```typescript
       import { observable } from '@legendapp/state'

       export const gameState$ = observable({
         player: {
           power: 1,
           combo: 0,
           pyreals: 0
         },
         combat: {
           isActive: false,
           currentEnemy: null,
           lastHitTime: 0
         }
       })
       ```
    3. Create src/state/types.ts with state type definitions
    4. Create src/hooks/useGameState.ts for React integration
    5. Set up persistence configuration in src/state/persistence.ts
    6. Create src/state/index.ts to export all state modules

    # VALIDATION
    - [ ] Legend-state imports without errors
    - [ ] State observable is reactive
    - [ ] TypeScript types are properly inferred
    - [ ] State updates trigger re-renders

  tools_required: [Bash, Write, Edit]
  files_to_create:
    - src/state/gameState.ts
    - src/state/types.ts
    - src/hooks/useGameState.ts
    - src/state/persistence.ts
    - src/state/index.ts

  validation_script: |
    npm run typescript
    grep -q "observable" src/state/gameState.ts

# ============================================
# PHASE 2: CORE COMBAT COMPONENTS
# ============================================

- task_id: combat_001
  name: "Implement touch input handler with hit detection"
  type: implementation
  priority: P0
  dependencies: [setup_002]
  estimated_time: "45 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing the core touch input system for combat.
    Current state: Project setup complete with state management
    This is the primary interaction mechanism for the game.

    # OBJECTIVE
    Create a responsive touch input handler that detects taps and validates hits.
    Success looks like: <100ms response time from tap to hit registration.

    # STYLE & APPROACH
    - Use React Native Gesture Handler for performance
    - Follow iOS/Android touch best practices
    - Prioritize responsiveness over accuracy

    # SPECIFICATIONS
    Input: Touch events with x,y coordinates
    Output: Validated hit results with timing data
    Constraints: Must handle rapid taps without lag

    # IMPLEMENTATION STEPS
    1. Create src/components/combat/CombatArea.tsx:
       - Use GestureDetector from react-native-gesture-handler
       - Implement tap gesture with position tracking
       - Add visual feedback on touch
    2. Create src/services/HitDetection.ts:
       ```typescript
       export class HitDetectionService {
         checkHit(point: Point2D, enemy: Enemy): HitResult {
           // Implement collision detection
           // Check if point is within enemy bounds
           // Check if point hits weakness spot
           // Return hit result with type and position
         }
       }
       ```
    3. Create src/types/combat.ts with combat type definitions
    4. Implement hit zone registration in CombatArea
    5. Add performance monitoring for tap response time
    6. Create src/utils/geometry.ts for collision math

    # VALIDATION
    - [ ] Taps register within 100ms
    - [ ] Hit detection accurately identifies enemy bounds
    - [ ] Rapid tapping doesn't cause lag
    - [ ] Touch coordinates are properly scaled

  tools_required: [Read, Write, Edit]
  files_to_create:
    - src/components/combat/CombatArea.tsx
    - src/services/HitDetection.ts
    - src/types/combat.ts
    - src/utils/geometry.ts

  validation_script: |
    npm test -- HitDetection
    npm run lint src/components/combat/

- task_id: combat_002
  name: "Create enemy component with weakness spot system"
  type: implementation
  priority: P0
  dependencies: [combat_001]
  estimated_time: "40 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing the enemy system with dynamic weakness spots.
    Current state: Touch input system exists
    Enemies are the primary target for player interactions.

    # OBJECTIVE
    Create enemy component with visual weakness spots that provide bonus damage.
    Success looks like: Clearly visible, animated weakness spots on enemies.

    # STYLE & APPROACH
    - Use React Native Animated for smooth animations
    - Follow game UI best practices
    - Prioritize visual clarity

    # SPECIFICATIONS
    Input: Enemy data with type and stats
    Output: Rendered enemy with interactive weakness spots
    Constraints: Must maintain 60 FPS with animations

    # IMPLEMENTATION STEPS
    1. Create src/components/enemy/Enemy.tsx:
       ```typescript
       export const Enemy: React.FC<EnemyProps> = ({ enemyData }) => {
         // Render enemy sprite
         // Generate 2-4 weakness spots
         // Animate weakness spot pulsing
         // Handle hit registration
       }
       ```
    2. Create src/components/enemy/WeaknessSpot.tsx:
       - Pulsing animation using Reanimated
       - Glow effect for visibility
       - Size based on difficulty
    3. Create src/services/WeaknessGenerator.ts:
       - Algorithm for spot placement
       - Ensure spots don't overlap
       - Randomize positions per spawn
    4. Add enemy sprites to src/assets/enemies/
    5. Create src/components/enemy/HealthBar.tsx
    6. Implement enemy state management in gameState

    # VALIDATION
    - [ ] Enemy renders with visible sprite
    - [ ] Weakness spots pulse smoothly
    - [ ] Spots are clearly distinguishable
    - [ ] Health bar displays correctly

  tools_required: [Read, Write, Edit]
  files_to_create:
    - src/components/enemy/Enemy.tsx
    - src/components/enemy/WeaknessSpot.tsx
    - src/services/WeaknessGenerator.ts
    - src/components/enemy/HealthBar.tsx

  validation_script: |
    npm test -- Enemy
    npm run lint src/components/enemy/

- task_id: combat_003
  name: "Implement damage calculation engine"
  type: implementation
  priority: P0
  dependencies: [combat_002]
  estimated_time: "35 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing the damage calculation system.
    Current state: Enemies and hit detection exist
    Damage calculation drives progression and feedback.

    # OBJECTIVE
    Create damage engine that calculates damage based on power, weakness hits, and combos.
    Success looks like: Predictable, scalable damage with clear multipliers.

    # STYLE & APPROACH
    - Use pure functions for calculations
    - Follow incremental game formulas
    - Prioritize numerical stability

    # SPECIFICATIONS
    Input: Hit result, player stats, combo count
    Output: Calculated damage value with breakdown
    Constraints: Support damage up to 999,999,999

    # IMPLEMENTATION STEPS
    1. Create src/services/DamageEngine.ts:
       ```typescript
       export class DamageEngine {
         calculateDamage(hit: HitResult, player: Player): DamageResult {
           let damage = player.power;

           // Apply weakness multiplier (1.5x - 2x)
           if (hit.isWeaknessHit) {
             damage *= this.getWeaknessMultiplier();
           }

           // Apply combo multiplier (up to 5x)
           damage *= this.getComboMultiplier(player.combo);

           return {
             final: Math.floor(damage),
             breakdown: { /* multiplier details */ }
           };
         }
       }
       ```
    2. Create src/services/ComboSystem.ts:
       - Track consecutive hits
       - Implement combo timeout (2 seconds)
       - Calculate multiplier curve
    3. Create src/utils/numbers.ts for number formatting
    4. Add damage events to state management
    5. Create unit tests for damage formulas
    6. Document damage scaling in comments

    # VALIDATION
    - [ ] Damage calculations are consistent
    - [ ] Weakness hits apply correct multiplier
    - [ ] Combo system increments properly
    - [ ] Large numbers display correctly

  tools_required: [Read, Write, Edit]
  files_to_create:
    - src/services/DamageEngine.ts
    - src/services/ComboSystem.ts
    - src/utils/numbers.ts
    - src/services/__tests__/DamageEngine.test.ts

  validation_script: |
    npm test -- DamageEngine
    npm test -- ComboSystem

# ============================================
# PHASE 3: FEEDBACK SYSTEMS
# ============================================

- task_id: feedback_001
  name: "Create particle effects system for combat feedback"
  type: implementation
  priority: P0
  dependencies: [combat_003]
  estimated_time: "50 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing the particle effects system for visual feedback.
    Current state: Combat mechanics functional
    Visual feedback is crucial for player satisfaction.

    # OBJECTIVE
    Create performant particle system for hit impacts and effects.
    Success looks like: Smooth particles that enhance combat feel without lag.

    # STYLE & APPROACH
    - Use object pooling for performance
    - Follow mobile particle best practices
    - Prioritize performance over quantity

    # SPECIFICATIONS
    Input: Effect type and position
    Output: Animated particles with physics
    Constraints: Max 100 simultaneous particles

    # IMPLEMENTATION STEPS
    1. Install Skia: `expo install @shopify/react-native-skia`
    2. Create src/components/effects/ParticleSystem.tsx:
       ```typescript
       export const ParticleSystem: React.FC = () => {
         // Initialize particle pool
         // Render particles using Skia Canvas
         // Update particle positions each frame
         // Recycle completed particles
       }
       ```
    3. Create src/services/ParticlePool.ts:
       - Pre-allocate 100 particle objects
       - Implement acquire/release methods
       - Track active particles
    4. Create src/components/effects/ImpactEffect.tsx
    5. Create src/components/effects/ComboEffect.tsx
    6. Add particle textures to assets/particles/
    7. Optimize rendering with batch drawing

    # VALIDATION
    - [ ] Particles render at 60 FPS
    - [ ] Object pool prevents memory leaks
    - [ ] Effects trigger on hits
    - [ ] No frame drops during combat

  tools_required: [Bash, Read, Write, Edit]
  files_to_create:
    - src/components/effects/ParticleSystem.tsx
    - src/services/ParticlePool.ts
    - src/components/effects/ImpactEffect.tsx
    - src/components/effects/ComboEffect.tsx

  validation_script: |
    npm test -- ParticleSystem
    npm run performance:test

- task_id: feedback_002
  name: "Implement damage number display system"
  type: implementation
  priority: P0
  dependencies: [feedback_001]
  estimated_time: "30 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing floating damage numbers for combat feedback.
    Current state: Particle system exists
    Damage numbers provide critical feedback for player actions.

    # OBJECTIVE
    Create animated damage numbers that float up and fade out.
    Success looks like: Clear, readable numbers with satisfying animation.

    # STYLE & APPROACH
    - Use Reanimated for smooth animations
    - Follow RPG damage number conventions
    - Prioritize readability

    # SPECIFICATIONS
    Input: Damage value and hit position
    Output: Animated floating text
    Constraints: Support numbers up to 999M with abbreviation

    # IMPLEMENTATION STEPS
    1. Create src/components/effects/DamageNumber.tsx:
       ```typescript
       export const DamageNumber: React.FC<DamageNumberProps> = ({
         damage, position, isCritical
       }) => {
         // Animate position (float up)
         // Animate opacity (fade out)
         // Scale based on damage magnitude
         // Color based on damage type
       }
       ```
    2. Create src/components/effects/DamageNumberPool.tsx:
       - Manage pool of 20 damage number components
       - Queue if pool exhausted
       - Auto-cleanup after animation
    3. Create src/utils/formatters.ts:
       - Format large numbers (1.5M, 23.4B)
       - Color coding for damage types
       - Font size scaling algorithm
    4. Add custom fonts for damage numbers
    5. Create critical hit special effects
    6. Test with various damage ranges

    # VALIDATION
    - [ ] Numbers are clearly readable
    - [ ] Animation completes in 1.5 seconds
    - [ ] Large numbers format correctly
    - [ ] No overlapping numbers

  tools_required: [Read, Write, Edit]
  files_to_create:
    - src/components/effects/DamageNumber.tsx
    - src/components/effects/DamageNumberPool.tsx
    - src/utils/formatters.ts
    - src/assets/fonts/damage-font.ttf

  validation_script: |
    npm test -- DamageNumber
    npm run lint src/components/effects/

- task_id: feedback_003
  name: "Integrate audio feedback system"
  type: implementation
  priority: P0
  dependencies: [feedback_002]
  estimated_time: "40 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing the audio system for combat feedback.
    Current state: Visual feedback systems complete
    Audio enhances the visceral feel of combat.

    # OBJECTIVE
    Create responsive audio system with layered sound effects.
    Success looks like: Instant audio feedback with no latency.

    # STYLE & APPROACH
    - Use Expo Audio with preloading
    - Follow game audio best practices
    - Prioritize low latency

    # SPECIFICATIONS
    Input: Combat events
    Output: Synchronized sound effects
    Constraints: <50ms audio latency

    # IMPLEMENTATION STEPS
    1. Create src/services/AudioManager.ts:
       ```typescript
       export class AudioManager {
         private sounds: Map<string, Audio.Sound> = new Map();

         async preloadSounds() {
           // Load all combat sounds
           // Set low-latency mode on Android
           // Configure audio session
         }

         async playSound(soundId: string, options?: PlayOptions) {
           // Play with volume/pitch variation
           // Handle concurrent sounds
         }
       }
       ```
    2. Add sound files to assets/audio/:
       - hit_normal.mp3
       - hit_weakness.mp3
       - hit_critical.mp3
       - combo_1.mp3 through combo_5.mp3
       - enemy_defeat.mp3
       - coin_collect.mp3
    3. Create src/hooks/useAudio.ts for React integration
    4. Implement sound pooling for repeated sounds
    5. Add volume controls to settings
    6. Create audio event queue for timing

    # VALIDATION
    - [ ] Sounds play within 50ms of trigger
    - [ ] No audio glitches or pops
    - [ ] Concurrent sounds mix properly
    - [ ] Volume controls work

  tools_required: [Read, Write, Edit, Bash]
  files_to_create:
    - src/services/AudioManager.ts
    - src/hooks/useAudio.ts
    - src/services/AudioPool.ts
    - assets/audio/hit_normal.mp3

  validation_script: |
    npm test -- AudioManager
    expo prebuild

- task_id: feedback_004
  name: "Add screen shake and enemy deformation effects"
  type: implementation
  priority: P1
  dependencies: [feedback_003]
  estimated_time: "35 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing screen shake and enemy deformation for impact feel.
    Current state: Core feedback systems complete
    These effects add weight to player actions.

    # OBJECTIVE
    Create configurable screen shake and enemy squash/stretch animations.
    Success looks like: Satisfying impact feel without motion sickness.

    # STYLE & APPROACH
    - Use Reanimated for performant animations
    - Follow animation principles (squash/stretch)
    - Make effects configurable for accessibility

    # SPECIFICATIONS
    Input: Hit impact data
    Output: Screen shake and enemy deformation
    Constraints: Smooth animation at 60 FPS

    # IMPLEMENTATION STEPS
    1. Create src/components/effects/ScreenShake.tsx:
       ```typescript
       export const ScreenShake: React.FC<PropsWithChildren> = ({ children }) => {
         const shakeAnimation = useSharedValue(0);

         const shake = (intensity: number) => {
           // Implement shake algorithm
           // Use spring animation for natural feel
           // Decay over 200-300ms
         };

         return (
           <Animated.View style={animatedStyle}>
             {children}
           </Animated.View>
         );
       }
       ```
    2. Create src/components/effects/Deformation.tsx:
       - Squash on hit (scale Y: 0.8, scale X: 1.2)
       - Spring back animation
       - Vary by damage magnitude
    3. Add shake configuration to settings
    4. Create accessibility options:
       - Reduce motion toggle
       - Shake intensity slider
    5. Test on various devices for performance
    6. Add easing curves for natural motion

    # VALIDATION
    - [ ] Shake feels impactful not nauseating
    - [ ] Deformation looks natural
    - [ ] Settings properly disable effects
    - [ ] Maintains 60 FPS

  tools_required: [Read, Write, Edit]
  files_to_create:
    - src/components/effects/ScreenShake.tsx
    - src/components/effects/Deformation.tsx
    - src/utils/animations.ts
    - src/config/accessibility.ts

  validation_script: |
    npm test -- ScreenShake
    npm test -- Deformation

# ============================================
# PHASE 4: GAME LOOP & PROGRESSION
# ============================================

- task_id: game_001
  name: "Implement core game loop and enemy spawning"
  type: implementation
  priority: P0
  dependencies: [feedback_004]
  estimated_time: "45 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing the main game loop and enemy management.
    Current state: All combat components exist
    The game loop ties everything together into playable experience.

    # OBJECTIVE
    Create game loop that manages enemy spawning, combat state, and progression.
    Success looks like: Continuous gameplay with proper enemy cycling.

    # STYLE & APPROACH
    - Use requestAnimationFrame for smooth updates
    - Follow game loop best practices
    - Prioritize consistent timing

    # SPECIFICATIONS
    Input: Game state and delta time
    Output: Updated game state each frame
    Constraints: Maintain steady 60 FPS

    # IMPLEMENTATION STEPS
    1. Create src/services/GameLoop.ts:
       ```typescript
       export class GameLoop {
         private lastTime = 0;
         private enemies: Enemy[] = [];

         start() {
           this.loop();
         }

         private loop = (currentTime: number) => {
           const deltaTime = currentTime - this.lastTime;

           this.update(deltaTime);
           this.render();

           requestAnimationFrame(this.loop);
         }

         private update(deltaTime: number) {
           // Update enemy states
           // Check for defeated enemies
           // Spawn new enemies
           // Update combo timers
         }
       }
       ```
    2. Create src/services/EnemySpawner.ts:
       - Progressive difficulty scaling
       - Enemy type selection
       - Position randomization
    3. Create src/screens/GameScreen.tsx:
       - Integrate all combat components
       - Handle game state
       - Display HUD elements
    4. Create src/components/HUD/index.tsx:
       - Power display
       - Pyreals counter
       - Combo indicator
    5. Implement pause/resume functionality
    6. Add background music loop

    # VALIDATION
    - [ ] Game loop runs at steady 60 FPS
    - [ ] Enemies spawn continuously
    - [ ] Combat flows smoothly
    - [ ] HUD updates properly

  tools_required: [Read, Write, Edit]
  files_to_create:
    - src/services/GameLoop.ts
    - src/services/EnemySpawner.ts
    - src/screens/GameScreen.tsx
    - src/components/HUD/index.tsx

  validation_script: |
    npm test -- GameLoop
    npm run start

- task_id: game_002
  name: "Implement currency system and auto-collection"
  type: implementation
  priority: P0
  dependencies: [game_001]
  estimated_time: "30 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing the Pyreal currency system with auto-collection.
    Current state: Game loop and combat functional
    Currency provides progression and reward feedback.

    # OBJECTIVE
    Create currency drops from defeated enemies with magnetic collection.
    Success looks like: Satisfying loot collection with clear value feedback.

    # STYLE & APPROACH
    - Use smooth animations for collection
    - Follow loot game conventions
    - Prioritize visual satisfaction

    # SPECIFICATIONS
    Input: Enemy defeat event
    Output: Currency drop and collection animation
    Constraints: Auto-collect within 1 second

    # IMPLEMENTATION STEPS
    1. Create src/components/loot/Pyreal.tsx:
       ```typescript
       export const Pyreal: React.FC<PyrealProps> = ({
         amount, position, onCollect
       }) => {
         // Spawn animation (pop out)
         // Magnetic pull to collection point
         // Sparkle effect during flight
         // Trigger collection callback
       }
       ```
    2. Create src/services/LootManager.ts:
       - Calculate loot drops
       - Manage active loot
       - Handle collection events
    3. Create src/components/loot/LootPool.tsx:
       - Pool of 20 loot objects
       - Queue if exhausted
    4. Add Pyreal sprite and effects
    5. Create collection sound effect
    6. Update HUD with currency animation

    # VALIDATION
    - [ ] Pyreals drop on enemy defeat
    - [ ] Auto-collection works smoothly
    - [ ] Currency updates in HUD
    - [ ] Collection feels satisfying

  tools_required: [Read, Write, Edit]
  files_to_create:
    - src/components/loot/Pyreal.tsx
    - src/services/LootManager.ts
    - src/components/loot/LootPool.tsx
    - assets/sprites/pyreal.png

  validation_script: |
    npm test -- LootManager
    npm test -- Pyreal

# ============================================
# PHASE 5: TESTING & OPTIMIZATION
# ============================================

- task_id: test_001
  name: "Create comprehensive unit tests for combat systems"
  type: testing
  priority: P0
  dependencies: [game_002]
  estimated_time: "40 minutes"

  agent_prompt: |
    # CONTEXT
    You are creating unit tests for all combat systems.
    Current state: Full combat system implemented
    Tests ensure reliability and prevent regressions.

    # OBJECTIVE
    Create comprehensive test suite with >80% coverage.
    Success looks like: All critical paths tested with clear assertions.

    # STYLE & APPROACH
    - Use Jest and React Native Testing Library
    - Follow AAA pattern (Arrange, Act, Assert)
    - Prioritize critical paths

    # SPECIFICATIONS
    Input: Test scenarios
    Output: Passing test suite
    Constraints: Must run in <30 seconds

    # IMPLEMENTATION STEPS
    1. Create src/__tests__/combat/HitDetection.test.ts:
       ```typescript
       describe('HitDetection', () => {
         it('should detect hits within enemy bounds', () => {
           // Test hit detection accuracy
         });

         it('should identify weakness spot hits', () => {
           // Test weakness detection
         });

         it('should handle rapid taps', () => {
           // Test performance under load
         });
       });
       ```
    2. Create src/__tests__/combat/DamageEngine.test.ts
    3. Create src/__tests__/combat/ComboSystem.test.ts
    4. Create src/__tests__/effects/ParticleSystem.test.ts
    5. Create integration tests in __tests__/integration/
    6. Add performance benchmarks
    7. Configure coverage reporting

    # VALIDATION
    - [ ] All tests pass
    - [ ] >80% code coverage
    - [ ] Tests run in <30 seconds
    - [ ] No console errors

  tools_required: [Read, Write, Edit, Bash]
  files_to_create:
    - src/__tests__/combat/HitDetection.test.ts
    - src/__tests__/combat/DamageEngine.test.ts
    - src/__tests__/combat/ComboSystem.test.ts
    - src/__tests__/effects/ParticleSystem.test.ts

  validation_script: |
    npm test -- --coverage
    npm test -- --watchAll=false

- task_id: test_002
  name: "Implement performance monitoring and optimization"
  type: testing
  priority: P0
  dependencies: [test_001]
  estimated_time: "35 minutes"

  agent_prompt: |
    # CONTEXT
    You are implementing performance monitoring and optimizations.
    Current state: Combat system complete with tests
    Performance is critical for mobile gaming experience.

    # OBJECTIVE
    Add performance monitoring and optimize for 60 FPS on target devices.
    Success looks like: Consistent frame rate with detailed metrics.

    # STYLE & APPROACH
    - Use React DevTools Profiler
    - Follow mobile optimization best practices
    - Prioritize battery efficiency

    # SPECIFICATIONS
    Input: Running game
    Output: Performance metrics and optimizations
    Constraints: <100ms tap response, 60 FPS

    # IMPLEMENTATION STEPS
    1. Create src/services/PerformanceMonitor.ts:
       ```typescript
       export class PerformanceMonitor {
         private metrics = {
           fps: 0,
           tapResponseTime: 0,
           memoryUsage: 0,
           renderTime: 0
         };

         measureTapResponse(start: number, end: number) {
           this.metrics.tapResponseTime = end - start;
         }

         measureFPS() {
           // Calculate rolling FPS average
         }
       }
       ```
    2. Add FPS counter overlay in development
    3. Implement render optimizations:
       - Memoize expensive components
       - Use React.memo for pure components
       - Optimize re-render triggers
    4. Profile with React DevTools
    5. Add memory leak detection
    6. Create performance dashboard
    7. Document optimization findings

    # VALIDATION
    - [ ] FPS counter shows 60 FPS
    - [ ] Tap response <100ms
    - [ ] Memory usage <50MB
    - [ ] No memory leaks detected

  tools_required: [Read, Write, Edit, Bash]
  files_to_create:
    - src/services/PerformanceMonitor.ts
    - src/components/debug/FPSCounter.tsx
    - src/components/debug/PerformanceOverlay.tsx
    - docs/performance-report.md

  validation_script: |
    npm run performance:test
    npm run profile

# ============================================
# PHASE 6: POLISH & DEPLOYMENT
# ============================================

- task_id: polish_001
  name: "Add tutorial and onboarding flow"
  type: implementation
  priority: P1
  dependencies: [test_002]
  estimated_time: "40 minutes"

  agent_prompt: |
    # CONTEXT
    You are creating the tutorial and onboarding experience.
    Current state: Complete combat system
    Tutorial ensures players understand core mechanics.

    # OBJECTIVE
    Create guided tutorial that teaches tap combat and weakness spots.
    Success looks like: Players understand mechanics within 30 seconds.

    # STYLE & APPROACH
    - Use progressive disclosure
    - Follow mobile tutorial best practices
    - Keep it brief and interactive

    # SPECIFICATIONS
    Input: New player state
    Output: Completed tutorial flag
    Constraints: Complete in <1 minute

    # IMPLEMENTATION STEPS
    1. Create src/screens/TutorialScreen.tsx:
       ```typescript
       export const TutorialScreen: React.FC = () => {
         const [step, setStep] = useState(0);

         const tutorialSteps = [
           { text: "Tap the enemy to attack!", action: "tap" },
           { text: "Hit the glowing spots for bonus damage!", action: "weakness" },
           { text: "Chain hits for combo multipliers!", action: "combo" }
         ];

         // Guide player through each step
         // Highlight relevant UI elements
         // Validate completion
       }
       ```
    2. Create src/components/tutorial/TutorialOverlay.tsx
    3. Create src/components/tutorial/HighlightCircle.tsx
    4. Add tutorial completion to persistent state
    5. Create skip option for returning players
    6. Add celebration on tutorial completion

    # VALIDATION
    - [ ] Tutorial loads for new players
    - [ ] Each step validates correctly
    - [ ] Skip option works
    - [ ] Tutorial state persists

  tools_required: [Read, Write, Edit]
  files_to_create:
    - src/screens/TutorialScreen.tsx
    - src/components/tutorial/TutorialOverlay.tsx
    - src/components/tutorial/HighlightCircle.tsx
    - src/services/TutorialManager.ts

  validation_script: |
    npm test -- Tutorial
    npm run start

- task_id: deploy_001
  name: "Configure build and prepare for deployment"
  type: deployment
  priority: P0
  dependencies: [polish_001]
  estimated_time: "30 minutes"

  agent_prompt: |
    # CONTEXT
    You are preparing the app for production deployment.
    Current state: Feature complete with tests passing
    Deployment configuration ensures smooth release.

    # OBJECTIVE
    Configure production build with optimizations and monitoring.
    Success looks like: Optimized builds for iOS and Android.

    # STYLE & APPROACH
    - Follow Expo EAS Build best practices
    - Include error tracking
    - Prioritize app size optimization

    # SPECIFICATIONS
    Input: Development build
    Output: Production-ready builds
    Constraints: <50MB app size

    # IMPLEMENTATION STEPS
    1. Configure eas.json:
       ```json
       {
         "build": {
           "production": {
             "releaseChannel": "production",
             "env": {
               "EXPO_PUBLIC_ENV": "production"
             }
           }
         }
       }
       ```
    2. Update app.json with production settings:
       - Version numbers
       - Bundle identifiers
       - Splash screen
       - App icons
    3. Set up Sentry for error tracking:
       - Install @sentry/react-native
       - Configure DSN
       - Add error boundaries
    4. Configure Firebase Analytics
    5. Optimize bundle size:
       - Enable Hermes
       - Remove unused dependencies
       - Minimize assets
    6. Create production environment file
    7. Generate app store assets

    # VALIDATION
    - [ ] Production build succeeds
    - [ ] App size <50MB
    - [ ] Error tracking configured
    - [ ] Analytics working

  tools_required: [Read, Write, Edit, Bash]
  files_to_create:
    - eas.json
    - .env.production
    - sentry.config.js
    - firebase.config.js

  validation_script: |
    eas build --platform ios --profile production --local
    eas build --platform android --profile production --local

# ============================================
# EXECUTION METADATA
# ============================================

metadata:
  total_tasks: 15
  estimated_total_time: "9 hours"
  critical_path: [setup_001, setup_002, combat_001, combat_002, combat_003, feedback_001, feedback_002, feedback_003, game_001, game_002, test_001, deploy_001]
  parallel_groups:
    - [feedback_001, feedback_002, feedback_003]
    - [test_001, test_002]
    - [polish_001]

  success_criteria:
    - "Tap response time <100ms"
    - "Consistent 60 FPS during combat"
    - "All tests passing with >80% coverage"
    - "Memory usage <50MB"
    - "App size <50MB"
    - "No critical errors in production"

# Generated: 2025-09-20 06:50:00