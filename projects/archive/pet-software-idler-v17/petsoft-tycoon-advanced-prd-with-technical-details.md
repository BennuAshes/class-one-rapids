# PetSoft Tycoon: Product Requirements Document with Technical Implementation

## 1. Executive Summary

PetSoft Tycoon is an incremental idle game where players build and manage a software company from a single developer to a tech giant. Players progress through seven departments (Development, Sales, Customer Experience, Product, Design, QA, Marketing), each with unique mechanics and upgrade paths. The game features a prestige system called "Investor Rounds" that provides permanent bonuses for long-term progression.

**Key Success Metrics:**
- Target DAU: 10,000+ within 6 months
- 7-day retention: 30%+
- 30-day retention: 15%+
- Average session time: 15+ minutes

## 2. Product Overview

### 2.1 Core Gameplay Loop

The game follows a classic incremental progression pattern:
1. **Click to Generate**: Players start by clicking "WRITE CODE" to generate Lines of Code
2. **Convert Resources**: Lines of Code convert to Features (Basic → Advanced → Premium)
3. **Hire Employees**: Automate production by hiring developers, sales reps, and other specialists
4. **Unlock Departments**: Progressive unlock of 7 specialized departments
5. **Upgrade Systems**: Purchase upgrades to multiply efficiency and unlock new mechanics
6. **Prestige Reset**: Reset progress for permanent bonuses via "Investor Rounds"

### 2.2 Resource Economy

**Primary Resources:**
- Lines of Code (generated by clicking/developers)
- Features (Basic, Advanced, Premium - converted from code)
- Leads (generated by sales department)
- Revenue ($ - generated by combining leads + features)

**Conversion Rates:**
- 10 lines = 1 Basic Feature
- 100 lines = 1 Advanced Feature
- 1,000 lines = 1 Premium Feature
- Revenue = Leads × Features (rates: $50, $500, $5,000)

### 2.3 Progression Curve

**Cost Scaling Formula:** `cost = baseCost × 1.15^owned`
**Major Milestones:**
- $10: First automation (Junior Dev)
- $500: Sales department unlock
- $50K: Manager automation
- $10M: Prestige system
- $1B: Victory condition

## 3. User Stories & Acceptance Criteria

### 3.1 Tutorial and Onboarding

**US-001: New Player Introduction**
*As a new player, I want a guided introduction so I understand the core mechanics.*

**Acceptance Criteria:**
- [ ] Tutorial begins immediately on first launch
- [ ] Step 1: Prompt to click "WRITE CODE" button 10 times
- [ ] Step 2: Show Lines of Code counter incrementing with animation
- [ ] Step 3: Explain feature conversion (10 lines → 1 Basic Feature)
- [ ] Step 4: Guide first Junior Dev purchase at $10
- [ ] Step 5: Demonstrate passive income generation
- [ ] Tutorial can be skipped after Step 2
- [ ] All tutorial steps have clear visual highlights
- [ ] Tutorial state persists through app restarts

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── tutorial/
│   ├── TutorialService.ts         # Manages tutorial state and progression
│   ├── TutorialOverlay.tsx        # Visual overlay component
│   ├── TutorialEvents.ts          # Tutorial-specific events
│   ├── components/
│   │   ├── TutorialStep.tsx       # Individual step component
│   │   ├── TutorialHighlight.tsx  # Highlight overlay
│   │   └── TutorialTooltip.tsx    # Tooltip component
│   └── index.ts                   # Public API
```

**Data Model (Legend-State observable stores):**
```typescript
class TutorialService {
  #state$ = observable({
    isActive: false,
    currentStep: 0,
    completedSteps: new Set<number>(),
    canSkip: false,
    hasSkipped: false,
    persistent: {
      hasCompletedTutorial: false,
      lastCompletedStep: -1
    }
  });

  // Public capabilities
  startTutorial(): void
  nextStep(): void
  skipTutorial(): void
  highlightElement(elementId: string): void
  clearHighlight(): void
  getCurrentStep(): TutorialStep | null
  getProgress(): { current: number; total: number }
}
```

**API/Service methods:**
- `tutorial.start()` - Initiates tutorial sequence
- `tutorial.advance()` - Moves to next step
- `tutorial.skip()` - Allows skipping after step 2
- `tutorial.highlight(elementId)` - Shows visual highlight
- `tutorial.persist()` - Saves tutorial progress

**Event coordination between features:**
```typescript
// Tutorial listens for game events to advance
eventBus.on('game.codeGenerated', (data) => {
  if (tutorial.getCurrentStep()?.id === 'firstClick') {
    tutorial.advance();
  }
});

// Tutorial triggers game events
eventBus.emit('tutorial.stepCompleted', { 
  step: 'firstPurchase',
  unlocks: ['automation'] 
});
```

**Error handling approach:**
- Graceful degradation if tutorial data is corrupted
- Fallback to skip tutorial if overlay rendering fails
- Recovery mechanism to restart from last valid step

**Performance considerations:**
- Lazy load tutorial components only when needed
- Debounce highlight positioning calculations
- Use memo for expensive step validation logic

**Testing strategy:**
- Unit tests for tutorial progression logic
- Integration tests for cross-feature event coordination
- E2E tests for complete tutorial flow
- Visual regression tests for overlay positioning

---

**US-002: Progressive Feature Discovery**
*As a player, I want to discover new features naturally through gameplay.*

**Acceptance Criteria:**
- [ ] New departments show "Coming Soon" placeholder until unlock threshold
- [ ] Unlock notifications appear with celebratory animation
- [ ] First unlock (Sales at $500) includes brief explanation
- [ ] Help tooltips available for all game elements
- [ ] Achievement notifications guide progression milestones

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── progression/
│   ├── ProgressionService.ts      # Tracks unlock thresholds
│   ├── UnlockNotification.tsx     # Celebration component
│   ├── FeatureDiscovery.tsx       # Coming soon placeholders
│   ├── components/
│   │   ├── UnlockAnimation.tsx    # Animated unlock sequence
│   │   ├── ProgressBar.tsx        # Threshold progress
│   │   └── FeatureTooltip.tsx     # Help system
│   └── index.ts
```

**Data Model:**
```typescript
class ProgressionService {
  #state$ = observable({
    unlockedFeatures: new Set<string>(),
    thresholds: new Map<string, UnlockThreshold>(),
    pendingUnlocks: Array<PendingUnlock>(),
    achievementProgress: new Map<string, number>()
  });

  checkThresholds(currentMetrics: GameMetrics): UnlockResult[]
  triggerUnlock(featureId: string): void
  getNextUnlock(): UnlockThreshold | null
  calculateProgress(featureId: string): number
}
```

**API/Service methods:**
- `progression.checkUnlocks()` - Evaluates current state against thresholds
- `progression.celebrateUnlock(featureId)` - Triggers unlock animation
- `progression.getHelp(elementId)` - Returns contextual help
- `progression.trackAchievement(id, progress)` - Updates achievement progress

**Event coordination:**
```typescript
// Listen for resource changes to check unlock thresholds
eventBus.on('resources.updated', (metrics) => {
  const unlocks = progression.checkThresholds(metrics);
  unlocks.forEach(unlock => {
    eventBus.emit('feature.unlocked', unlock);
  });
});

// Coordinate with UI to show unlock notifications
eventBus.on('feature.unlocked', (feature) => {
  notifications.showUnlock(feature);
  audio.playUnlockSound();
});
```

**Error handling:**
- Validate threshold data on load with fallback defaults
- Handle missing feature definitions gracefully
- Prevent duplicate unlock notifications

**Performance considerations:**
- Cache computed threshold calculations
- Batch multiple simultaneous unlocks
- Use computed observables for progress calculations

**Testing strategy:**
- Unit tests for threshold calculation logic
- Integration tests for unlock event flow
- Visual tests for animation sequences
- Accessibility tests for notification announcements

### 3.2 Core Clicking Mechanic

**US-003: Satisfying Click Feedback**
*As a player, I want clicking to feel responsive and rewarding.*

**Acceptance Criteria:**
- [ ] "WRITE CODE" button responds in <50ms
- [ ] Click animation: scale 0.95 → 1.1 → 1.0 over 0.2s
- [ ] Number popup shows "+1 Line of Code" with fade-up animation
- [ ] Typewriter sound effect plays (pitched variations)
- [ ] Button glow effect on hover (scale 1.05)
- [ ] Multi-tap support on mobile
- [ ] Visual feedback on successful clicks vs. disabled state

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── clicking/
│   ├── ClickingService.ts         # Click handling and feedback
│   ├── ClickButton.tsx            # Main click button
│   ├── ClickEffects.tsx           # Visual effects system
│   ├── components/
│   │   ├── NumberPopup.tsx        # Floating number animations
│   │   ├── ButtonGlow.tsx         # Hover effects
│   │   └── ClickRipple.tsx        # Touch feedback
│   ├── audio/
│   │   ├── AudioService.ts        # Sound management
│   │   └── sounds/                # Audio assets
│   └── index.ts
```

**Data Model:**
```typescript
class ClickingService {
  #state$ = observable({
    clickPower: 1,
    comboCount: 0,
    comboTimer: null,
    isButtonPressed: false,
    pendingAnimations: Array<ClickAnimation>(),
    audioSettings: {
      enabled: true,
      volume: 0.7,
      pitchVariation: true
    }
  });

  handleClick(position: Point): ClickResult
  startAnimation(type: AnimationType, position: Point): void
  updateClickPower(newPower: number): void
  resetCombo(): void
}
```

**API/Service methods:**
- `clicking.executeClick(position)` - Processes click with feedback
- `clicking.setClickPower(power)` - Updates click multiplier
- `clicking.enableAudio(enabled)` - Controls sound effects
- `clicking.getComboMultiplier()` - Returns current combo bonus

**Event coordination:**
```typescript
// Click generates resources
eventBus.on('ui.buttonClicked', (clickData) => {
  const result = clicking.executeClick(clickData.position);
  eventBus.emit('resources.generated', {
    type: 'linesOfCode',
    amount: result.value,
    source: 'click'
  });
});

// Audio coordination
eventBus.on('click.executed', (clickResult) => {
  audio.playClickSound({
    pitch: clickResult.criticalHit ? 1.5 : 1.0,
    volume: Math.min(1.0, clickResult.value / 10)
  });
});
```

**Error handling:**
- Graceful degradation if audio fails to load
- Fallback animations if high-performance effects fail
- Click queue management to prevent overflow

**Performance considerations:**
- Pool animation objects to reduce GC pressure
- Limit concurrent popup animations to 10
- Use transform3d for hardware acceleration
- Debounce rapid clicks to maintain 60fps

**Testing strategy:**
- Unit tests for click calculation logic
- Performance tests for rapid clicking scenarios
- Audio integration tests across platforms
- Accessibility tests for button feedback

---

**US-004: Click Multipliers and Bonuses**
*As a player, I want my clicks to become more powerful as I progress.*

**Acceptance Criteria:**
- [ ] Base click value starts at 1 Line of Code
- [ ] Click power increases with prestige bonuses (+1% per IP)
- [ ] Special click events (critical clicks) at 5% chance for 10x value
- [ ] Visual distinction for critical clicks (larger popup, special sound)
- [ ] Click combo system: 10 clicks within 5 seconds = 2x multiplier

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── clickMultipliers/
│   ├── MultiplierService.ts       # Calculates click power
│   ├── CriticalHitSystem.tsx      # Critical click effects
│   ├── ComboTracker.tsx           # Combo system UI
│   ├── components/
│   │   ├── CriticalPopup.tsx      # Special critical animations
│   │   ├── ComboMeter.tsx         # Visual combo progress
│   │   └── PowerIndicator.tsx     # Current click power display
│   └── index.ts
```

**Data Model:**
```typescript
class MultiplierService {
  #state$ = observable({
    basePower: 1,
    prestigeBonus: 0,
    temporaryMultipliers: new Map<string, Multiplier>(),
    criticalChance: 0.05,
    criticalMultiplier: 10,
    combo: {
      count: 0,
      timeRemaining: 0,
      threshold: 10,
      multiplier: 2.0
    }
  });

  calculateClickPower(): number
  rollCriticalHit(): boolean
  updateCombo(): ComboState
  applyPrestigeBonus(ipCount: number): void
}
```

**API/Service methods:**
- `multipliers.getCurrentPower()` - Returns total click power
- `multipliers.processCritical()` - Handles critical hit calculation
- `multipliers.advanceCombo()` - Updates combo state
- `multipliers.addTemporaryBonus(id, multiplier, duration)` - Temporary bonuses

**Event coordination:**
```typescript
// Combo system coordination
eventBus.on('click.executed', () => {
  const comboResult = multipliers.updateCombo();
  if (comboResult.achieved) {
    eventBus.emit('combo.achieved', { 
      multiplier: comboResult.multiplier,
      duration: 5000 
    });
  }
});

// Prestige bonus updates
eventBus.on('prestige.completed', (prestigeData) => {
  multipliers.applyPrestigeBonus(prestigeData.intellectualProperty);
});
```

**Error handling:**
- Validate multiplier calculations to prevent infinite values
- Handle timer cleanup for combo system
- Fallback to base values if calculations fail

**Performance considerations:**
- Cache complex multiplier calculations
- Use computed observables for derived values
- Optimize critical hit random generation

**Testing strategy:**
- Unit tests for multiplier calculation accuracy
- Integration tests for combo timing
- Statistical tests for critical hit distribution
- Performance tests for rapid calculation scenarios

### 3.3 Department Management

**US-005: Development Department Operations**
*As a player, I want to hire developers to automate code generation.*

**Acceptance Criteria:**
- [ ] Four developer types with escalating costs and production rates
- [ ] Junior Dev: 0.1 lines/sec, $10 base cost
- [ ] Mid Dev: 0.5 lines/sec, $100 base cost
- [ ] Senior Dev: 2.5 lines/sec, $1,000 base cost
- [ ] Tech Lead: 10 lines/sec + 10% department boost, $10,000 base cost
- [ ] Cost scaling: `baseCost × 1.15^owned`
- [ ] Production rate displayed in real-time
- [ ] Visual representation of team size in department view

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── departments/
│   ├── development/
│   │   ├── DevelopmentService.ts      # Department logic
│   │   ├── DeveloperTypes.ts          # Employee definitions
│   │   ├── ProductionCalculator.ts    # Rate calculations
│   │   ├── components/
│   │   │   ├── DepartmentView.tsx     # Main department UI
│   │   │   ├── EmployeeCard.tsx       # Individual employee display
│   │   │   ├── ProductionMeter.tsx    # Real-time production display
│   │   │   ├── HireButton.tsx         # Purchase interface
│   │   │   └── TeamVisualization.tsx  # Visual team representation
│   │   └── index.ts
│   └── shared/
│       ├── DepartmentBase.ts          # Common department logic
│       ├── EmployeeBase.ts            # Base employee class
│       └── CostCalculator.ts          # Shared cost scaling
```

**Data Model:**
```typescript
class DevelopmentService extends DepartmentBase {
  #state$ = observable({
    employees: new Map<string, EmployeeCount>(),
    totalProduction: 0,
    departmentBonus: 1.0,
    upgrades: new Set<string>(),
    statistics: {
      totalHired: 0,
      totalProduced: 0,
      efficiency: 1.0
    }
  });

  hireEmployee(type: EmployeeType): Result<void, Error>
  calculateProduction(): number
  getNextCost(type: EmployeeType): number
  getDepartmentBonus(): number
}

interface EmployeeType {
  id: string;
  name: string;
  baseCost: number;
  productionRate: number;
  specialBonus?: DepartmentBonus;
}
```

**API/Service methods:**
- `development.hire(employeeType)` - Attempts to hire new employee
- `development.getProduction()` - Returns current lines/sec production
- `development.getCost(employeeType)` - Calculates scaled cost
- `development.getTeamSize()` - Returns total employee count
- `development.getEfficiency()` - Returns department efficiency multiplier

**Event coordination:**
```typescript
// Resource production coordination
setInterval(() => {
  const production = development.calculateProduction();
  eventBus.emit('resources.generated', {
    type: 'linesOfCode',
    amount: production,
    source: 'development',
    deltaTime: 1000
  });
}, 1000);

// Hiring coordination
eventBus.on('ui.hireRequested', async (request) => {
  const cost = development.getCost(request.employeeType);
  const fundsResult = await eventBus.emit('funds.request', { 
    amount: cost, 
    purpose: 'hire' 
  });
  
  if (fundsResult.success) {
    development.hireEmployee(request.employeeType);
    eventBus.emit('employee.hired', request);
  }
});
```

**Error handling:**
- Validate employee types on load with fallback defaults
- Handle production calculation overflow
- Graceful degradation if cost formula fails

**Performance considerations:**
- Cache expensive production calculations
- Use computed observables for derived statistics
- Batch production updates to reduce event frequency
- Optimize cost calculation for rapid purchases

**Testing strategy:**
- Unit tests for cost scaling accuracy
- Integration tests for production calculation
- Performance tests for large employee counts
- UI tests for real-time display updates

---

**US-006: Sales Department Mechanics**
*As a player, I want to generate leads to convert features into revenue.*

**Acceptance Criteria:**
- [ ] Unlocks at $500 total revenue milestone
- [ ] Four sales roles with lead generation rates
- [ ] Sales Rep: 0.2 leads/sec, $100 base cost
- [ ] Account Manager: 1 lead/sec, $1,000 base cost
- [ ] Sales Director: 5 leads/sec, $10,000 base cost
- [ ] VP Sales: 20 leads/sec + 15% dept boost, $100,000 base cost
- [ ] Automatic revenue calculation: leads × available features
- [ ] Revenue conversion shown in real-time

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── departments/
│   ├── sales/
│   │   ├── SalesService.ts            # Sales department logic
│   │   ├── RevenueCalculator.ts       # Lead conversion logic
│   │   ├── LeadGenerator.ts           # Lead production system
│   │   ├── components/
│   │   │   ├── SalesDashboard.tsx     # Department overview
│   │   │   ├── LeadMeter.tsx          # Lead generation display
│   │   │   ├── RevenueConverter.tsx   # Conversion visualization
│   │   │   ├── SalesTeam.tsx          # Team management
│   │   │   └── ConversionPipeline.tsx # Lead → Revenue flow
│   │   └── index.ts
│   └── shared/
│       └── RevenueTypes.ts            # Shared revenue interfaces
```

**Data Model:**
```typescript
class SalesService extends DepartmentBase {
  #state$ = observable({
    salesTeam: new Map<string, EmployeeCount>(),
    leadGeneration: 0,
    conversionRate: 1.0,
    departmentBonus: 1.0,
    pipeline: {
      activeLeads: 0,
      convertedToday: 0,
      revenue: 0
    }
  });

  generateLeads(): number
  convertLeadsToRevenue(availableFeatures: FeatureInventory): number
  calculateConversionRate(): number
  getDepartmentEfficiency(): number
}

interface FeatureInventory {
  basic: number;
  advanced: number;
  premium: number;
}
```

**API/Service methods:**
- `sales.getLeadGeneration()` - Returns current leads/sec rate
- `sales.processConversion(features)` - Converts leads to revenue
- `sales.getConversionRate()` - Returns current conversion efficiency
- `sales.hire(salesRole)` - Hires new sales team member
- `sales.getUnlockStatus()` - Checks if department is available

**Event coordination:**
```typescript
// Department unlock coordination
eventBus.on('resources.updated', (metrics) => {
  if (!sales.isUnlocked() && metrics.totalRevenue >= 500) {
    eventBus.emit('department.unlocked', { 
      department: 'sales',
      milestone: 500 
    });
  }
});

// Revenue generation coordination
setInterval(() => {
  const leads = sales.generateLeads();
  eventBus.emit('leads.generated', { amount: leads });
  
  // Get available features for conversion
  const features = await eventBus.emit('features.getInventory');
  const revenue = sales.convertLeadsToRevenue(features.data);
  
  if (revenue > 0) {
    eventBus.emit('revenue.generated', { 
      amount: revenue,
      source: 'sales' 
    });
  }
}, 1000);
```

**Error handling:**
- Handle missing feature data gracefully
- Validate revenue calculations to prevent overflow
- Fallback to basic conversion if complex logic fails

**Performance considerations:**
- Cache lead generation calculations
- Batch revenue conversion operations
- Use computed observables for conversion rates
- Optimize pipeline calculations for high volumes

**Testing strategy:**
- Unit tests for lead conversion accuracy
- Integration tests for feature-revenue coordination
- Performance tests for high-volume operations
- Business logic tests for unlock thresholds

---

**US-007: Customer Experience Department**
*As a player, I want to resolve support tickets to multiply revenue.*

**Acceptance Criteria:**
- [ ] Support staff resolve tickets at specified rates
- [ ] Support Agent: 0.1 tickets/sec, $250 base cost
- [ ] CX Specialist: 0.5 tickets/sec, $2,500 base cost
- [ ] CX Manager: 2.5 tickets/sec, $25,000 base cost
- [ ] CX Director: 10 tickets/sec + retention bonus, $250,000 base cost
- [ ] Resolved tickets multiply revenue (1.1x scaling to 3x maximum)
- [ ] Happy customers generate bonus referral leads
- [ ] Ticket backlog visualization

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── departments/
│   ├── customerExperience/
│   │   ├── CustomerExperienceService.ts  # Main CX logic
│   │   ├── TicketSystem.ts               # Support ticket management
│   │   ├── SatisfactionCalculator.ts     # Customer satisfaction
│   │   ├── RetentionSystem.ts            # Customer retention logic
│   │   ├── components/
│   │   │   ├── CXDashboard.tsx           # Department overview
│   │   │   ├── TicketQueue.tsx           # Ticket backlog display
│   │   │   ├── SatisfactionMeter.tsx     # Customer happiness
│   │   │   ├── RetentionBonus.tsx        # Retention multiplier UI
│   │   │   ├── ReferralTracker.tsx       # Bonus lead tracking
│   │   │   └── SupportTeam.tsx           # Team management
│   │   └── index.ts
```

**Data Model:**
```typescript
class CustomerExperienceService extends DepartmentBase {
  #state$ = observable({
    supportTeam: new Map<string, EmployeeCount>(),
    ticketResolution: 0,
    ticketBacklog: 0,
    customerSatisfaction: 0.5,
    retentionMultiplier: 1.0,
    referralGeneration: 0,
    metrics: {
      ticketsResolved: 0,
      happyCustomers: 0,
      retentionRate: 0.5
    }
  });

  resolveTickets(deltaTime: number): number
  calculateSatisfactionMultiplier(): number
  generateReferralLeads(): number
  updateRetentionBonus(): void
}

interface TicketResolutionResult {
  resolved: number;
  satisfactionChange: number;
  referralsGenerated: number;
}
```

**API/Service methods:**
- `customerExperience.getResolutionRate()` - Returns tickets/sec rate
- `customerExperience.getSatisfactionMultiplier()` - Revenue multiplier
- `customerExperience.processTickets()` - Resolves pending tickets
- `customerExperience.getReferralBonus()` - Bonus lead generation
- `customerExperience.getRetentionRate()` - Customer retention percentage

**Event coordination:**
```typescript
// Ticket generation from sales activity
eventBus.on('revenue.generated', (revenueData) => {
  const ticketRate = revenueData.amount * 0.001; // 0.1% of revenue creates tickets
  customerExperience.addTickets(ticketRate);
});

// Revenue multiplication from satisfaction
eventBus.on('revenue.calculating', (revenueData) => {
  const multiplier = customerExperience.getSatisfactionMultiplier();
  revenueData.apply(multiplier);
});

// Referral lead generation
setInterval(() => {
  const referrals = customerExperience.generateReferralLeads();
  if (referrals > 0) {
    eventBus.emit('leads.generated', { 
      amount: referrals,
      source: 'referrals',
      bonus: true 
    });
  }
}, 1000);
```

**Error handling:**
- Handle ticket overflow with queue management
- Validate satisfaction calculations within bounds [0, 1]
- Graceful degradation if retention calculation fails

**Performance considerations:**
- Batch ticket processing operations
- Cache satisfaction multiplier calculations
- Use computed observables for metrics
- Optimize backlog calculations for large volumes

**Testing strategy:**
- Unit tests for satisfaction calculation accuracy
- Integration tests for revenue multiplication
- Performance tests for high ticket volumes
- Business logic tests for referral generation

---

**US-008: Product Department Innovation**
*As a player, I want product insights to enhance feature value.*

**Acceptance Criteria:**
- [ ] Product roles generate insights and convert to specifications
- [ ] Product Analyst: Generates insights, $500 base cost
- [ ] Product Manager: Converts insights to specs, $5,000 base cost
- [ ] Senior PM: Premium specs + roadmap bonus, $50,000 base cost
- [ ] CPO: Global multipliers, $500,000 base cost
- [ ] Insights + Features = Enhanced Features (2x value)
- [ ] Visual roadmap showing upcoming enhancements

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── departments/
│   ├── product/
│   │   ├── ProductService.ts             # Product department logic
│   │   ├── InsightGenerator.ts           # Insight production
│   │   ├── SpecificationSystem.ts       # Spec conversion logic
│   │   ├── RoadmapPlanner.ts            # Product roadmap
│   │   ├── FeatureEnhancer.ts           # Feature value multiplication
│   │   ├── components/
│   │   │   ├── ProductDashboard.tsx     # Department overview
│   │   │   ├── InsightTracker.tsx       # Insight generation display
│   │   │   ├── SpecificationQueue.tsx   # Spec processing
│   │   │   ├── RoadmapView.tsx          # Visual roadmap
│   │   │   ├── EnhancementLab.tsx       # Feature enhancement UI
│   │   │   └── ProductTeam.tsx          # Team management
│   │   └── index.ts
```

**Data Model:**
```typescript
class ProductService extends DepartmentBase {
  #state$ = observable({
    productTeam: new Map<string, EmployeeCount>(),
    insightGeneration: 0,
    specificationRate: 0,
    enhancementMultiplier: 1.0,
    roadmap: {
      upcomingFeatures: Array<PlannedFeature>(),
      inDevelopment: Array<Feature>(),
      completed: Array<Feature>()
    },
    resources: {
      insights: 0,
      specifications: 0,
      enhancedFeatures: 0
    }
  });

  generateInsights(deltaTime: number): number
  convertInsightsToSpecs(): number
  enhanceFeatures(baseFeatures: FeatureSet): EnhancedFeatureSet
  updateRoadmap(): void
}

interface EnhancedFeature {
  baseFeature: Feature;
  enhancementLevel: number;
  valueMultiplier: number;
  specifications: Specification[];
}
```

**API/Service methods:**
- `product.getInsightRate()` - Returns insights/sec generation
- `product.convertToSpecs(insightCount)` - Converts insights to specifications
- `product.enhanceFeatures(features)` - Creates enhanced features
- `product.getRoadmap()` - Returns planned feature roadmap
- `product.getEnhancementMultiplier()` - Feature value multiplier

**Event coordination:**
```typescript
// Feature enhancement coordination
eventBus.on('features.produced', (featureData) => {
  const enhanced = product.enhanceFeatures(featureData.features);
  if (enhanced.length > 0) {
    eventBus.emit('features.enhanced', { 
      enhanced,
      multiplier: 2.0 
    });
  }
});

// Roadmap planning coordination
eventBus.on('insights.threshold', (insightData) => {
  if (insightData.count >= 100) {
    product.planNewFeature();
    eventBus.emit('roadmap.updated', product.getRoadmap());
  }
});

// Specification production
setInterval(() => {
  const insights = product.getResourceCount('insights');
  if (insights > 0) {
    const specs = product.convertInsightsToSpecs();
    eventBus.emit('specifications.generated', { 
      amount: specs,
      consumed: insights 
    });
  }
}, 1000);
```

**Error handling:**
- Validate enhancement calculations to prevent overflow
- Handle missing feature data gracefully
- Fallback to base features if enhancement fails

**Performance considerations:**
- Cache enhancement calculations
- Batch feature processing operations
- Use computed observables for roadmap calculations
- Optimize specification conversion for large volumes

**Testing strategy:**
- Unit tests for enhancement multiplier accuracy
- Integration tests for feature enhancement flow
- Performance tests for large feature sets
- Business logic tests for roadmap planning

---

**US-009: Design Department Polish**
*As a player, I want design teams to improve feature quality and conversion.*

**Acceptance Criteria:**
- [ ] Design roles generate polish and experience points
- [ ] UI Designer: Polish points/sec, $1,000 base cost
- [ ] UX Designer: Experience points/sec, $10,000 base cost
- [ ] Design Lead: Team multipliers, $100,000 base cost
- [ ] Creative Director: Global polish, $1,000,000 base cost
- [ ] Polish points increase feature value
- [ ] Experience points increase sales conversion rates
- [ ] Design system unlocks at 50 designers (2x all production)

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── departments/
│   ├── design/
│   │   ├── DesignService.ts              # Design department logic
│   │   ├── PolishSystem.ts               # Polish point management
│   │   ├── ExperienceSystem.ts           # UX experience tracking
│   │   ├── DesignSystemUnlock.ts         # Design system mechanics
│   │   ├── components/
│   │   │   ├── DesignStudio.tsx          # Department overview
│   │   │   ├── PolishMeter.tsx           # Polish accumulation
│   │   │   ├── ExperienceTracker.tsx     # UX experience display
│   │   │   ├── DesignSystemStatus.tsx    # System unlock progress
│   │   │   ├── QualityIndicator.tsx      # Feature quality display
│   │   │   └── CreativeTeam.tsx          # Team management
│   │   └── index.ts
```

**Data Model:**
```typescript
class DesignService extends DepartmentBase {
  #state$ = observable({
    designTeam: new Map<string, EmployeeCount>(),
    polishGeneration: 0,
    experienceGeneration: 0,
    qualityMultiplier: 1.0,
    conversionBonus: 1.0,
    designSystem: {
      unlocked: false,
      progress: 0,
      threshold: 50,
      globalMultiplier: 2.0
    },
    resources: {
      polishPoints: 0,
      experiencePoints: 0,
      qualityLevel: 0
    }
  });

  generatePolish(deltaTime: number): number
  generateExperience(deltaTime: number): number
  calculateQualityMultiplier(): number
  calculateConversionBonus(): number
  checkDesignSystemUnlock(): boolean
}
```

**API/Service methods:**
- `design.getPolishRate()` - Returns polish points/sec
- `design.getExperienceRate()` - Returns experience points/sec
- `design.getQualityMultiplier()` - Feature quality multiplier
- `design.getConversionBonus()` - Sales conversion improvement
- `design.getDesignSystemStatus()` - Unlock progress and benefits

**Event coordination:**
```typescript
// Feature quality enhancement
eventBus.on('features.valuing', (featureData) => {
  const qualityMultiplier = design.getQualityMultiplier();
  featureData.value *= qualityMultiplier;
  featureData.addTag('polished');
});

// Sales conversion improvement
eventBus.on('sales.converting', (conversionData) => {
  const conversionBonus = design.getConversionBonus();
  conversionData.rate *= conversionBonus;
});

// Design system unlock
eventBus.on('employee.hired', (employeeData) => {
  if (employeeData.department === 'design') {
    const unlocked = design.checkDesignSystemUnlock();
    if (unlocked) {
      eventBus.emit('designSystem.unlocked', {
        globalMultiplier: 2.0,
        teamSize: design.getTotalEmployees()
      });
    }
  }
});
```

**Error handling:**
- Validate quality calculations within reasonable bounds
- Handle design system unlock state gracefully
- Fallback to base values if complex calculations fail

**Performance considerations:**
- Cache quality multiplier calculations
- Batch polish and experience generation
- Use computed observables for derived bonuses
- Optimize team size calculations

**Testing strategy:**
- Unit tests for quality multiplier accuracy
- Integration tests for conversion bonus application
- Performance tests for large design teams
- Business logic tests for design system unlock

---

**US-010: QA Department Quality Assurance**
*As a player, I want QA teams to catch bugs and reduce support burden.*

**Acceptance Criteria:**
- [ ] QA roles catch and prevent bugs
- [ ] QA Tester: Catches bugs, $750 base cost
- [ ] QA Engineer: Prevents bugs, $7,500 base cost
- [ ] QA Lead: Process improvements, $75,000 base cost
- [ ] QA Director: Zero-defect bonuses, $750,000 base cost
- [ ] Each bug caught saves 10x its cost
- [ ] Bug prevention reduces support tickets
- [ ] Quality score affects customer satisfaction

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── departments/
│   ├── qa/
│   │   ├── QAService.ts                  # QA department logic
│   │   ├── BugDetectionSystem.ts         # Bug catching mechanics
│   │   ├── BugPreventionSystem.ts        # Bug prevention logic
│   │   ├── QualityScoreCalculator.ts     # Quality metrics
│   │   ├── DefectTracking.ts             # Bug tracking system
│   │   ├── components/
│   │   │   ├── QALaboratory.tsx          # Department overview
│   │   │   ├── BugTracker.tsx            # Bug detection display
│   │   │   ├── QualityMeter.tsx          # Quality score indicator
│   │   │   ├── PreventionSystem.tsx      # Prevention metrics
│   │   │   ├── DefectAnalysis.tsx        # Bug analysis display
│   │   │   └── QATeam.tsx                # Team management
│   │   └── index.ts
```

**Data Model:**
```typescript
class QAService extends DepartmentBase {
  #state$ = observable({
    qaTeam: new Map<string, EmployeeCount>(),
    bugDetectionRate: 0,
    bugPreventionRate: 0,
    qualityScore: 0.5,
    defectMetrics: {
      bugsFound: 0,
      bugsPrevented: 0,
      costSavings: 0,
      qualityImprovement: 0
    },
    processes: {
      testingEfficiency: 1.0,
      preventionEfficiency: 1.0,
      zeroDefectBonus: false
    }
  });

  detectBugs(codeProduced: number): BugDetectionResult
  preventBugs(developmentRate: number): BugPreventionResult
  calculateQualityScore(): number
  calculateCostSavings(): number
  updateQualityImpact(): void
}

interface BugDetectionResult {
  bugsFound: number;
  costSavings: number;
  qualityImprovement: number;
}
```

**API/Service methods:**
- `qa.getBugDetectionRate()` - Returns bugs caught/sec
- `qa.getBugPreventionRate()` - Returns prevention efficiency
- `qa.getQualityScore()` - Current quality score (0-1)
- `qa.getCostSavings()` - Total cost savings from QA
- `qa.getTicketReduction()` - Support ticket prevention rate

**Event coordination:**
```typescript
// Bug detection from code production
eventBus.on('code.produced', (codeData) => {
  const detectionResult = qa.detectBugs(codeData.amount);
  if (detectionResult.bugsFound > 0) {
    eventBus.emit('bugs.detected', {
      count: detectionResult.bugsFound,
      savings: detectionResult.costSavings
    });
  }
});

// Bug prevention impact on development
eventBus.on('development.calculating', (devData) => {
  const preventionRate = qa.getBugPreventionRate();
  devData.qualityMultiplier *= (1 + preventionRate);
});

// Quality impact on customer satisfaction
eventBus.on('satisfaction.calculating', (satisfactionData) => {
  const qualityScore = qa.getQualityScore();
  satisfactionData.baseScore += (qualityScore - 0.5) * 0.2; // -0.1 to +0.1 impact
});

// Support ticket reduction
eventBus.on('tickets.generating', (ticketData) => {
  const reductionRate = qa.getTicketReduction();
  ticketData.count *= (1 - reductionRate);
});
```

**Error handling:**
- Validate quality score within bounds [0, 1]
- Handle bug calculation overflow gracefully
- Fallback to base quality if calculations fail

**Performance considerations:**
- Cache quality score calculations
- Batch bug detection operations
- Use computed observables for cost savings
- Optimize prevention calculations

**Testing strategy:**
- Unit tests for bug detection accuracy
- Integration tests for quality impact propagation
- Performance tests for high code production volumes
- Business logic tests for cost savings calculations

---

**US-011: Marketing Department Growth**
*As a player, I want marketing to multiply lead generation and create viral growth.*

**Acceptance Criteria:**
- [ ] Marketing roles generate brand power and campaign effects
- [ ] Content Writer: Brand points, $2,000 base cost
- [ ] Marketing Manager: Campaign power, $20,000 base cost
- [ ] Growth Hacker: Viral coefficients, $200,000 base cost
- [ ] CMO: Market domination, $2,000,000 base cost
- [ ] Brand points multiply lead generation
- [ ] Campaigns create temporary 10x spikes
- [ ] Viral mechanics for exponential growth phases

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── departments/
│   ├── marketing/
│   │   ├── MarketingService.ts           # Marketing department logic
│   │   ├── BrandSystem.ts                # Brand power management
│   │   ├── CampaignSystem.ts             # Campaign mechanics
│   │   ├── ViralGrowthEngine.ts          # Viral growth calculations
│   │   ├── MarketDominationTracker.ts    # Market share tracking
│   │   ├── components/
│   │   │   ├── MarketingHQ.tsx           # Department overview
│   │   │   ├── BrandMeter.tsx            # Brand power display
│   │   │   ├── CampaignLauncher.tsx      # Campaign management
│   │   │   ├── ViralTracker.tsx          # Viral growth metrics
│   │   │   ├── MarketShare.tsx           # Market domination UI
│   │   │   └── MarketingTeam.tsx         # Team management
│   │   └── index.ts
```

**Data Model:**
```typescript
class MarketingService extends DepartmentBase {
  #state$ = observable({
    marketingTeam: new Map<string, EmployeeCount>(),
    brandPower: 0,
    campaignPower: 0,
    viralCoefficient: 1.0,
    marketShare: 0,
    activeCampaigns: Array<ActiveCampaign>(),
    viralMetrics: {
      currentMultiplier: 1.0,
      spreadRate: 0,
      saturationLevel: 0
    },
    brandMetrics: {
      awareness: 0,
      loyalty: 0,
      advocacy: 0
    }
  });

  generateBrandPower(deltaTime: number): number
  launchCampaign(type: CampaignType): CampaignResult
  calculateViralGrowth(): ViralGrowthResult
  updateMarketDomination(): MarketDominationResult
}

interface ActiveCampaign {
  id: string;
  type: CampaignType;
  multiplier: number;
  duration: number;
  timeRemaining: number;
}
```

**API/Service methods:**
- `marketing.getBrandMultiplier()` - Returns brand-based lead multiplier
- `marketing.launchCampaign(type)` - Initiates marketing campaign
- `marketing.getViralCoefficient()` - Current viral growth rate
- `marketing.getMarketShare()` - Current market domination percentage
- `marketing.getCampaignStatus()` - Active campaign information

**Event coordination:**
```typescript
// Brand power multiplication of leads
eventBus.on('leads.generating', (leadData) => {
  const brandMultiplier = marketing.getBrandMultiplier();
  leadData.amount *= brandMultiplier;
  leadData.addSource('brand');
});

// Campaign spike effects
eventBus.on('campaign.launched', (campaignData) => {
  const spikeMultiplier = 10; // 10x spike
  eventBus.emit('leads.temporaryBoost', {
    multiplier: spikeMultiplier,
    duration: campaignData.duration,
    source: 'campaign'
  });
});

// Viral growth mechanics
setInterval(() => {
  const viralResult = marketing.calculateViralGrowth();
  if (viralResult.newUsers > 0) {
    eventBus.emit('users.viral', {
      count: viralResult.newUsers,
      coefficient: viralResult.coefficient
    });
  }
}, 1000);

// Market domination effects
eventBus.on('marketShare.threshold', (shareData) => {
  if (shareData.percentage >= 0.5) { // 50% market share
    eventBus.emit('market.dominated', {
      globalMultiplier: 2.0,
      permanentBonus: true
    });
  }
});
```

**Error handling:**
- Validate viral coefficient to prevent infinite growth
- Handle campaign overlap scenarios gracefully
- Fallback to base multipliers if calculations fail

**Performance considerations:**
- Cache brand power calculations
- Batch campaign effect processing
- Use computed observables for viral metrics
- Optimize market share calculations

**Testing strategy:**
- Unit tests for brand multiplier accuracy
- Integration tests for campaign coordination
- Performance tests for viral growth calculations
- Business logic tests for market domination thresholds

### 3.4 Upgrade System

**US-012: Department-Specific Upgrades**
*As a player, I want to purchase upgrades that meaningfully improve department performance.*

**Acceptance Criteria:**
- [ ] Each department has 3 unique upgrades
- [ ] Development upgrades: Better IDEs (+25/50/100% speed), Pair Programming (2x at 25 devs), Code Reviews (-50% bugs at 50 devs)
- [ ] Sales upgrades: CRM System (+30% leads), Sales Training (2x at 25 reps), Partnership Deals (+50% revenue)
- [ ] Customer Experience upgrades: Help Desk Software (+40% resolution), Knowledge Base (auto-resolve 25%), Customer Success (+50% retention)
- [ ] Upgrades have clear prerequisites and cost scaling
- [ ] Visual indicators show upgrade effects
- [ ] Upgrade purchase confirmation for expensive items

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── upgrades/
│   ├── UpgradeService.ts                 # Upgrade system logic
│   ├── UpgradeDefinitions.ts             # All upgrade configurations
│   ├── PrerequisiteChecker.ts            # Upgrade prerequisites
│   ├── EffectCalculator.ts               # Upgrade effect calculations
│   ├── components/
│   │   ├── UpgradeStore.tsx              # Upgrade purchasing UI
│   │   ├── UpgradeTree.tsx               # Upgrade dependency tree
│   │   ├── UpgradeCard.tsx               # Individual upgrade display
│   │   ├── EffectIndicator.tsx           # Visual effect display
│   │   ├── PrerequisiteDisplay.tsx       # Prerequisite requirements
│   │   └── ConfirmationDialog.tsx        # Purchase confirmation
│   ├── types/
│   │   ├── UpgradeTypes.ts               # Upgrade interfaces
│   │   └── EffectTypes.ts                # Effect definitions
│   └── index.ts
```

**Data Model:**
```typescript
class UpgradeService {
  #state$ = observable({
    purchasedUpgrades: new Set<string>(),
    availableUpgrades: new Map<string, Upgrade>(),
    departmentEffects: new Map<string, UpgradeEffects>(),
    upgradeCategories: new Map<string, UpgradeCategory>()
  });

  purchaseUpgrade(upgradeId: string): Result<void, Error>
  checkPrerequisites(upgradeId: string): PrerequisiteResult
  calculateUpgradeEffects(department: string): UpgradeEffects
  getAvailableUpgrades(department: string): Upgrade[]
}

interface Upgrade {
  id: string;
  name: string;
  description: string;
  cost: number;
  department: string;
  prerequisites: Prerequisite[];
  effects: UpgradeEffect[];
  tier: number;
}

interface UpgradeEffect {
  type: 'multiplier' | 'additive' | 'threshold' | 'unlock';
  target: string;
  value: number;
  condition?: UpgradeCondition;
}
```

**API/Service methods:**
- `upgrades.purchase(upgradeId)` - Attempts to buy upgrade
- `upgrades.getEffects(department)` - Returns active upgrade effects
- `upgrades.checkAvailability(upgradeId)` - Validates prerequisites
- `upgrades.calculateCost(upgradeId)` - Returns scaled upgrade cost
- `upgrades.getUpgradeTree(department)` - Returns upgrade progression tree

**Event coordination:**
```typescript
// Department effect application
eventBus.on('department.calculating', (deptData) => {
  const effects = upgrades.getEffects(deptData.department);
  deptData.applyEffects(effects);
});

// Prerequisite checking
eventBus.on('ui.upgradeClicked', async (upgradeData) => {
  const prereqResult = upgrades.checkPrerequisites(upgradeData.id);
  if (!prereqResult.satisfied) {
    eventBus.emit('ui.showPrerequisites', {
      upgrade: upgradeData.id,
      missing: prereqResult.missing
    });
    return;
  }
  
  const cost = upgrades.calculateCost(upgradeData.id);
  if (cost > 10000) { // Expensive upgrade threshold
    eventBus.emit('ui.confirmPurchase', {
      upgrade: upgradeData.id,
      cost: cost
    });
  } else {
    const result = upgrades.purchase(upgradeData.id);
    eventBus.emit('upgrade.purchased', result);
  }
});

// Effect notification
eventBus.on('upgrade.purchased', (purchaseResult) => {
  if (purchaseResult.success) {
    const effects = purchaseResult.upgrade.effects;
    eventBus.emit('effects.applied', {
      department: purchaseResult.upgrade.department,
      effects: effects
    });
  }
});
```

**Error handling:**
- Validate upgrade definitions on load
- Handle missing prerequisite data gracefully
- Prevent duplicate upgrade purchases
- Rollback on failed purchase transactions

**Performance considerations:**
- Cache upgrade effect calculations
- Lazy load upgrade trees
- Use computed observables for availability checks
- Optimize prerequisite validation

**Testing strategy:**
- Unit tests for upgrade effect calculations
- Integration tests for prerequisite validation
- UI tests for purchase confirmation flow
- Business logic tests for effect application

---

**US-013: Manager Automation System**
*As a player, I want managers to automatically purchase department units.*

**Acceptance Criteria:**
- [ ] Manager system unlocks at $50K total revenue
- [ ] Each department can hire a manager independently
- [ ] Manager costs scale: $1K, $10K, $100K, $1M, $10M, $100M, $1B
- [ ] Managers auto-buy cheapest available unit when affordable
- [ ] Manager efficiency settings: Conservative, Balanced, Aggressive
- [ ] Manual override to pause/resume manager purchasing
- [ ] Visual indication when managers are active

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── managers/
│   ├── ManagerService.ts                 # Manager system logic
│   ├── AutoPurchaseEngine.ts             # Automated buying logic
│   ├── ManagerAI.ts                      # Decision making algorithms
│   ├── EfficiencyCalculator.ts           # Manager efficiency modes
│   ├── components/
│   │   ├── ManagerHub.tsx                # Manager overview
│   │   ├── ManagerCard.tsx               # Individual manager display
│   │   ├── AutoBuySettings.tsx           # Efficiency configuration
│   │   ├── PurchaseQueue.tsx             # Upcoming purchases
│   │   ├── ManagerStatus.tsx             # Activity indicators
│   │   └── EfficiencySlider.tsx          # Mode selection
│   ├── types/
│   │   ├── ManagerTypes.ts               # Manager interfaces
│   │   └── AutoBuyTypes.ts               # Auto-purchase definitions
│   └── index.ts
```

**Data Model:**
```typescript
class ManagerService {
  #state$ = observable({
    managers: new Map<string, Manager>(),
    unlocked: false,
    globalSettings: {
      pauseAll: false,
      defaultEfficiency: 'balanced'
    },
    autoBuyQueue: Array<AutoBuyDecision>(),
    purchaseHistory: Array<ManagerPurchase>()
  });

  hireManager(department: string): Result<void, Error>
  setEfficiencyMode(department: string, mode: EfficiencyMode): void
  pauseManager(department: string): void
  resumeManager(department: string): void
  processAutoBuying(): void
}

interface Manager {
  department: string;
  tier: number;
  cost: number;
  efficiencyMode: 'conservative' | 'balanced' | 'aggressive';
  active: boolean;
  purchaseHistory: Array<AutoPurchase>;
  settings: {
    minCashReserve: number;
    maxPurchasePercent: number;
    priorityOrder: string[];
  }
}

interface AutoBuyDecision {
  department: string;
  employeeType: string;
  cost: number;
  priority: number;
  efficiency: EfficiencyMode;
}
```

**API/Service methods:**
- `managers.hire(department)` - Hires manager for department
- `managers.setMode(department, mode)` - Changes efficiency settings
- `managers.pause(department)` - Stops auto-purchasing
- `managers.getStatus(department)` - Returns manager activity status
- `managers.getNextPurchase(department)` - Returns planned purchase

**Event coordination:**
```typescript
// Manager unlock coordination
eventBus.on('revenue.milestone', (milestone) => {
  if (milestone.total >= 50000 && !managers.isUnlocked()) {
    managers.unlock();
    eventBus.emit('managers.unlocked', {
      departments: ['development', 'sales', 'customerExperience']
    });
  }
});

// Auto-purchase processing
setInterval(() => {
  managers.processAutoBuying();
}, 5000); // Check every 5 seconds

eventBus.on('manager.deciding', async (decision) => {
  const availableFunds = await eventBus.emit('funds.getAvailable');
  const recommendation = managers.calculateBestPurchase(
    decision.department,
    availableFunds.data,
    decision.efficiencyMode
  );
  
  if (recommendation.viable) {
    eventBus.emit('purchase.manager', {
      department: recommendation.department,
      employee: recommendation.employeeType,
      cost: recommendation.cost
    });
  }
});

// Purchase execution
eventBus.on('purchase.manager', async (purchase) => {
  const fundsResult = await eventBus.emit('funds.request', {
    amount: purchase.cost,
    purpose: 'manager_purchase'
  });
  
  if (fundsResult.success) {
    const dept = departments.get(purchase.department);
    dept.hireEmployee(purchase.employee);
    managers.recordPurchase(purchase);
  }
});
```

**Error handling:**
- Validate manager settings on load
- Handle insufficient funds gracefully
- Prevent infinite purchase loops
- Graceful degradation if auto-buy fails

**Performance considerations:**
- Batch auto-purchase decisions
- Cache efficiency calculations
- Use computed observables for purchase recommendations
- Optimize decision-making algorithms

**Testing strategy:**
- Unit tests for auto-purchase logic
- Integration tests for manager coordination
- Performance tests for rapid decision making
- Business logic tests for efficiency modes

### 3.5 Prestige System

**US-014: Investor Round Reset Mechanics**
*As a player, I want to reset progress for permanent bonuses that make future runs faster.*

**Acceptance Criteria:**
- [ ] Prestige unlocks at $10M valuation
- [ ] Reset formula: 1 Intellectual Property (IP) per $1M valuation
- [ ] Confirmation dialog showing IP gain and bonuses lost
- [ ] IP bonuses: Starting Capital (+10% per IP), Global Speed (+1% per IP)
- [ ] Advanced bonuses: Department Synergy (+2% per 10 IP)
- [ ] Super Units unlock at 100, 1K, 10K IP milestones
- [ ] Prestige animation with investor meeting theme
- [ ] IP total prominently displayed in UI

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── prestige/
│   ├── PrestigeService.ts                # Prestige system logic
│   ├── IPCalculator.ts                   # IP calculation and bonuses
│   ├── ResetManager.ts                   # Game state reset logic
│   ├── SuperUnitUnlocker.ts              # Special prestige unlocks
│   ├── components/
│   │   ├── PrestigeHub.tsx               # Main prestige interface
│   │   ├── IPDisplay.tsx                 # Intellectual Property display
│   │   ├── PrestigeCalculator.tsx        # Reset preview
│   │   ├── ConfirmationDialog.tsx        # Reset confirmation
│   │   ├── InvestorMeeting.tsx           # Prestige animation
│   │   ├── BonusBreakdown.tsx            # Bonus calculation display
│   │   └── SuperUnitGallery.tsx          # Special unlock showcase
│   ├── animations/
│   │   ├── PrestigeSequence.tsx          # Investor meeting animation
│   │   └── IPCountAnimation.tsx          # IP gain animation
│   └── index.ts
```

**Data Model:**
```typescript
class PrestigeService {
  #state$ = observable({
    totalIP: 0,
    lifetimeIP: 0,
    currentValuation: 0,
    unlocked: false,
    superUnits: new Set<string>(),
    bonuses: {
      startingCapital: 0,
      globalSpeed: 0,
      departmentSynergy: 0
    },
    prestigeHistory: Array<PrestigeRun>(),
    milestones: new Map<number, boolean>()
  });

  calculateIPGain(valuation: number): number
  calculateBonuses(ipCount: number): PrestigeBonuses
  executePrestige(): Promise<PrestigeResult>
  checkSuperUnitUnlocks(ipCount: number): string[]
  applyPrestigeBonuses(): void
}

interface PrestigeRun {
  id: string;
  timestamp: Date;
  valuationAchieved: number;
  ipGained: number;
  timeToPrestige: number;
  milestonesReached: string[];
}

interface PrestigeBonuses {
  startingCapital: number;    // +10% per IP
  globalSpeed: number;        // +1% per IP
  departmentSynergy: number;  // +2% per 10 IP
  superUnitAccess: string[];  // Special unlocks
}
```

**API/Service methods:**
- `prestige.calculateGain()` - Returns IP that would be gained
- `prestige.previewBonuses(ipCount)` - Shows bonus preview
- `prestige.executeReset()` - Performs prestige reset
- `prestige.applyBonuses()` - Applies IP bonuses to game
- `prestige.getSuperUnits()` - Returns available super units

**Event coordination:**
```typescript
// Prestige unlock coordination
eventBus.on('valuation.updated', (valuation) => {
  if (valuation.total >= 10000000 && !prestige.isUnlocked()) {
    prestige.unlock();
    eventBus.emit('prestige.unlocked', {
      valuation: valuation.total,
      ipGain: prestige.calculateIPGain(valuation.total)
    });
  }
});

// Prestige execution coordination
eventBus.on('prestige.confirmed', async () => {
  const currentValuation = await eventBus.emit('game.getValuation');
  const ipGain = prestige.calculateIPGain(currentValuation.data);
  
  // Show prestige animation
  eventBus.emit('animation.prestige', { ipGain });
  
  // Execute reset after animation
  setTimeout(async () => {
    const result = await prestige.executePrestige();
    eventBus.emit('game.reset', {
      bonuses: result.bonuses,
      superUnits: result.superUnits
    });
  }, 3000);
});

// Bonus application coordination
eventBus.on('game.started', () => {
  const bonuses = prestige.calculateBonuses(prestige.getTotalIP());
  prestige.applyPrestigeBonuses();
  
  eventBus.emit('bonuses.applied', {
    startingCapital: bonuses.startingCapital,
    globalSpeed: bonuses.globalSpeed,
    departmentSynergy: bonuses.departmentSynergy
  });
});
```

**Error handling:**
- Validate IP calculations to prevent overflow
- Handle reset failures with rollback mechanism
- Graceful degradation if animation fails
- Backup game state before prestige

**Performance considerations:**
- Cache bonus calculations
- Lazy load super unit data
- Optimize prestige animation performance
- Batch reset operations

**Testing strategy:**
- Unit tests for IP calculation accuracy
- Integration tests for reset coordination
- Performance tests for prestige animation
- Data integrity tests for reset process

---

**US-015: Post-Prestige Progression**
*As a player, I want each prestige run to feel meaningfully different and faster.*

**Acceptance Criteria:**
- [ ] Starting capital bonus applied immediately on reset
- [ ] Speed bonuses affect all production rates
- [ ] New prestige-only upgrades available
- [ ] Super Units provide exponential power increases
- [ ] Prestige milestones tracked and displayed
- [ ] Achievement system for prestige-related goals
- [ ] Visual progression indicators for IP accumulation

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── postPrestige/
│   ├── PostPrestigeService.ts            # Post-prestige progression
│   ├── SuperUnitManager.ts               # Super unit mechanics
│   ├── PrestigeUpgrades.ts               # Prestige-only upgrades
│   ├── MilestoneTracker.ts               # Prestige milestone system
│   ├── components/
│   │   ├── PrestigeProgression.tsx       # Post-prestige overview
│   │   ├── SuperUnitPanel.tsx            # Super unit management
│   │   ├── PrestigeUpgradeTree.tsx       # Prestige upgrade tree
│   │   ├── MilestoneDisplay.tsx          # Milestone progress
│   │   ├── IPAccumulator.tsx             # IP progression display
│   │   └── AchievementTracker.tsx        # Prestige achievements
│   ├── superUnits/
│   │   ├── SuperUnitDefinitions.ts       # Super unit configurations
│   │   └── SuperUnitEffects.ts           # Super unit effects
│   └── index.ts
```

**Data Model:**
```typescript
class PostPrestigeService {
  #state$ = observable({
    currentRun: {
      startTime: Date.now(),
      startingBonuses: {},
      milestonesReached: new Set<string>(),
      prestigeUpgrades: new Set<string>()
    },
    superUnits: new Map<string, SuperUnit>(),
    milestones: new Map<string, Milestone>(),
    achievements: new Map<string, Achievement>(),
    progression: {
      ipThisRun: 0,
      speedMultiplier: 1.0,
      powerLevel: 1
    }
  });

  initializePrestigeRun(bonuses: PrestigeBonuses): void
  updateSpeedBonuses(): number
  checkMilestones(): Milestone[]
  unlockSuperUnit(unitId: string): void
  calculateProgressionPower(): number
}

interface SuperUnit {
  id: string;
  name: string;
  description: string;
  ipRequirement: number;
  effects: SuperUnitEffect[];
  unlocked: boolean;
  owned: number;
}

interface SuperUnitEffect {
  type: 'exponential' | 'multiplicative' | 'additive';
  target: string;
  baseValue: number;
  scaling: number;
}
```

**API/Service methods:**
- `postPrestige.initializeRun(bonuses)` - Sets up new prestige run
- `postPrestige.getSpeedMultiplier()` - Returns current speed bonus
- `postPrestige.purchaseSuperUnit(unitId)` - Buys super unit
- `postPrestige.checkAchievements()` - Evaluates achievement progress
- `postPrestige.getMilestoneProgress()` - Returns milestone status

**Event coordination:**
```typescript
// Speed bonus application
eventBus.on('production.calculating', (prodData) => {
  const speedMultiplier = postPrestige.getSpeedMultiplier();
  prodData.rate *= speedMultiplier;
  prodData.addBonus('prestige_speed');
});

// Milestone checking
eventBus.on('game.milestone', (milestone) => {
  const achievements = postPrestige.checkMilestones();
  achievements.forEach(achievement => {
    eventBus.emit('achievement.unlocked', achievement);
  });
});

// Super unit effects
eventBus.on('superUnit.purchased', (unit) => {
  const effects = unit.effects;
  effects.forEach(effect => {
    eventBus.emit('effect.permanent', {
      type: effect.type,
      target: effect.target,
      value: effect.baseValue
    });
  });
});

// Achievement system
eventBus.on('prestige.milestone', (milestoneData) => {
  const achievementProgress = postPrestige.updateAchievements(milestoneData);
  if (achievementProgress.newAchievements.length > 0) {
    eventBus.emit('achievements.earned', achievementProgress.newAchievements);
  }
});
```

**Error handling:**
- Validate super unit unlock conditions
- Handle achievement data corruption gracefully
- Fallback to default bonuses if calculation fails
- Prevent duplicate milestone triggers

**Performance considerations:**
- Cache speed multiplier calculations
- Lazy load achievement definitions
- Optimize milestone checking frequency
- Use computed observables for progression calculations

**Testing strategy:**
- Unit tests for speed bonus calculations
- Integration tests for super unit coordination
- Achievement system accuracy tests
- Performance tests for milestone checking

### 3.6 UI/UX Interactions

**US-016: Responsive Mobile Interface**
*As a mobile player, I want an interface optimized for touch interaction.*

**Acceptance Criteria:**
- [ ] Primary buttons minimum 44px touch target
- [ ] Swipe navigation between departments
- [ ] Pinch-to-zoom for detailed views
- [ ] Haptic feedback for important actions
- [ ] Landscape and portrait orientation support
- [ ] One-handed operation mode
- [ ] Accessibility support (screen readers, high contrast)

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── ui/
│   ├── TouchInterface.ts                 # Touch interaction handling
│   ├── NavigationSystem.ts               # Swipe navigation
│   ├── AccessibilityService.ts           # A11y support
│   ├── HapticFeedback.ts                 # Haptic feedback system
│   ├── components/
│   │   ├── TouchOptimizedButton.tsx      # 44px+ touch targets
│   │   ├── SwipeNavigator.tsx            # Department navigation
│   │   ├── ZoomableView.tsx              # Pinch-to-zoom container
│   │   ├── OneHandedMode.tsx             # One-handed interface
│   │   ├── OrientationHandler.tsx        # Orientation management
│   │   └── AccessibilityWrapper.tsx      # A11y enhancements
│   ├── gestures/
│   │   ├── SwipeGestureHandler.ts        # Swipe gesture recognition
│   │   ├── PinchGestureHandler.ts        # Zoom gesture handling
│   │   └── TapGestureHandler.ts          # Tap optimization
│   └── index.ts
```

**Data Model:**
```typescript
class TouchInterface {
  #state$ = observable({
    touchTargetSize: 44, // Minimum 44px
    gesturesEnabled: true,
    hapticEnabled: true,
    oneHandedMode: false,
    currentOrientation: 'portrait',
    accessibility: {
      screenReaderEnabled: false,
      highContrastMode: false,
      reduceMotion: false
    },
    navigation: {
      currentDepartment: 'development',
      swipeThreshold: 50,
      animationDuration: 300
    }
  });

  handleSwipeNavigation(direction: 'left' | 'right'): void
  enableOneHandedMode(): void
  adjustForOrientation(orientation: OrientationType): void
  triggerHaptic(type: HapticType): void
}

interface AccessibilitySettings {
  announcements: boolean;
  gestureAlternatives: boolean;
  highContrast: boolean;
  largeText: boolean;
  reduceMotion: boolean;
}
```

**API/Service methods:**
- `touchInterface.setTouchTargetSize(size)` - Adjusts minimum touch targets
- `touchInterface.enableHaptic(enabled)` - Controls haptic feedback
- `touchInterface.setAccessibility(settings)` - Updates a11y settings
- `touchInterface.handleGesture(gesture)` - Processes touch gestures
- `touchInterface.adaptToOrientation()` - Adjusts layout for orientation

**Event coordination:**
```typescript
// Gesture navigation coordination
eventBus.on('gesture.swipe', (gestureData) => {
  if (gestureData.direction === 'left') {
    touchInterface.navigateToNext();
  } else if (gestureData.direction === 'right') {
    touchInterface.navigateToPrevious();
  }
  
  eventBus.emit('navigation.changed', {
    department: touchInterface.getCurrentDepartment(),
    method: 'swipe'
  });
});

// Haptic feedback coordination
eventBus.on('ui.action', (actionData) => {
  if (touchInterface.isHapticEnabled()) {
    let hapticType = 'light';
    if (actionData.importance === 'high') hapticType = 'heavy';
    if (actionData.type === 'purchase') hapticType = 'success';
    
    touchInterface.triggerHaptic(hapticType);
  }
});

// Accessibility coordination
eventBus.on('accessibility.announce', (announcement) => {
  if (touchInterface.isScreenReaderEnabled()) {
    accessibilityService.announce(announcement.text);
  }
});

// Orientation change handling
eventBus.on('device.orientationChanged', (orientation) => {
  touchInterface.adaptToOrientation(orientation);
  eventBus.emit('ui.reflow', { orientation });
});
```

**Error handling:**
- Graceful degradation if haptic API unavailable
- Fallback navigation if gestures fail
- Default accessibility settings if detection fails
- Handle orientation change edge cases

**Performance considerations:**
- Debounce gesture recognition
- Use CSS transforms for smooth animations
- Optimize touch target calculations
- Cache accessibility settings

**Testing strategy:**
- Touch target size validation tests
- Gesture recognition accuracy tests
- Accessibility compliance tests
- Cross-device orientation tests

---

**US-017: Information Display and Feedback**
*As a player, I want clear information about my progress and next goals.*

**Acceptance Criteria:**
- [ ] Real-time counters for all resources
- [ ] Next unlock clearly displayed with progress bar
- [ ] Tooltips for all interactive elements
- [ ] Achievement notifications with appropriate fanfare
- [ ] Statistics screen showing lifetime totals
- [ ] Progress comparison (current vs. all-time best)
- [ ] Clear visual hierarchy for information priority

**Technical Implementation:**

**Components & Architecture:**
```
features/
├── ui/
│   ├── informationDisplay/
│   │   ├── InformationService.ts         # Information management
│   │   ├── CounterSystem.ts              # Real-time counters
│   │   ├── ProgressTracker.ts            # Progress calculations
│   │   ├── TooltipSystem.ts              # Tooltip management
│   │   ├── NotificationSystem.ts         # Achievement notifications
│   │   ├── components/
│   │   │   ├── ResourceCounters.tsx      # Live resource display
│   │   │   ├── ProgressBars.tsx          # Progress visualization
│   │   │   ├── TooltipProvider.tsx       # Tooltip system
│   │   │   ├── AchievementNotification.tsx # Achievement display
│   │   │   ├── StatisticsPanel.tsx       # Lifetime statistics
│   │   │   ├── ComparisonView.tsx        # Progress comparison
│   │   │   └── VisualHierarchy.tsx       # Information prioritization
│   │   └── index.ts
```

**Data Model:**
```typescript
class InformationService {
  #state$ = observable({
    counters: new Map<string, Counter>(),
    progressBars: new Map<string, ProgressBar>(),
    tooltips: new Map<string, Tooltip>(),
    notifications: Array<Notification>(),
    statistics: {
      lifetime: new Map<string, number>(),
      current: new Map<string, number>(),
      records: new Map<string, number>()
    },
    display: {
      priorityLevels: new Map<string, number>(),
      updateFrequency: 100, // 10 FPS for counters
      animationDuration: 300
    }
  });

  updateCounter(counterId: string, value: number): void
  showTooltip(elementId: string, content: TooltipContent): void
  displayNotification(notification: Notification): void
  calculateProgress(goalId: string): ProgressData
  updateStatistics(category: string, value: number): void
}

interface Counter {
  id: string;
  currentValue: number;
  displayValue: string;
  formatType: 'currency' | 'number' | 'percentage' | 'time';
  animationSpeed: number;
}

interface ProgressBar {
  id: string;
  current: number;
  target: number;
  percentage: number;
  description: string;
  timeEstimate?: number;
}
```

**API/Service methods:**
- `info.updateCounter(id, value)` - Updates real-time counter
- `info.showProgress(goal, current, target)` - Displays progress bar
- `info.showTooltip(element, content)` - Shows contextual tooltip
- `info.notify(achievement)` - Displays achievement notification
- `info.getStatistics(category)` - Returns lifetime statistics

**Event coordination:**
```typescript
// Real-time counter updates
eventBus.on('resources.changed', (resourceData) => {
  Object.entries(resourceData).forEach(([resource, value]) => {
    info.updateCounter(resource, value);
  });
});

// Progress tracking coordination
eventBus.on('goal.updated', (goalData) => {
  const progress = info.calculateProgress(goalData.id);
  eventBus.emit('ui.progressUpdate', {
    goal: goalData.id,
    progress: progress
  });
});

// Tooltip system coordination
eventBus.on('ui.elementHover', (elementData) => {
  const tooltipContent = info.getTooltipContent(elementData.id);
  if (tooltipContent) {
    info.showTooltip(elementData.id, tooltipContent);
  }
});

// Achievement notification coordination
eventBus.on('achievement.earned', (achievement) => {
  info.displayNotification({
    type: 'achievement',
    title: achievement.name,
    description: achievement.description,
    duration: 5000,
    fanfare: achievement.tier === 'legendary'
  });
});

// Statistics updates
eventBus.on('game.action', (actionData) => {
  info.updateStatistics(actionData.category, actionData.value);
  
  // Update records if new best
  const currentRecord = info.getRecord(actionData.category);
  if (actionData.value > currentRecord) {
    info.setRecord(actionData.category, actionData.value);
    eventBus.emit('record.broken', {
      category: actionData.category,
      newRecord: actionData.value,
      previousRecord: currentRecord
    });
  }
});
```

**Error handling:**
- Graceful degradation if counter animation fails
- Fallback to static display if real-time updates fail
- Handle missing tooltip content gracefully
- Validate progress calculations to prevent division by zero

**Performance considerations:**
- Throttle counter updates to 10 FPS maximum
- Use CSS animations for smooth counter transitions
- Lazy load tooltip content
- Batch notification displays

**Testing strategy:**
- Unit tests for counter accuracy and formatting
- Integration tests for progress calculation
- UI tests for tooltip positioning and visibility
- Performance tests for high-frequency updates

## 4. Technical Requirements

### 4.1 Platform and Framework
- **Primary Platform**: Mobile (Android for MVP)
- **Framework**: React Native with Expo SDK 53
- **Target Devices**: Android 8.0+ (API level 26+)
- **Screen Support**: 5" to 12" displays
- **Performance Target**: 30 FPS minimum on low-end devices

### 4.2 Performance Requirements
- **Response Time**: All button interactions <50ms
- **Save Frequency**: Auto-save every 30 seconds
- **Offline Calculation**: Maximum 24 hours at 10% efficiency
- **Memory Usage**: <100MB RAM on target devices
- **Battery Impact**: Optimized for extended play sessions

### 4.3 Audio System
- **Sound Effects**: 5 core sound types (click, sale, notification, upgrade, prestige)
- **Dynamic Audio**: Pitch variation based on action magnitude
- **Audio Limiting**: Prevent same sound within 0.5s
- **Volume Control**: User-adjustable master volume
- **Audio Priority**: Milestone sounds override standard effects

### 4.4 Save System
- **Storage**: Local storage only (no backend required)
- **Save Triggers**: 30-second intervals, prestige events, app background
- **Data Integrity**: Checksums to prevent save corruption
- **Export/Import**: Save data export for device migration
- **Recovery**: Automatic backup of last 3 save states

### 4.5 Offline Progression
- **Maximum Duration**: 24 hours of offline time calculated
- **Efficiency Rate**: 10% of online production rate
- **Welcome Back**: Summary screen showing offline gains
- **Resource Caps**: Prevent overflow issues during long offline periods

## 5. Success Metrics

### 5.1 User Acquisition
- **Daily Active Users (DAU)**: 1,000 in month 1, 10,000 in month 6
- **Install-to-First-Session**: 90%+ conversion rate
- **Organic Growth Rate**: 15%+ month-over-month growth
- **App Store Rating**: Maintain 4.0+ stars

### 5.2 Engagement Metrics
- **Session Duration**: Average 15+ minutes
- **Sessions per User per Day**: 3+ sessions
- **7-Day Retention**: 30%+ retention rate
- **30-Day Retention**: 15%+ retention rate
- **Feature Adoption**: 70%+ reach Sales unlock, 40%+ reach prestige

### 5.3 Monetization Targets
- **In-App Purchase Rate**: 5%+ of players make purchases
- **Average Revenue Per User (ARPU)**: $2.50+ monthly
- **Lifetime Value (LTV)**: $15+ per retained user
- **Ad Revenue**: $0.10+ per DAU (if ads implemented)

### 5.4 Technical Performance
- **Crash Rate**: <1% of sessions
- **Load Time**: <3 seconds to gameplay
- **Save Reliability**: 99.9%+ save success rate
- **Offline Accuracy**: <5% deviation in calculated gains

## 6. Development Timeline

### 6.1 Phase 1: Core Foundation (Weeks 1-4)
**Deliverables:**
- Basic clicking mechanic with visual/audio feedback
- Development department with 4 employee types
- Cost scaling and production calculation system
- Local save/load functionality
- Basic UI framework and navigation

**Success Criteria:**
- Playable core loop from clicking to first automation
- 30 FPS performance on target devices
- Reliable save system with auto-save

### 6.2 Phase 2: Department Expansion (Weeks 5-8)
**Deliverables:**
- Sales department with lead generation
- Customer Experience department with ticket system
- Revenue calculation and multiplier mechanics
- Visual upgrades and office progression
- Offline progression system

**Success Criteria:**
- Three departments fully functional
- Resource conversion chains working correctly
- 24-hour offline progression accurate

### 6.3 Phase 3: Advanced Systems (Weeks 9-12)
**Deliverables:**
- Product, Design, QA, and Marketing departments
- Manager automation system
- Department-specific upgrade trees
- Achievement system foundation
- Audio system with dynamic effects

**Success Criteria:**
- All seven departments operational
- Manager automation reducing required clicks
- Upgrade paths providing meaningful progression

### 6.4 Phase 4: Prestige and Polish (Weeks 13-16)
**Deliverables:**
- Complete prestige system with IP bonuses
- Statistics tracking and display
- Tutorial and onboarding flow
- Performance optimization pass
- User interface polish and accessibility

**Success Criteria:**
- Prestige system encouraging long-term play
- New player onboarding completion rate >70%
- All technical performance targets met

### 6.5 Phase 5: Launch Preparation (Weeks 17-20)
**Deliverables:**
- Beta testing and feedback integration
- App store optimization (screenshots, description)
- Analytics integration for metrics tracking
- Final bug fixes and stability improvements
- Launch marketing materials

**Success Criteria:**
- Beta testing shows positive retention metrics
- App store approval obtained
- Analytics tracking functional
- Zero critical bugs in release candidate

## 7. Risk Assessment

### 7.1 High-Risk Items

**R-001: Progression Balance**
- **Risk**: Game becomes too easy/hard, affecting retention
- **Impact**: High - Poor balance kills long-term engagement
- **Mitigation**: Extensive playtesting, configurable balance parameters, post-launch tuning capability

**R-002: Performance on Low-End Devices**
- **Risk**: Game runs poorly on target minimum specs
- **Impact**: High - Excludes significant portion of market
- **Mitigation**: Early performance testing, optimization sprints, progressive enhancement approach

**R-003: Save Data Corruption**
- **Risk**: Players lose progress due to save system failures
- **Impact**: High - Lost progress leads to immediate churn
- **Mitigation**: Multiple save slots, data validation, comprehensive testing, recovery mechanisms

### 7.2 Medium-Risk Items

**R-004: Tutorial Complexity**
- **Risk**: New players abandon during onboarding
- **Impact**: Medium - Affects user acquisition efficiency
- **Mitigation**: A/B testing tutorial flows, user testing sessions, analytics tracking

**R-005: Audio System Issues**
- **Risk**: Audio bugs or performance problems
- **Impact**: Medium - Degrades experience but not gameplay
- **Mitigation**: Audio system abstraction, fallback to silent mode, user volume controls

**R-006: Platform Compatibility**
- **Risk**: React Native/Expo limitations affecting features
- **Impact**: Medium - May require architecture changes
- **Mitigation**: Early prototyping of complex features, fallback implementations

### 7.3 Low-Risk Items

**R-007: Art Asset Production**
- **Risk**: Visual assets delayed or insufficient quality
- **Impact**: Low - Can launch with simple graphics
- **Mitigation**: Placeholder graphics, phased art improvement, simple art style

**R-008: Market Competition**
- **Risk**: Similar games launched during development
- **Impact**: Low - Market is large enough for multiple games
- **Mitigation**: Focus on unique mechanics, rapid iteration based on market feedback

## 8. Dependencies and Assumptions

### 8.1 Technical Dependencies
- React Native/Expo framework stability
- Local storage API reliability across devices
- Audio playback system performance
- Touch interaction responsiveness

### 8.2 Business Assumptions
- Target market exists for incremental idle games
- Mobile gaming continues growth trajectory
- Players willing to engage with 7+ department complexity
- Offline progression is valuable to target audience

### 8.3 Resource Assumptions
- Development team of 2-3 developers available
- 20-week development timeline feasible
- Basic art/audio assets can be sourced affordably
- Testing devices available for target range

---

**Document Version**: 1.1  
**Last Updated**: August 13, 2025  
**Next Review**: Development Phase 2 Completion