{"type":"system","subtype":"init","cwd":"/mnt/c/dev/class-one-rapids","session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","tools":["Task","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","BashOutput","KillShell","Skill","SlashCommand"],"mcp_servers":[],"model":"claude-sonnet-4-5-20250929","permissionMode":"default","slash_commands":["prd","next-feature","next-feature-full-flow","fix-tests","expand-feature","execute-task","design","add-docs","reflect","reflect-convo","reflect-bug","refactor","research","research-technical","tasks","compact","context","cost","init","output-style:new","pr-comments","release-notes","todos","review","security-review"],"apiKeySource":"none","claude_code_version":"2.0.26","output_style":"default","agents":["general-purpose","statusline-setup","output-style-setup","Explore"],"skills":[],"uuid":"d64aedb6-fb4c-4d49-9b41-e4073d9e0fba"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DKAr8BxgbQBphagevvLocL","type":"message","role":"assistant","content":[{"type":"text","text":"I need to read the design template first to understand what structure to follow for the Technical Design Document."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":29949,"cache_read_input_tokens":16268,"cache_creation":{"ephemeral_5m_input_tokens":29949,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"d716b567-3408-4318-8def-b7019e62a277"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DKAr8BxgbQBphagevvLocL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RkAd7dbdthNEMjsjVak2Zu","name":"Read","input":{"file_path":"/mnt/c/dev/class-one-rapids/.claude/commands/design.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":29949,"cache_read_input_tokens":16268,"cache_creation":{"ephemeral_5m_input_tokens":29949,"ephemeral_1h_input_tokens":0},"output_tokens":94,"service_tier":"standard"}},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"9282397b-14f4-485c-a7b4-c02749756b4d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RkAd7dbdthNEMjsjVak2Zu","type":"tool_result","content":"     1→---\n     2→description: \"Generate a comprehensive Technical Design Document from a Product Requirements Document\"\n     3→argument-hint: \"<prd-file-path>\"\n     4→allowed-tools: \"Write, Read, Edit, Bash(date:*), Grep, Glob, Task\"\n     5→---\n     6→\n     7→# Technical Design Document Generator\n     8→\n     9→Generate a comprehensive Technical Design Document for the PRD at: **$ARGUMENTS**\n    10→\n    11→## Phase 1: PRD Analysis\n    12→\n    13→First, read and analyze the PRD to extract:\n    14→1. **Core Requirements**: Functional and non-functional requirements\n    15→2. **User Stories**: Understanding the user flows and acceptance criteria\n    16→3. **Success Metrics**: Performance targets and KPIs\n    17→4. **Scope Definition**: MVP features vs future enhancements\n    18→5. **Dependencies & Risks**: Technical constraints and mitigation needs\n    19→\n    20→## Phase 2: Technical Solution Design\n    21→\n    22→Based on the PRD analysis, design the technical solution covering:\n    23→\n    24→### Architecture Decisions\n    25→- Choose appropriate architectural patterns (monolithic, microservices, serverless)\n    26→- Define system boundaries and component responsibilities\n    27→- Select technology stack based on requirements\n    28→- Design for scalability, reliability, and maintainability\n    29→\n    30→### Implementation Strategy\n    31→- Break down features into technical components\n    32→- Define interfaces and contracts between components\n    33→- Plan data flow and state management\n    34→- Design error handling and recovery mechanisms\n    35→\n    36→## Phase 3: TDD Generation\n    37→\n    38→Generate a comprehensive Technical Design Document with these sections:\n    39→\n    40→### Document Structure\n    41→\n    42→```markdown\n    43→# [Feature Name] Technical Design Document\n    44→\n    45→## Document Control\n    46→| Version | Author | Date | Status | Changes |\n    47→|---------|--------|------|--------|---------|\n    48→| v1.0 | [Generated] | [Date] | Draft | Initial TDD from PRD |\n    49→\n    50→## Executive Summary\n    51→[2-3 sentence technical overview linking to PRD goals]\n    52→\n    53→## 1. Overview & Context\n    54→### Problem Statement\n    55→[Extract from PRD with technical perspective]\n    56→\n    57→### Solution Approach\n    58→[High-level technical approach to solve the problem]\n    59→\n    60→### Success Criteria\n    61→[Technical metrics aligned with PRD business metrics]\n    62→\n    63→## 2. Requirements Analysis\n    64→### Functional Requirements\n    65→[Map PRD user stories to technical capabilities]\n    66→\n    67→### Non-Functional Requirements\n    68→- Performance: [Specific benchmarks from PRD]\n    69→- Scalability: [User/data volume projections]\n    70→- Security: [Authentication, authorization, data protection]\n    71→- Availability: [Uptime requirements]\n    72→- Compliance: [Regulatory requirements if any]\n    73→\n    74→## 3. System Architecture\n    75→### High-Level Architecture\n    76→[Architecture diagram showing major components]\n    77→- Component breakdown\n    78→- Service boundaries\n    79→- External dependencies\n    80→\n    81→### Component Design\n    82→#### [Component Name]\n    83→- **Purpose**: [What it does]\n    84→- **Responsibilities**: [Core functions]\n    85→- **Interfaces**: [APIs/contracts]\n    86→- **Dependencies**: [What it needs]\n    87→\n    88→### Data Flow\n    89→[Sequence diagrams for critical user flows from PRD]\n    90→\n    91→## 4. API Design\n    92→### Internal APIs\n    93→| Endpoint | Method | Purpose | Request | Response |\n    94→|----------|--------|---------|---------|----------|\n    95→| /api/[resource] | GET/POST/etc | [Purpose] | [Schema] | [Schema] |\n    96→\n    97→### External Integrations\n    98→[Any third-party services or APIs]\n    99→\n   100→## 5. Data Model\n   101→### Entity Design\n   102→```\n   103→[Entity Name]\n   104→- field1: type (constraints)\n   105→- field2: type (constraints)\n   106→- relationships\n   107→```\n   108→\n   109→### Database Schema\n   110→- Tables/Collections structure\n   111→- Indexes for performance\n   112→- Data validation rules\n   113→- Migration strategy\n   114→\n   115→### Data Access Patterns\n   116→- Common queries\n   117→- Caching strategy\n   118→- Data consistency approach\n   119→\n   120→## 6. Security Design\n   121→### Authentication & Authorization\n   122→- Authentication method: [OAuth, JWT, etc.]\n   123→- Authorization model: [RBAC, ABAC, etc.]\n   124→- Session management\n   125→\n   126→### Data Security\n   127→- Encryption at rest: [Method]\n   128→- Encryption in transit: [TLS/HTTPS]\n   129→- PII handling: [Approach]\n   130→- Audit logging: [What's logged]\n   131→\n   132→### Security Controls\n   133→- Input validation\n   134→- Rate limiting\n   135→- CORS policies\n   136→- Security headers\n   137→\n   138→## 7. Test-Driven Development (TDD) Strategy\n   139→### TDD Approach (MANDATORY)\n   140→**All implementation must follow Red-Green-Refactor cycle**\n   141→\n   142→#### Testing Framework & Tools\n   143→- Framework: React Native Testing Library\n   144→- Reference: `/docs/research/react_native_testing_library_guide_20250918_184418.md`\n   145→- Test Runner: Jest with React Native preset\n   146→- Mocking: MSW for API mocking, Jest mocks for modules\n   147→\n   148→#### TDD Implementation Process\n   149→For each feature/component, follow this strict order:\n   150→\n   151→1. **RED Phase - Write Failing Test First**\n   152→   ```typescript\n   153→   // Example: Test for a new feature requirement\n   154→   test('should display user name in header', () => {\n   155→     render(<Header user={mockUser} />);\n   156→     expect(screen.getByText('John Doe')).toBeTruthy();\n   157→   });\n   158→   // This test MUST fail initially\n   159→   ```\n   160→\n   161→2. **GREEN Phase - Minimal Implementation**\n   162→   - Write ONLY enough code to pass the test\n   163→   - No extra features or optimizations\n   164→   - Focus on making test green\n   165→\n   166→3. **REFACTOR Phase - Improve Code**\n   167→   - Clean up implementation\n   168→   - Extract components/functions\n   169→   - Maintain all green tests\n   170→\n   171→#### Test Categories (in order of implementation)\n   172→\n   173→### Unit Testing (TDD First Layer)\n   174→- **Render Tests**: Component displays correctly\n   175→- **Interaction Tests**: User actions work properly\n   176→- **State Tests**: Data changes trigger correct updates\n   177→- Coverage target: > 80% for new code\n   178→- Testing approach: Test behavior, not implementation\n   179→\n   180→### Integration Testing (TDD Second Layer)\n   181→- **Component Integration**: Parent-child data flow\n   182→- **API Integration**: MSW mock handlers\n   183→- **Navigation Testing**: Screen transitions\n   184→- **Context/State Management**: Global state updates\n   185→\n   186→### End-to-End Testing (TDD Third Layer)\n   187→- **User Flows**: Complete feature workflows\n   188→- **Cross-Feature Integration**: Feature interactions\n   189→- **Performance Benchmarks**: Response time requirements\n   190→\n   191→### TDD Checklist for Each Component\n   192→- [ ] First test written before any implementation code\n   193→- [ ] Each test covers one specific behavior\n   194→- [ ] Tests use React Native Testing Library patterns\n   195→- [ ] No testIds unless absolutely necessary\n   196→- [ ] Tests query by user-visible content\n   197→- [ ] Async operations use waitFor/findBy\n   198→- [ ] All tests pass before next feature\n   199→\n   200→## 8. Infrastructure & Deployment\n   201→### Infrastructure Requirements\n   202→| Component | Specification | Justification |\n   203→|-----------|--------------|---------------|\n   204→| Compute | [CPU/Memory] | [Why needed] |\n   205→| Storage | [Type/Size] | [Data requirements] |\n   206→| Network | [Bandwidth] | [Traffic expectations] |\n   207→\n   208→### Deployment Architecture\n   209→- Environment strategy: [Dev/Staging/Prod]\n   210→- Container strategy: [Docker/K8s if applicable]\n   211→- CI/CD pipeline design\n   212→- Blue-green deployment approach\n   213→\n   214→### Monitoring & Observability\n   215→#### Metrics\n   216→- Application metrics: [Key metrics]\n   217→- Business metrics: [Aligned with PRD]\n   218→- Infrastructure metrics: [Resource utilization]\n   219→\n   220→#### Logging\n   221→- Log levels and categories\n   222→- Centralized logging strategy\n   223→- Log retention policy\n   224→\n   225→#### Alerting\n   226→| Alert | Condition | Priority | Action |\n   227→|-------|-----------|----------|--------|\n   228→| [Alert name] | [Trigger] | P0/P1/P2 | [Response] |\n   229→\n   230→## 9. Scalability & Performance\n   231→### Performance Requirements\n   232→[Extract from PRD and define technical targets]\n   233→- Response time: [<Xms for Y percentile]\n   234→- Throughput: [X requests/second]\n   235→- Concurrent users: [X users]\n   236→\n   237→### Scalability Strategy\n   238→- Horizontal scaling approach\n   239→- Load balancing strategy\n   240→- Database scaling (read replicas, sharding)\n   241→- Caching layers (Redis, CDN)\n   242→\n   243→### Performance Optimization\n   244→- Query optimization\n   245→- Asset optimization\n   246→- Code-level optimizations\n   247→- Resource pooling\n   248→\n   249→## 10. Risk Assessment & Mitigation\n   250→### Technical Risks\n   251→| Risk | Impact | Probability | Mitigation | Owner |\n   252→|------|--------|-------------|------------|-------|\n   253→| [From PRD + new technical risks] | High/Med/Low | High/Med/Low | [Strategy] | [Team] |\n   254→\n   255→### Dependencies\n   256→[Map PRD dependencies to technical components]\n   257→\n   258→## 11. Implementation Plan (TDD-Driven)\n   259→### Development Phases\n   260→Following @docs/guides/lean-task-generation-guide.md principles - prioritize user-visible functionality:\n   261→\n   262→#### Phase 1: Foundation & Test Setup [X weeks]\n   263→- Set up testing infrastructure (Jest, React Native Testing Library)\n   264→- Configure MSW for API mocking\n   265→- Create test utilities and custom renderers\n   266→- Set up CI/CD with test automation\n   267→- Core data models with tests first\n   268→\n   269→#### Phase 2: TDD Feature Implementation [X weeks]\n   270→[Map to PRD MVP features - each with TDD cycle]\n   271→\n   272→**For Each Feature:**\n   273→1. **Day 1-2: Test Planning**\n   274→   - Break down feature into testable behaviors\n   275→   - Write all failing tests for feature\n   276→   - Review tests against requirements\n   277→\n   278→2. **Day 3-4: Implementation**\n   279→   - Implement code to pass each test\n   280→   - Follow Red-Green-Refactor for each behavior\n   281→   - Keep all previous tests green\n   282→\n   283→3. **Day 5: Integration**\n   284→   - Write integration tests\n   285→   - Connect feature to system\n   286→   - Ensure end-to-end flow works\n   287→\n   288→Example Feature Breakdown:\n   289→- **[Feature 1]**: User Authentication\n   290→  - Test 1: Login form renders with email/password fields\n   291→  - Test 2: Validation shows errors for invalid email\n   292→  - Test 3: Successful login navigates to home\n   293→  - Test 4: Failed login shows error message\n   294→  - Test 5: Token stored securely after login\n   295→\n   296→#### Phase 3: Enhancement with TDD [X weeks]\n   297→[Map to PRD nice-to-have features]\n   298→- Write tests for enhanced features first\n   299→- Implement improvements test-by-test\n   300→- Performance optimization with benchmark tests\n   301→\n   302→#### Phase 4: Hardening [X weeks]\n   303→- Security testing suite\n   304→- Performance test suite\n   305→- Documentation of all test scenarios\n   306→- Coverage report review (must be >80%)\n   307→\n   308→### Technical Milestones\n   309→| Milestone | Deliverable | Date | Dependencies |\n   310→|-----------|------------|------|--------------|\n   311→| M1 | [Technical deliverable] | [Date] | [What's needed] |\n   312→\n   313→## 12. Decision Log\n   314→### Architecture Decisions\n   315→| Decision | Options Considered | Choice | Rationale |\n   316→|----------|-------------------|--------|-----------|\n   317→| [Database] | [SQL, NoSQL, etc] | [Choice] | [Why] |\n   318→| [Framework] | [Options] | [Choice] | [Why] |\n   319→\n   320→### Trade-offs\n   321→- [Trade-off 1]: Chose [X] over [Y] because [reason]\n   322→- [Trade-off 2]: Accepted [limitation] for [benefit]\n   323→\n   324→## 13. Open Questions\n   325→Technical questions requiring resolution:\n   326→- [ ] [Technical question from PRD analysis]\n   327→- [ ] [Architecture decision pending]\n   328→- [ ] [Integration clarification needed]\n   329→\n   330→## 14. Appendices\n   331→### A. Technical Glossary\n   332→[Define technical terms used]\n   333→\n   334→### B. Reference Architecture\n   335→[Links to similar systems or patterns]\n   336→\n   337→### C. Proof of Concepts\n   338→[Any POCs or prototypes created]\n   339→\n   340→### D. Related Documents\n   341→- Product Requirements Document: [Link to source PRD]\n   342→- Architecture Decision Records: [Links]\n   343→- API Documentation: [Links]\n   344→\n   345→---\n   346→*Generated from PRD: [filename]*\n   347→*Generation Date: [timestamp]*\n   348→```\n   349→\n   350→## Generation Requirements\n   351→\n   352→The TDD must:\n   353→1. **Directly address all PRD requirements** with technical solutions\n   354→2. **Include specific technologies** not vague descriptions\n   355→3. **Define measurable performance criteria** aligned with PRD metrics\n   356→4. **Provide implementation-ready details** for developers\n   357→5. **Include realistic timelines** based on technical complexity\n   358→6. **Address all risks** from PRD plus new technical risks\n   359→7. **Follow best practices** from the research guide\n   360→\n   361→## Quality Markers\n   362→\n   363→✅ **GOOD**: \"Use PostgreSQL 14+ with JSONB columns for flexible schema, indexed on user_id and created_at\"\n   364→❌ **BAD**: \"Use a database for data storage\"\n   365→\n   366→✅ **GOOD**: \"Implement JWT tokens with 15-minute expiry, refresh tokens in Redis with 7-day TTL\"\n   367→❌ **BAD**: \"Implement secure authentication\"\n   368→\n   369→✅ **GOOD**: \"Deploy using Kubernetes with 3 replicas, HPA scaling 2-10 pods based on 70% CPU\"\n   370→❌ **BAD**: \"Ensure the system is scalable\"\n   371→\n   372→## Implementation Steps\n   373→\n   374→1. **Read the PRD** at the specified path\n   375→2. **Extract key information** including requirements, user stories, metrics, and scope\n   376→3. **Design technical solution** addressing each PRD requirement\n   377→4. **Generate comprehensive TDD** following the template\n   378→5. **Include realistic details** for immediate implementation\n   379→6. **Save the document** with proper naming and location\n   380→\n   381→## Output\n   382→\n   383→Save the generated TDD to:\n   384→- Filename: `tdd_[feature_name_snake_case]_[YYYYMMDD].md`\n   385→- Location: `/docs/specs/` if it exists, otherwise `/docs/` or project root\n   386→- Include generation timestamp and source PRD reference\n   387→\n   388→The TDD should enable the development team to immediately begin implementation with clear technical direction and architectural decisions already made.\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"1a62ea36-391a-4fc1-9689-173dc11ee5af"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VfMVVDc3xf2UgeEXXvv2hN","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll generate a comprehensive Technical Design Document based on the PRD. Let me get the current date first:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":4564,"cache_read_input_tokens":46217,"cache_creation":{"ephemeral_5m_input_tokens":4564,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"7a0b1d62-5ad1-45f6-a9f5-9871721db5fc"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VfMVVDc3xf2UgeEXXvv2hN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GEptMMp54u4AZiSCJZz3m8","name":"Bash","input":{"command":"date +%Y%m%d","description":"Get current date in YYYYMMDD format"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":4564,"cache_read_input_tokens":46217,"cache_creation":{"ephemeral_5m_input_tokens":4564,"ephemeral_1h_input_tokens":0},"output_tokens":109,"service_tier":"standard"}},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"1377d6f2-ce29-455a-a366-ba75bf80c561"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GEptMMp54u4AZiSCJZz3m8","type":"tool_result","content":"20251024","is_error":false}]},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"527a781f-dfaf-4905-a609-fff32c2b0a34"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01B9GJgjRhs8KxqQMwNVsP5D","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll generate the comprehensive Technical Design Document:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":124,"cache_read_input_tokens":50781,"cache_creation":{"ephemeral_5m_input_tokens":124,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"e23a6905-8c95-4ec6-962d-b62becfda18f"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01B9GJgjRhs8KxqQMwNVsP5D","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01N7g3zi94nyx3KiiR6Eg3WU","name":"Write","input":{"file_path":"/mnt/c/dev/class-one-rapids/docs/specs/salvage-tinkering-system/tdd_salvage_tinkering_progressive_automation_20251024.md","content":"# Salvage & Tinkering Progressive Automation - Technical Design Document\n\n## Document Control\n| Version | Author | Date | Status | Changes |\n|---------|--------|------|--------|---------|\n| v1.0 | Generated from PRD | 2025-10-24 | Draft | Initial TDD from PRD v1.0 |\n\n## Executive Summary\nThis Technical Design Document defines the implementation architecture for a three-phase progressive automation system that transforms manual item salvaging and equipment tinkering into an automated idle game mechanic. The system leverages React Native with Zustand for state management, React Native Reanimated v3 for 60fps animations, and a Test-Driven Development approach to ensure each progression phase (Manual → Hybrid → Automation) delivers measurable engagement improvements while maintaining <3s app launch times and processing up to 100 items/second.\n\n## 1. Overview & Context\n\n### Problem Statement\nFrom a technical perspective, implementing idle game automation presents three core challenges:\n1. **Animation Performance**: Maintaining 60fps particle effects while processing 1-100 items/second on mid-range devices\n2. **State Synchronization**: Managing offline progression calculations with server validation while providing instant client-side feedback\n3. **Progression Calibration**: Dynamically adjusting automation unlock timing based on actual player behavior without hardcoded assumptions\n\n### Solution Approach\nWe implement a modular component architecture where:\n- **Phase 1 (Manual)**: Direct user interactions trigger immediate state updates with reanimated particle animations, teaching system mechanics through tactile feedback\n- **Phase 2 (Hybrid)**: Introduction of background workers using setInterval with configurable speeds, maintaining manual bonuses through dual code paths (manual vs automated)\n- **Phase 3 (Automation)**: Queue-based processing system with rule engine for filters, prestige calculation service, and offline accumulation with server reconciliation\n\n### Success Criteria\nTechnical metrics aligned with PRD business goals:\n- Animation frame rate: >55fps average during salvage bursts (60 items in 10 seconds)\n- State update latency: <16ms from user tap to UI feedback\n- Queue processing efficiency: 100 items/second with <10% CPU usage\n- Offline calculation accuracy: ±2% of server-calculated values\n- Test coverage: >80% for all new components\n- App bundle size increase: <5MB for complete feature\n\n## 2. Requirements Analysis\n\n### Functional Requirements\n\n#### FR1: Manual Salvaging (Phase 1)\n- **User Action**: Tap item → 0.5s animation → material burst → auto-collect at 0.5s\n- **Technical Need**: Event-driven animation system, particle spawner, material inventory state management\n- **Acceptance**: 60fps animations, <50ms tap-to-feedback latency\n\n#### FR2: Manual Tinkering (Phase 1)\n- **User Action**: Drag materials → hold 2s button → success animation → stat increase\n- **Technical Need**: Gesture recognizer, hold-to-activate component, equipment state store\n- **Acceptance**: 100% success rate for levels 1-10, visual progress circle during channel\n\n#### FR3: Automation Progression (Levels 10-26)\n- **User Action**: Unlock automation tiers → configure settings → view queue status\n- **Technical Need**: Unlock state machine, configurable interval workers, queue management system\n- **Acceptance**: 6 automation tiers with speeds: 3s, 2s, 1s, 0.33s, 0.1s, 0.01s per item\n\n#### FR4: Hybrid Manual Bonuses (Phase 2)\n- **User Action**: Manual clicks yield 2x materials, combos, critical hits\n- **Technical Need**: Dual calculation paths, combo detection (10 clicks in 5s), RNG for crits (5%)\n- **Acceptance**: Statistics tracking manual vs auto contribution\n\n#### FR5: Automation Controls (Phase 2-3)\n- **User Action**: Set filters, priorities, queue management\n- **Technical Need**: Rule engine for filters, priority sorting algorithm, queue data structure\n- **Acceptance**: Filter preview before enable, drag-to-reorder queue\n\n#### FR6: Offline Progression (Level 26+)\n- **User Action**: Close app → reopen → receive accumulated resources\n- **Technical Need**: Timestamp tracking, rate calculation, server validation service\n- **Acceptance**: 4-hour max accumulation, ±2% accuracy vs server\n\n#### FR7: Prestige System (Level 35+)\n- **User Action**: Reach milestone → choose bonus → apply temporary multiplier\n- **Technical Need**: Milestone counter, bonus selection modal, temporary effect timer\n- **Acceptance**: 3-choice system, 1-hour effect duration tracking\n\n### Non-Functional Requirements\n\n#### NFR1: Performance\n- **Animation Frame Rate**: 60fps target, >55fps acceptable during particle bursts\n- **Processing Throughput**: 100 items/second at Level 26 without UI stutter\n- **Queue Operations**: Add/remove/reorder in <50ms\n- **App Launch**: <3 seconds to interactive state on 4G (Expo requirement)\n- **Memory Footprint**: <50MB increase for feature (particle textures, queue data)\n\n#### NFR2: Scalability\n- **Inventory Size**: Support 100,000+ items with FlatList virtualization\n- **Material Counters**: Number.MAX_SAFE_INTEGER (9 quadrillion) with scientific notation\n- **Automation Processing**: O(1) performance from 1/sec to 100/sec using batch processing\n- **State Store Size**: <10MB for full game state with compression\n\n#### NFR3: Security\n- **Client Validation**: All salvage/tinker operations validated locally for instant feedback\n- **Server Authority**: Material balances reconciled server-side every 30s\n- **Rate Limiting**: Max 10 manual clicks/second to prevent automation exploits\n- **Offline Validation**: Server recalculates offline progression on reconnect, client shows estimate\n\n#### NFR4: Accessibility\n- **Color + Shape**: Materials have distinct shapes (circle, square, diamond, star) for colorblind users\n- **Haptics**: Expo Haptics feedback on tap, hold, success events\n- **Screen Readers**: All buttons/counters have accessibilityLabel props\n- **Touch Targets**: Minimum 44x44pt per iOS Human Interface Guidelines\n\n#### NFR5: Platform Support\n- **iOS**: 14+ (React Native 0.70+ compatibility)\n- **Android**: API 26+ (Android 8.0)\n- **Offline-First**: AsyncStorage for local state, background sync\n- **Cloud Save**: Sync to backend every 5 minutes or on app background\n\n## 3. System Architecture\n\n### High-Level Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     React Native App                         │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              Presentation Layer                       │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │  Inventory  │ │  Equipment   │ │  Automation  │  │  │\n│  │  │  Screen     │ │  Screen      │ │  Dashboard   │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  └───────────────────────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              State Management (Zustand)               │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │ Inventory   │ │  Materials   │ │  Automation  │  │  │\n│  │  │   Store     │ │    Store     │ │    Store     │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │ Equipment   │ │   Player     │ │   Prestige   │  │  │\n│  │  │   Store     │ │    Store     │ │    Store     │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  └───────────────────────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              Business Logic Layer                     │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │  Salvage    │ │  Tinkering   │ │  Automation  │  │  │\n│  │  │  Service    │ │  Service     │ │  Engine      │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │  Material   │ │  Offline     │ │  Prestige    │  │  │\n│  │  │  Calculator │ │  Progression │ │  Service     │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  └───────────────────────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              Animation Layer                          │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │  Particle   │ │  Number      │ │  Equipment   │  │  │\n│  │  │  System     │ │  Popup       │ │  Glow        │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  └───────────────────────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              Persistence Layer                        │  │\n│  │  ┌─────────────┐ ┌──────────────┐                    │  │\n│  │  │ AsyncStorage│ │  API Client  │                    │  │\n│  │  │  (Local)    │ │  (Backend)   │                    │  │\n│  │  └─────────────┘ └──────────────┘                    │  │\n│  └───────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Component Design\n\n#### Component 1: SalvageService\n- **Purpose**: Orchestrates salvaging operations for both manual and automated flows\n- **Responsibilities**:\n  - Process manual salvage with instant feedback\n  - Calculate materials with rarity RNG\n  - Trigger particle animations\n  - Apply manual bonuses (2x, combo, critical)\n  - Track statistics (manual vs auto counts)\n- **Interfaces**:\n  ```typescript\n  interface SalvageService {\n    salvageItem(itemId: string, isManual: boolean): SalvageResult;\n    salvageBatch(itemIds: string[], isManual: false): SalvageResult[];\n    calculateMaterials(item: Item, bonusMultiplier: number): Material[];\n    checkCritical(): boolean; // 5% chance\n  }\n  ```\n- **Dependencies**: MaterialsStore, InventoryStore, ParticleSystem\n\n#### Component 2: AutomationEngine\n- **Purpose**: Manages automation workers at different progression levels\n- **Responsibilities**:\n  - Start/stop automation workers based on unlock level\n  - Process queue at configured speeds (3s → 0.01s per item)\n  - Apply filters and rules before processing\n  - Maintain queue data structure (max 10,000 items)\n  - Emit events for UI updates\n- **Interfaces**:\n  ```typescript\n  interface AutomationEngine {\n    start(level: AutomationLevel): void;\n    stop(): void;\n    addToQueue(items: Item[]): void;\n    removeFromQueue(itemId: string): void;\n    reorderQueue(fromIndex: number, toIndex: number): void;\n    setFilters(filters: SalvageFilter[]): void;\n    getQueueStatus(): QueueStatus;\n  }\n  ```\n- **Dependencies**: SalvageService, InventoryStore, AutomationStore\n\n#### Component 3: TinkeringService\n- **Purpose**: Handles equipment upgrades with materials\n- **Responsibilities**:\n  - Validate material requirements\n  - Calculate success rate (100% for Phase 1, variable later)\n  - Apply upgrades to equipment\n  - Calculate power level increases\n  - Handle manual vs auto tinkering cost difference (50% reduction manual)\n- **Interfaces**:\n  ```typescript\n  interface TinkeringService {\n    tinkerEquipment(equipmentId: string, isManual: boolean): TinkerResult;\n    calculateCost(equipment: Equipment, isManual: boolean): MaterialCost;\n    calculateSuccessRate(playerLevel: number): number;\n    applyUpgrade(equipment: Equipment, bonusLevel: number): Equipment;\n  }\n  ```\n- **Dependencies**: MaterialsStore, EquipmentStore, PlayerStore\n\n#### Component 4: ParticleSystem\n- **Purpose**: Renders high-performance particle animations using Reanimated\n- **Responsibilities**:\n  - Spawn particles on salvage (10-30 particles per salvage)\n  - Color-code particles by rarity\n  - Animate particle trajectories (burst → collect)\n  - Pool particle objects for performance (max 300 active)\n  - Maintain 60fps during multi-salvage bursts\n- **Interfaces**:\n  ```typescript\n  interface ParticleSystem {\n    spawnParticles(x: number, y: number, material: Material, count: number): void;\n    animateCollection(particles: Particle[], targetX: number, targetY: number): void;\n    clearParticles(): void;\n    setPoolSize(size: number): void;\n  }\n  ```\n- **Dependencies**: react-native-reanimated, MaterialsStore (for target coordinates)\n\n#### Component 5: OfflineProgressionService\n- **Purpose**: Calculates and validates offline resource accumulation\n- **Responsibilities**:\n  - Store exit timestamp when app backgrounds\n  - Calculate elapsed time on return (capped at 4 hours)\n  - Compute materials based on automation rates at exit\n  - Request server validation\n  - Show welcome-back modal with results\n- **Interfaces**:\n  ```typescript\n  interface OfflineProgressionService {\n    recordAppExit(): Promise<void>;\n    calculateOfflineRewards(): OfflineRewards;\n    validateWithServer(clientCalculation: OfflineRewards): Promise<OfflineRewards>;\n    applyOfflineRewards(rewards: OfflineRewards): void;\n  }\n  ```\n- **Dependencies**: AutomationStore, MaterialsStore, API Client\n\n#### Component 6: PrestigeService\n- **Purpose**: Manages prestige milestones and bonus selection\n- **Responsibilities**:\n  - Track salvage count toward 1,000-item milestones\n  - Trigger prestige choice modal\n  - Apply temporary bonuses (1hr +10% materials, etc.)\n  - Maintain bonus timers\n  - Calculate prestige point accumulation\n- **Interfaces**:\n  ```typescript\n  interface PrestigeService {\n    checkMilestone(): boolean;\n    applyPrestigeBonus(choice: PrestigeChoice): void;\n    getActiveBonus(): PrestigeBonus | null;\n    calculatePrestigePoints(totalSalvages: number): number;\n  }\n  ```\n- **Dependencies**: MaterialsStore, PrestigeStore, PlayerStore\n\n### Data Flow\n\n#### Critical Flow 1: Manual Salvage\n```\nUser taps item\n  ↓\n[InventoryScreen] onPress handler\n  ↓\n[SalvageService] salvageItem(itemId, isManual=true)\n  ↓\n[MaterialCalculator] calculateMaterials(item, 2x multiplier)\n  ↓\n[ParticleSystem] spawnParticles(x, y, materials, count)\n  ↓ (parallel)\n[MaterialsStore] addMaterials(materials)\n  ↓\n[ParticleSystem] animateCollection(particles, targetCoords)\n  ↓ (0.5s delay)\n[MaterialsStore] triggers UI update → number popup animation\n  ↓\n[InventoryStore] removeItem(itemId)\n```\n\n#### Critical Flow 2: Automation Processing\n```\n[AutomationEngine] interval tick (speed based on level)\n  ↓\n[AutomationEngine] getNextItemFromQueue()\n  ↓\n[AutomationEngine] applyFilters(item) → allow/skip\n  ↓\n[SalvageService] salvageItem(itemId, isManual=false)\n  ↓\n[MaterialCalculator] calculateMaterials(item, 1x multiplier)\n  ↓\n[MaterialsStore] addMaterials(materials) → NO particle animation\n  ↓\n[AutomationEngine] updateQueueStatus() → UI shows progress\n```\n\n#### Critical Flow 3: Offline Progression\n```\nApp moves to background\n  ↓\n[OfflineProgressionService] recordAppExit()\n  ↓\n[AsyncStorage] save { exitTime, automationRate, queueSize }\n  ↓\nApp returns to foreground\n  ↓\n[OfflineProgressionService] calculateOfflineRewards()\n  ↓\nCalculate: min(elapsed, 4hrs) × automationRate → materials\n  ↓ (parallel)\n[OfflineProgressionService] validateWithServer(clientCalc)\n  ↓\n[API Client] POST /offline-validate → server recalculates\n  ↓\nUse server result if different by >2%\n  ↓\n[MaterialsStore] addMaterials(offlineRewards)\n  ↓\n[WelcomeBackModal] show summary\n```\n\n## 4. API Design\n\n### Internal APIs\n\n#### Salvage Module\n| Function | Purpose | Input | Output |\n|----------|---------|-------|--------|\n| `salvageItem(itemId, isManual)` | Process single item salvage | itemId: string, isManual: boolean | SalvageResult: { materials: Material[], isCritical: boolean } |\n| `salvageBatch(itemIds)` | Process multiple items (automation) | itemIds: string[] | SalvageResult[] |\n| `calculateMaterials(item, multiplier)` | Determine materials from item | item: Item, multiplier: number | Material[] |\n\n#### Automation Module\n| Function | Purpose | Input | Output |\n|----------|---------|-------|--------|\n| `startAutomation(level)` | Begin automation at tier | level: 10\\|13\\|15\\|18\\|22\\|26 | void |\n| `setSpeed(itemsPerSecond)` | Configure processing rate | itemsPerSecond: number | void |\n| `addFilter(filter)` | Add automation filter | filter: SalvageFilter | void |\n| `getQueue()` | Retrieve current queue | none | QueueItem[] |\n\n#### Tinkering Module\n| Function | Purpose | Input | Output |\n|----------|---------|-------|--------|\n| `tinker(equipId, isManual)` | Upgrade equipment | equipId: string, isManual: boolean | TinkerResult: { success: boolean, newLevel: number } |\n| `getCost(equipId, isManual)` | Calculate material cost | equipId: string, isManual: boolean | MaterialCost |\n| `setPriority(equipId, priority)` | Set auto-tinker priority | equipId: string, priority: 1-5 | void |\n\n### External Integrations\n\n#### Backend API Endpoints\n| Endpoint | Method | Purpose | Request | Response |\n|----------|--------|---------|---------|----------|\n| `/api/player/state` | GET | Fetch player state | Auth token | PlayerState (inventory, materials, equipment) |\n| `/api/player/state` | POST | Save player state | PlayerState | { success: boolean, timestamp: number } |\n| `/api/offline/validate` | POST | Validate offline calc | { exitTime, returnTime, clientMaterials } | { validatedMaterials: Material[], serverTimestamp: number } |\n| `/api/prestige/record` | POST | Record prestige milestone | { salvageCount, choiceId } | { prestigePoints: number } |\n\n## 5. Data Model\n\n### Entity Design\n\n#### Item Entity\n```typescript\ninterface Item {\n  id: string;\n  name: string;\n  rarity: 'common' | 'rare' | 'epic' | 'legendary';\n  salvageValue: number; // Base material multiplier\n  iconUrl: string;\n  acquiredAt: number; // Timestamp\n}\n```\n\n#### Material Entity\n```typescript\ninterface Material {\n  type: 'common' | 'rare' | 'epic' | 'legendary';\n  amount: number;\n  shape: 'circle' | 'square' | 'diamond' | 'star'; // For accessibility\n  color: string; // Hex color\n}\n```\n\n#### Equipment Entity\n```typescript\ninterface Equipment {\n  id: string;\n  slot: 'weapon' | 'armor' | 'accessory';\n  level: number; // Upgrade level\n  powerLevel: number; // Calculated stat\n  tinkerCost: MaterialCost; // Current upgrade cost\n  autoPriority: number; // 1-5, for auto-tinker\n}\n```\n\n#### AutomationState Entity\n```typescript\ninterface AutomationState {\n  isActive: boolean;\n  currentLevel: 10 | 13 | 15 | 18 | 22 | 26;\n  itemsPerSecond: number;\n  queue: QueueItem[];\n  filters: SalvageFilter[];\n  statistics: {\n    totalProcessed: number;\n    manualCount: number;\n    autoCount: number;\n    manualMaterials: number;\n    autoMaterials: number;\n  };\n}\n```\n\n#### PrestigeState Entity\n```typescript\ninterface PrestigeState {\n  totalSalvages: number;\n  nextMilestone: number; // Next 1000 mark\n  prestigePoints: number;\n  activeBonus: {\n    type: 'material_boost' | 'guaranteed_rare' | 'tinker_speed';\n    multiplier: number;\n    expiresAt: number; // Timestamp\n  } | null;\n  milestoneHistory: PrestigeChoice[];\n}\n```\n\n### Database Schema\n\n#### AsyncStorage Keys (Local)\n```\nplayer_state: PlayerState (JSON)\ninventory_items: Item[] (JSON)\nmaterials: { [type]: amount } (JSON)\nequipment: Equipment[] (JSON)\nautomation_state: AutomationState (JSON)\nprestige_state: PrestigeState (JSON)\noffline_exit_timestamp: number\noffline_automation_rate: number\n```\n\n#### Backend Schema (Conceptual)\n```sql\n-- Players table\nCREATE TABLE players (\n  id UUID PRIMARY KEY,\n  username VARCHAR(255),\n  level INTEGER,\n  created_at TIMESTAMP,\n  last_sync TIMESTAMP\n);\n\n-- Player inventory\nCREATE TABLE player_inventory (\n  player_id UUID REFERENCES players(id),\n  item_id UUID,\n  acquired_at TIMESTAMP,\n  PRIMARY KEY (player_id, item_id)\n);\nCREATE INDEX idx_player_inventory ON player_inventory(player_id);\n\n-- Player materials\nCREATE TABLE player_materials (\n  player_id UUID REFERENCES players(id),\n  material_type VARCHAR(50),\n  amount BIGINT,\n  PRIMARY KEY (player_id, material_type)\n);\n\n-- Player equipment\nCREATE TABLE player_equipment (\n  player_id UUID REFERENCES players(id),\n  equipment_id UUID,\n  level INTEGER,\n  power_level INTEGER,\n  PRIMARY KEY (player_id, equipment_id)\n);\n\n-- Offline progression logs\nCREATE TABLE offline_progression_log (\n  player_id UUID REFERENCES players(id),\n  exit_timestamp TIMESTAMP,\n  return_timestamp TIMESTAMP,\n  client_materials JSONB,\n  server_materials JSONB,\n  logged_at TIMESTAMP\n);\nCREATE INDEX idx_offline_log ON offline_progression_log(player_id, logged_at);\n```\n\n### Data Access Patterns\n\n#### Common Queries\n1. **Load Player State**: Read all AsyncStorage keys on app launch → hydrate Zustand stores\n2. **Save Player State**: Debounced write to AsyncStorage every 5s during active play\n3. **Sync to Backend**: POST to `/api/player/state` every 5 minutes or on app background\n4. **Queue Operations**: Array operations (push, splice, swap) on in-memory queue (max 10,000)\n\n#### Caching Strategy\n- **Local First**: All game state lives in Zustand stores (in-memory)\n- **AsyncStorage**: Persistent cache synced every 5s\n- **Backend**: Source of truth, synced every 5min + on app close\n- **Conflict Resolution**: Server timestamp wins on conflicts\n\n#### Data Consistency\n- **Optimistic Updates**: UI updates immediately on user actions\n- **Server Reconciliation**: Backend validates on sync, client accepts server corrections\n- **Offline Queue**: Actions queued locally, replayed to server on reconnect\n\n## 6. Security Design\n\n### Authentication & Authorization\n- **Authentication**: JWT tokens issued by backend auth service (not part of this feature)\n- **Authorization**: Player can only modify their own inventory/materials (enforced server-side)\n- **Session Management**: JWT stored in SecureStore (Expo), 7-day expiry with refresh\n\n### Data Security\n- **Encryption at Rest**: AsyncStorage data not encrypted (game state, not PII)\n- **Encryption in Transit**: All API calls over HTTPS/TLS 1.3\n- **PII Handling**: No PII in salvage/tinkering data (player ID only)\n- **Audit Logging**: Server logs all state changes with timestamps for anti-cheat\n\n### Security Controls\n\n#### Input Validation\n```typescript\n// Client-side validation (instant feedback)\nfunction validateSalvage(itemId: string): boolean {\n  const item = inventoryStore.getItem(itemId);\n  if (!item) return false; // Item doesn't exist\n  if (item.salvageValue <= 0) return false; // Invalid item\n  return true;\n}\n\n// Server-side validation (authority)\nfunction validateSalvageServer(playerId: string, itemId: string): boolean {\n  // Check player owns item\n  // Check item not already salvaged\n  // Check timestamps for rate limiting\n  return true;\n}\n```\n\n#### Rate Limiting\n- **Client**: Max 10 manual salvages/second (enforced by debouncing tap handler)\n- **Server**: Max 100 salvages/minute per player (prevents automation bots)\n- **Automation**: Server validates automation rate matches player's unlock level\n\n#### Anti-Cheat Measures\n- **Material Balance Checks**: Server recalculates expected materials based on logged salvages\n- **Offline Progression Validation**: Server independently calculates offline rewards, flags >5% discrepancies\n- **Queue Integrity**: Server validates queue operations against player's inventory state\n\n## 7. Test-Driven Development (TDD) Strategy\n\n### TDD Approach (MANDATORY)\nAll implementation follows strict Red-Green-Refactor cycle using React Native Testing Library.\n\n### Testing Framework & Tools\n- **Framework**: React Native Testing Library + Jest\n- **Reference**: `/docs/research/react_native_testing_library_guide_20250918_184418.md`\n- **Test Runner**: Jest with React Native preset (already configured in project)\n- **Mocking**:\n  - API calls: MSW (Mock Service Worker)\n  - Animations: Mock `react-native-reanimated` with `reanimated-jest`\n  - AsyncStorage: `@react-native-async-storage/async-storage/jest/async-storage-mock`\n  - Timers: Jest fake timers for interval testing\n\n### TDD Implementation Process\n\n#### RED Phase Example: Manual Salvage\n```typescript\n// SalvageService.test.ts\nimport { render, fireEvent, screen, waitFor } from '@testing-library/react-native';\nimport { InventoryScreen } from '../screens/InventoryScreen';\nimport { setupTestStores } from '../test-utils/storeSetup';\n\ndescribe('Manual Salvage', () => {\n  beforeEach(() => {\n    setupTestStores({\n      inventory: [{ id: 'item1', name: 'Rusty Sword', rarity: 'common' }],\n      materials: { common: 0 }\n    });\n  });\n\n  test('should salvage item and add materials on tap', async () => {\n    render(<InventoryScreen />);\n\n    // Arrange\n    const item = screen.getByText('Rusty Sword');\n    expect(screen.getByText('Common: 0')).toBeTruthy();\n\n    // Act\n    fireEvent.press(item);\n\n    // Assert\n    await waitFor(() => {\n      expect(screen.queryByText('Rusty Sword')).toBeNull(); // Item removed\n      expect(screen.getByText(/Common: 1[0-9]/)).toBeTruthy(); // Materials added (10-15 range)\n    }, { timeout: 1000 });\n  });\n\n  test('should apply 2x multiplier for manual salvage', async () => {\n    render(<InventoryScreen />);\n\n    const item = screen.getByText('Rusty Sword');\n    fireEvent.press(item);\n\n    await waitFor(() => {\n      // Base salvage = 10 common, manual = 2x = 20 common\n      expect(screen.getByText('Common: 20')).toBeTruthy();\n    });\n  });\n\n  test('should trigger combo after 10 clicks in 5 seconds', async () => {\n    const { inventory } = setupTestStores({\n      inventory: Array(15).fill(null).map((_, i) => ({\n        id: `item${i}`, name: `Item ${i}`, rarity: 'common'\n      }))\n    });\n\n    render(<InventoryScreen />);\n\n    // Click 10 items rapidly\n    for (let i = 0; i < 10; i++) {\n      fireEvent.press(screen.getByText(`Item ${i}`));\n      await waitFor(() => {}, { timeout: 10 }); // Small delay to allow state update\n    }\n\n    // Assert combo triggered\n    await waitFor(() => {\n      expect(screen.getByText(/Combo Burst!/)).toBeTruthy();\n    });\n  });\n});\n```\n\n#### GREEN Phase: Minimal Implementation\n```typescript\n// SalvageService.ts\nexport class SalvageService {\n  salvageItem(itemId: string, isManual: boolean): SalvageResult {\n    const item = inventoryStore.getItem(itemId);\n    if (!item) throw new Error('Item not found');\n\n    // Calculate materials\n    const baseMaterials = item.salvageValue; // e.g., 10\n    const multiplier = isManual ? 2 : 1;\n    const materialAmount = baseMaterials * multiplier;\n\n    // Add to materials store\n    materialsStore.addMaterial('common', materialAmount);\n\n    // Remove from inventory\n    inventoryStore.removeItem(itemId);\n\n    return {\n      materials: [{ type: 'common', amount: materialAmount }],\n      isCritical: false\n    };\n  }\n}\n```\n\n#### REFACTOR Phase: Improve Implementation\n```typescript\n// Extract material calculation\nclass MaterialCalculator {\n  calculate(item: Item, bonusMultiplier: number): Material[] {\n    const base = item.salvageValue;\n    const amount = Math.floor(base * bonusMultiplier);\n\n    // Add rarity RNG\n    const materials: Material[] = [{ type: 'common', amount }];\n\n    if (Math.random() < this.getRareChance(item.rarity)) {\n      materials.push({ type: 'rare', amount: Math.floor(amount / 3) });\n    }\n\n    return materials;\n  }\n\n  private getRareChance(rarity: string): number {\n    return { common: 0.25, rare: 0.50, epic: 0.75, legendary: 1.0 }[rarity] || 0;\n  }\n}\n\n// Refactored SalvageService\nexport class SalvageService {\n  constructor(private calculator: MaterialCalculator) {}\n\n  salvageItem(itemId: string, isManual: boolean): SalvageResult {\n    const item = inventoryStore.getItem(itemId);\n    if (!item) throw new Error('Item not found');\n\n    const multiplier = isManual ? 2 : 1;\n    const materials = this.calculator.calculate(item, multiplier);\n\n    materials.forEach(m => materialsStore.addMaterial(m.type, m.amount));\n    inventoryStore.removeItem(itemId);\n\n    return { materials, isCritical: false };\n  }\n}\n```\n\n### Test Categories (in order of implementation)\n\n#### Unit Testing (TDD First Layer)\n\n**Components to Test**:\n1. **SalvageService**: All salvage logic\n   - [ ] Manual salvage removes item and adds materials\n   - [ ] Manual salvage applies 2x multiplier\n   - [ ] Auto salvage applies 1x multiplier\n   - [ ] Critical salvage (5% chance) applies 5x multiplier\n   - [ ] Combo detection (10 in 5 seconds)\n\n2. **TinkeringService**: All tinkering logic\n   - [ ] Tinker consumes materials\n   - [ ] Tinker increases equipment level\n   - [ ] Manual tinker costs 50% less\n   - [ ] Success rate is 100% for levels 1-10\n\n3. **MaterialCalculator**: Material RNG\n   - [ ] Calculates base materials correctly\n   - [ ] Applies multipliers\n   - [ ] RNG rare materials based on item rarity\n\n4. **AutomationEngine**: Queue and processing\n   - [ ] Adds items to queue\n   - [ ] Processes queue at configured speed\n   - [ ] Respects filters (auto-salvage commons only)\n   - [ ] Reorders queue correctly\n\n**Coverage Target**: >85% for services\n\n#### Integration Testing (TDD Second Layer)\n\n**Integration Scenarios**:\n1. **Inventory + Salvage + Materials Flow**\n   ```typescript\n   test('complete salvage flow updates all stores', async () => {\n     // Test that tapping item updates inventory, materials, and statistics\n   });\n   ```\n\n2. **Automation + Queue + Salvage Integration**\n   ```typescript\n   test('automation processes queue and updates materials', async () => {\n     jest.useFakeTimers();\n     automationEngine.start(10); // Level 10 = 1 item/3s\n\n     // Advance 3 seconds\n     jest.advanceTimersByTime(3000);\n\n     expect(materialsStore.getCommon()).toBeGreaterThan(0);\n   });\n   ```\n\n3. **Offline Progression Calculation**\n   ```typescript\n   test('offline rewards calculated correctly', async () => {\n     offlineService.recordAppExit();\n\n     // Simulate 2 hours passing\n     jest.setSystemTime(Date.now() + 2 * 60 * 60 * 1000);\n\n     const rewards = offlineService.calculateOfflineRewards();\n     expect(rewards.materials.common).toBe(2 * 60 * 60 * automationRate);\n   });\n   ```\n\n**Coverage Target**: >75% for integration paths\n\n#### End-to-End Testing (TDD Third Layer)\n\n**E2E User Flows**:\n1. **Phase 1 Progression: Manual → First Automation**\n   - Start with 50 items in inventory\n   - Manually salvage 30 items\n   - Collect 500 common materials\n   - Tinker equipment to +5\n   - Reach level 10 → unlock automation\n   - Enable automation → verify queue processing\n\n2. **Phase 2: Hybrid Gameplay**\n   - Manual click 10 items → trigger combo\n   - Enable automation → verify both manual and auto contribute\n   - Set filter to auto-salvage commons only\n   - Manually salvage rare item → verify 2x bonus\n\n3. **Offline Progression Flow**\n   - Enable automation at 10 items/sec\n   - Background app for 1 hour (simulated)\n   - Return → verify welcome modal\n   - Verify materials match expected (3600 items × materials per item)\n\n### TDD Checklist for Each Component\n- [ ] Test written BEFORE implementation code\n- [ ] Test queries by user-visible content (text, accessibility labels)\n- [ ] Avoid testID unless absolutely necessary\n- [ ] Async operations use `waitFor` or `findBy`\n- [ ] Mock external dependencies (API, AsyncStorage, timers)\n- [ ] Tests are deterministic (no actual RNG, use seeded random)\n- [ ] All tests pass before committing\n- [ ] Coverage report shows >80% coverage\n\n## 8. Infrastructure & Deployment\n\n### Infrastructure Requirements\n\n| Component | Specification | Justification |\n|-----------|--------------|---------------|\n| Client App | React Native 0.70+, Expo SDK 48+ | Current project stack |\n| Animations | Reanimated v3 | 60fps requirement |\n| State | Zustand 4.x | Lightweight, performant |\n| Storage | AsyncStorage | Offline-first architecture |\n| Backend | Node.js 18+ / Express | Existing backend stack |\n| Database | PostgreSQL 14+ | Relational data, ACID guarantees |\n| Cache | Redis 7+ | Session management, rate limiting |\n\n### Deployment Architecture\n\n#### Environment Strategy\n- **Development**: Local Expo dev server, local PostgreSQL\n- **Staging**: Expo EAS Update staging channel, AWS RDS staging\n- **Production**: Expo EAS Update production channel, AWS RDS production\n\n#### CI/CD Pipeline\n```yaml\n# .github/workflows/test-and-deploy.yml\nname: Test & Deploy\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      - run: npm ci\n      - run: npm run test:coverage\n      - run: npx codecov # Upload coverage\n\n  build-ios:\n    needs: test\n    if: github.ref == 'refs/heads/main'\n    runs-on: macos-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npx expo build:ios\n\n  build-android:\n    needs: test\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npx expo build:android\n\n  deploy-ota:\n    needs: [build-ios, build-android]\n    runs-on: ubuntu-latest\n    steps:\n      - run: npx expo publish --release-channel production\n```\n\n### Monitoring & Observability\n\n#### Metrics\n- **Application Metrics**:\n  - Salvage operations per second (avg, p95, p99)\n  - Animation frame rate during bursts (target >55fps)\n  - Queue processing lag (time between item added and processed)\n  - Offline calculation accuracy (% difference from server)\n\n- **Business Metrics**:\n  - Players reaching Level 10 (first automation unlock) - target 65%\n  - Manual vs auto salvage ratio - target 40% manual\n  - Daily active users with automation enabled\n  - Prestige milestone completion rate\n\n- **Infrastructure Metrics**:\n  - App launch time (target <3s)\n  - Memory usage (target <200MB total app)\n  - API response time (target p95 <200ms)\n  - Backend CPU/memory utilization\n\n#### Logging\n```typescript\n// Centralized logger\nimport * as Sentry from '@sentry/react-native';\n\nconst logger = {\n  info: (message: string, context: object) => {\n    console.log(message, context);\n    Sentry.addBreadcrumb({ message, data: context, level: 'info' });\n  },\n\n  error: (message: string, error: Error, context: object) => {\n    console.error(message, error, context);\n    Sentry.captureException(error, { extra: context });\n  },\n\n  performance: (operation: string, duration: number) => {\n    Sentry.addBreadcrumb({\n      message: `${operation} took ${duration}ms`,\n      level: 'info',\n      category: 'performance'\n    });\n  }\n};\n\n// Usage\nlogger.info('Manual salvage', { itemId, materials, isCritical });\nlogger.performance('salvage_animation', animationDuration);\n```\n\n#### Alerting\n\n| Alert | Condition | Priority | Action |\n|-------|-----------|----------|--------|\n| High crash rate | >2% of sessions crash | P0 | Rollback OTA update, investigate Sentry errors |\n| Animation perf degradation | Avg FPS <50 for 10min | P1 | Review particle pooling, check for memory leaks |\n| Offline calc divergence | >10% of offline validations fail | P1 | Check rate calculation logic, review server logs |\n| API latency spike | p95 >500ms for 5min | P2 | Check backend CPU, investigate slow queries |\n| Low automation adoption | <50% of L10+ players enable automation | P2 | Review unlock messaging, check for UX friction |\n\n## 9. Scalability & Performance\n\n### Performance Requirements\n\nFrom PRD, translated to technical targets:\n\n| Requirement | Technical Target | Measurement |\n|-------------|-----------------|-------------|\n| Animation frame rate | >55fps avg during 60-item/10s burst | React DevTools Profiler |\n| Salvage processing | 100 items/sec at Level 26 | Performance.now() timing |\n| Queue operations | Add/remove/reorder in <50ms | Performance.now() timing |\n| App launch | <3s to interactive (Expo requirement) | Time to First Interaction metric |\n| Memory footprint | <50MB increase for feature | Xcode Instruments / Android Profiler |\n\n### Scalability Strategy\n\n#### Client-Side Scalability\n\n**Challenge**: Processing 100 items/second while maintaining 60fps\n**Solution**: Batch processing with requestAnimationFrame\n\n```typescript\nclass AutomationEngine {\n  private processingQueue: Item[] = [];\n  private batchSize = 10; // Process 10 items per frame at 60fps = 600/sec capacity\n\n  start(level: AutomationLevel) {\n    const itemsPerSecond = this.getSpeedForLevel(level);\n    const frameInterval = Math.ceil(60 / itemsPerSecond); // e.g., process every 1 frame for 60/sec\n\n    let frameCount = 0;\n    const processFrame = () => {\n      frameCount++;\n\n      if (frameCount % frameInterval === 0) {\n        this.processBatch(this.batchSize);\n      }\n\n      this.animationFrameId = requestAnimationFrame(processFrame);\n    };\n\n    processFrame();\n  }\n\n  private processBatch(count: number) {\n    const batch = this.processingQueue.splice(0, count);\n    const results = salvageService.salvageBatch(batch.map(i => i.id));\n    // Update materials in single store update (batched re-render)\n    materialsStore.addMaterialsBatch(results.flatMap(r => r.materials));\n  }\n}\n```\n\n**Challenge**: Inventory with 100,000+ items\n**Solution**: Virtual scrolling with React Native FlatList\n\n```typescript\n<FlatList\n  data={inventory}\n  renderItem={({ item }) => <InventoryItemCard item={item} />}\n  keyExtractor={(item) => item.id}\n  windowSize={5} // Render 5 screens worth of content\n  maxToRenderPerBatch={10}\n  updateCellsBatchingPeriod={50}\n  removeClippedSubviews={true}\n  getItemLayout={(data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  })}\n/>\n```\n\n#### Backend Scalability\n\n**Challenge**: Supporting 1M concurrent users\n**Solution**: Horizontal scaling with stateless API servers\n\n- **API Servers**: Auto-scaling group (2-10 instances) behind ALB\n- **Database**: PostgreSQL with read replicas (1 primary, 2 replicas)\n- **Caching**: Redis cluster for session data and rate limiting\n- **Queue**: Background job queue for async operations (offline validation)\n\n### Performance Optimization\n\n#### Animation Optimization\n```typescript\n// Particle pooling to avoid allocation overhead\nclass ParticlePool {\n  private pool: Particle[] = [];\n  private active: Set<Particle> = new Set();\n\n  constructor(poolSize = 300) {\n    for (let i = 0; i < poolSize; i++) {\n      this.pool.push(this.createParticle());\n    }\n  }\n\n  acquire(): Particle {\n    const particle = this.pool.pop() || this.createParticle();\n    this.active.add(particle);\n    return particle;\n  }\n\n  release(particle: Particle) {\n    this.active.delete(particle);\n    particle.reset();\n    this.pool.push(particle);\n  }\n}\n```\n\n#### Query Optimization\n```sql\n-- Optimize player state loading\nCREATE INDEX idx_player_materials ON player_materials(player_id);\nCREATE INDEX idx_player_inventory_acquired ON player_inventory(player_id, acquired_at DESC);\n\n-- Optimize offline progression query\nCREATE INDEX idx_offline_log_recent ON offline_progression_log(player_id, logged_at DESC);\n```\n\n#### Code-Level Optimizations\n- **Zustand selectors**: Use shallow equality checks to prevent unnecessary re-renders\n- **React.memo**: Memoize InventoryItemCard, MaterialCounter components\n- **useCallback**: Memoize event handlers to prevent child re-renders\n- **useMemo**: Memoize expensive calculations (material totals, power level)\n\n## 10. Risk Assessment & Mitigation\n\n### Technical Risks\n\n| Risk | Impact | Probability | Mitigation | Owner |\n|------|--------|-------------|------------|-------|\n| Reanimated v3 performance issues on Android | High | Medium | Early prototype (Week 1), fallback to React Native Animated, reduce particle count on low-end devices | Engineering |\n| Queue processing causes UI jank at 100/sec | High | Medium | Implement batching with RAF, throttle UI updates to 10fps for counters, use web workers if needed | Engineering |\n| Offline calc exploits (client manipulation) | High | Low | Server-side validation on every sync, flag accounts with >5% discrepancies, ban repeat offenders | Backend + Security |\n| State sync conflicts (multiple devices) | Medium | Medium | Server timestamp wins, show conflict modal to user, provide manual merge option | Engineering |\n| AsyncStorage size limits (some devices cap at 6MB) | Medium | Low | Implement state compression (gzip), archive old data, prompt user to clear old items | Engineering |\n| Complex state causing test brittleness | Medium | Medium | Use factory functions for test data, avoid mocking Zustand stores (use real stores in tests), isolate test environments | QA + Engineering |\n| Battery drain from constant animation | Low | High | Reduce particle count after 10 salvages, offer \"power saver mode\", pause animations when app backgrounded | Engineering |\n\n### Dependencies\n\n#### From PRD\n| Dependency | Technical Impact | Mitigation |\n|------------|-----------------|------------|\n| React Native Reanimated v3 compatibility | Required for 60fps animations | Verify Expo SDK 48 compatibility, budget 3 days for upgrade if needed |\n\n#### Additional Technical Dependencies\n| Dependency | Impact | Mitigation |\n|------------|--------|------------|\n| Expo EAS Build service availability | Blocks deployment | Have local build fallback, monitor Expo status page |\n| Backend API availability | Breaks cloud sync, offline mode still works | Implement retry logic, queue failed requests, show offline indicator |\n| Jest + React Native Testing Library | Required for TDD approach | Already in project, reference guide exists |\n\n## 11. Implementation Plan (TDD-Driven)\n\nFollowing `@docs/guides/lean-task-generation-guide.md` principles - prioritize user-visible functionality, no infrastructure-only tasks.\n\n### Phase 1: Manual Foundation with TDD (2 weeks)\n\n#### Week 1: Manual Salvaging\n\n**Task 1.1: Basic Manual Salvage with TDD (2 days)**\n- **Day 1**: Write failing tests\n  - Test: Tap item → item removed from inventory\n  - Test: Tap item → materials added to counter\n  - Test: Material counter shows popup animation\n- **Day 2**: Implement to pass tests\n  - Create SalvageService.salvageItem()\n  - Wire tap handler in InventoryScreen\n  - Add materials to MaterialsStore\n  - Create NumberPopup component\n\n**Task 1.2: Particle Animation System (3 days)**\n- **Day 1-2**: Write failing tests + setup\n  - Test: Particles spawn at item location\n  - Test: Particles animate to materials counter\n  - Setup Reanimated mocks for testing\n  - Create ParticleSystem test harness\n- **Day 3**: Implement particle spawner\n  - ParticlePool class\n  - Burst animation (useSharedValue, withSpring)\n  - Collection animation (withTiming to target coords)\n\n**Files Created**:\n- `/frontend/services/SalvageService.ts`\n- `/frontend/components/ParticleSystem.tsx`\n- `/frontend/components/NumberPopup.tsx`\n- Test files for each\n\n#### Week 2: Manual Tinkering\n\n**Task 1.3: Basic Tinkering with TDD (2 days)**\n- **Day 1**: Write failing tests\n  - Test: Drag materials to equipment → button appears\n  - Test: Hold button 2s → equipment level increases\n  - Test: Success rate is 100% for levels 1-10\n- **Day 2**: Implement tinkering\n  - TinkeringService class\n  - HoldToChannel button component\n  - Equipment upgrade logic\n\n**Task 1.4: Equipment Display (1 day)**\n- Write test: Equipment shows current level, power, cost\n- Implement EquipmentCard component\n- Wire to EquipmentStore\n\n**Task 1.5: Integration + Polish (2 days)**\n- Write E2E test: Complete flow (salvage → tinker → power increase)\n- Add haptic feedback\n- Add sound effects (optional)\n- Tune particle visuals\n\n**Files Created**:\n- `/frontend/services/TinkeringService.ts`\n- `/frontend/components/HoldToChannel.tsx`\n- `/frontend/components/EquipmentCard.tsx`\n- `/frontend/screens/EquipmentScreen.tsx`\n\n### Phase 2: Automation & Hybrid Gameplay (3 weeks)\n\n#### Week 3: First Automation Unlock\n\n**Task 2.1: Level 10 Automation Unlock (3 days)**\n- **Day 1**: Write failing tests\n  - Test: Reach level 10 → celebration modal appears\n  - Test: Enable assistant → items process every 3s\n  - Test: Queue shows next items\n- **Day 2-3**: Implement automation engine\n  - AutomationEngine.start() with setInterval\n  - Queue data structure (array with max 10,000)\n  - CelebrationModal component\n  - AutomationPanel UI\n\n**Task 2.2: Queue Management UI (2 days)**\n- Tests: Add/remove items, reorder queue, view status\n- Implement QueueDisplay component with FlatList\n- Drag-to-reorder with react-native-draggable-flatlist\n\n**Files Created**:\n- `/frontend/services/AutomationEngine.ts`\n- `/frontend/components/AutomationPanel.tsx`\n- `/frontend/components/QueueDisplay.tsx`\n- `/frontend/components/CelebrationModal.tsx`\n\n#### Week 4: Hybrid Manual Bonuses\n\n**Task 2.3: Manual Bonuses (2 days)**\n- Tests: Manual salvage yields 2x materials\n- Tests: 10 clicks in 5s triggers combo\n- Tests: Critical clicks (5% chance) give 5x\n- Implement bonus logic in SalvageService\n- Add combo detection (track timestamps)\n- Add \"Combo Burst!\" visual\n\n**Task 2.4: Statistics Tracking (1 day)**\n- Test: UI shows manual vs auto contribution %\n- Implement StatisticsDisplay component\n- Track counts in AutomationStore\n\n**Task 2.5: Automation Tiers (2 days)**\n- Tests: Levels 13, 15, 18, 22 unlock faster speeds\n- Implement tier unlocking system\n- Update AutomationPanel to show upgrades\n\n**Files Created**:\n- `/frontend/components/ComboDisplay.tsx`\n- `/frontend/components/StatisticsDisplay.tsx`\n- `/frontend/stores/AutomationStore.ts`\n\n#### Week 5: Filters & Priority System\n\n**Task 2.6: Salvage Filters (3 days)**\n- **Day 1**: Tests for filter rules\n  - Test: \"Auto-salvage commons\" only processes commons\n  - Test: Whitelist prevents auto-salvage of specific items\n  - Test: Filter preview shows what would be salvaged\n- **Day 2**: Implement filter engine\n  - SalvageFilter types (rarity, whitelist, duplicates)\n  - FilterEngine.applyFilters(queue, filters)\n- **Day 3**: Filter configuration UI\n  - FilterSettings modal\n  - Preview mode\n\n**Task 2.7: Tinkering Priority (2 days)**\n- Tests: Materials distribute to high-priority equipment first\n- Implement priority sorting\n- Add priority UI to EquipmentCard\n\n**Files Created**:\n- `/frontend/services/FilterEngine.ts`\n- `/frontend/components/FilterSettings.tsx`\n- `/frontend/components/FilterPreview.tsx`\n\n### Phase 3: Full Automation & Prestige (2 weeks)\n\n#### Week 6: Master Automation\n\n**Task 3.1: Level 26 Master Salvager (2 days)**\n- Tests: Processes 100 items/sec\n- Tests: Queue holds 10,000 items\n- Implement batching with RAF\n- Optimize for performance\n\n**Task 3.2: Smart Tinkering AI (3 days)**\n- **Day 1**: Tests for AI suggestions\n  - Test: AI suggests optimal distribution\n  - Test: One-click accepts suggestion\n- **Day 2-3**: Implement suggestion algorithm\n  - Analyze player patterns (which equipment gets most manual tinkers)\n  - Calculate optimal distribution based on power/cost ratio\n  - SmartTinkeringModal component\n\n**Files Created**:\n- `/frontend/services/SmartTinkeringAI.ts`\n- `/frontend/components/SmartTinkeringModal.tsx`\n\n#### Week 7: Offline & Prestige\n\n**Task 3.3: Offline Progression (3 days)**\n- **Day 1**: Tests for offline calc\n  - Test: App backgrounds → timestamp saved\n  - Test: App returns → offline rewards calculated\n  - Test: Server validation corrects client calc\n- **Day 2**: Implement OfflineProgressionService\n  - recordAppExit() on AppState change\n  - calculateOfflineRewards() on return\n  - API integration for validation\n- **Day 3**: WelcomeBackModal UI\n\n**Task 3.4: Prestige System (2 days)**\n- Tests: 1,000 salvages → prestige choice modal\n- Tests: Bonus applied correctly (1hr duration)\n- Implement PrestigeService\n- PrestigeChoiceModal component\n\n**Files Created**:\n- `/frontend/services/OfflineProgressionService.ts`\n- `/frontend/services/PrestigeService.ts`\n- `/frontend/components/WelcomeBackModal.tsx`\n- `/frontend/components/PrestigeChoiceModal.tsx`\n\n### Phase 4: Polish & Testing (1 week)\n\n#### Week 8: Integration Testing & Performance\n\n**Task 4.1: Full Integration Tests (2 days)**\n- E2E test: Phase 1 → Phase 2 → Phase 3 progression\n- E2E test: Offline for 2hrs → return → validate\n- E2E test: Prestige milestone flow\n\n**Task 4.2: Performance Optimization (2 days)**\n- Profile particle animations → optimize pool size\n- Profile queue processing → tune batch size\n- Test on low-end Android device\n- Reduce particle count if FPS <55\n\n**Task 4.3: Accessibility & Polish (1 day)**\n- Add accessibility labels\n- Test with VoiceOver/TalkBack\n- Add haptic feedback to all interactions\n- Final visual polish\n\n### Technical Milestones\n\n| Milestone | Deliverable | Date | Dependencies |\n|-----------|------------|------|--------------|\n| M1 | Manual salvage + tinkering working | End Week 2 | Reanimated setup, test framework |\n| M2 | First automation unlock functional | End Week 3 | M1 complete, level progression |\n| M3 | Hybrid gameplay with bonuses | End Week 4 | M2 complete |\n| M4 | Complete automation with filters | End Week 5 | M3 complete |\n| M5 | Offline progression + prestige | End Week 7 | M4 complete, backend API ready |\n| M6 | Performance targets met, tests passing | End Week 8 | All features complete |\n\n## 12. Decision Log\n\n### Architecture Decisions\n\n| Decision | Options Considered | Choice | Rationale |\n|----------|-------------------|--------|-----------|\n| State Management | Redux, MobX, Zustand, Context API | **Zustand** | Lightweight (1KB), simple API, no boilerplate, already familiar to team, excellent TypeScript support |\n| Animation Library | React Native Animated, Reanimated v2, Reanimated v3, Lottie | **Reanimated v3** | Runs on UI thread (60fps capable), best performance for particle effects, active development, Expo compatible |\n| Queue Data Structure | Array, Linked List, Ring Buffer | **Array with splice** | Simplest implementation, max 10,000 items is small enough for O(n) operations, easier to serialize for persistence |\n| Offline Storage | AsyncStorage, SQLite, Realm | **AsyncStorage** | Already in project, sufficient for <10MB game state, simpler API, no migration complexity |\n| Testing Strategy | Unit only, E2E only, Full TDD | **Full TDD with RNTL** | Enforces quality, catches regressions early, aligns with project guide, builds confidence for refactoring |\n| Backend Stack | REST, GraphQL, gRPC | **REST** | Existing backend is REST, simpler for CRUD operations, easier to mock in tests, sufficient for sync operations |\n\n### Trade-offs\n\n#### Trade-off 1: Client-side RNG vs Server-side RNG\n- **Chose**: Client-side RNG with server validation\n- **Over**: Server-side authoritative RNG for every salvage\n- **Because**: Instant client feedback is critical for engagement, server validates material balances on sync (every 30s), acceptable risk for cheat detection\n\n#### Trade-off 2: Particle Animation Complexity\n- **Chose**: Simple particle pool with basic physics\n- **Over**: Complex particle system with collisions, trails, etc.\n- **Because**: 60fps target is strict, battery life concerns, diminishing returns on visual complexity, can enhance later if performance allows\n\n#### Trade-off 3: Queue Size Limit\n- **Chose**: Hard cap at 10,000 items\n- **Over**: Unlimited queue or pagination\n- **Because**: Prevents memory issues, forces player engagement (empty queue), 10,000 items = 100 seconds at max speed (sufficient buffer), simplifies UI\n\n#### Trade-off 4: Offline Progression Cap\n- **Chose**: 4-hour maximum accumulation\n- **Over**: Unlimited offline gains\n- **Because**: Prevents extreme imbalances, encourages daily engagement, aligns with idle game best practices, reduces server validation complexity\n\n## 13. Open Questions\n\nTechnical questions requiring resolution:\n\n- [ ] **Animation Performance**: Can we achieve 60fps with 30 particles per salvage on iPhone X (A11 chip)? Need prototype by end of Week 1.\n- [ ] **Queue Persistence**: Should queue state persist across app restarts, or rebuild from inventory on launch? (Persistence = more complexity, rebuild = potential UX hiccup)\n- [ ] **Combo Detection**: Should combo timer reset on any gap >1s, or allow small gaps? Need UX feedback.\n- [ ] **Material Counter Display**: At what point do we switch to scientific notation? (1,000? 1,000,000?)\n- [ ] **Backend Sync Frequency**: Is 30s sync sufficient, or should we sync every state change (with debouncing)? Trade-off: server load vs data freshness.\n- [ ] **Prestige Bonus Stacking**: Can multiple prestige bonuses be active simultaneously, or only one at a time? Affects game balance.\n- [ ] **Filter Rule Conflicts**: If user sets \"auto-salvage commons\" but also \"whitelist Item X\" (a common), which wins? Need clear precedence.\n- [ ] **Offline Validation Handling**: If server offline calc differs by >2%, do we show modal to user or silently accept server value?\n\n## 14. Appendices\n\n### A. Technical Glossary\n\n| Term | Definition |\n|------|------------|\n| **RAF (requestAnimationFrame)** | Browser/React Native API for 60fps rendering loop, used for batching queue processing |\n| **Zustand Store** | Lightweight state management library, stores are created with `create()` and accessed via hooks |\n| **Reanimated Shared Value** | useSharedValue() creates values that run on UI thread for 60fps animations |\n| **Particle Pool** | Pre-allocated array of particle objects to avoid allocation overhead during animations |\n| **Batching** | Processing multiple items in single operation to reduce overhead (e.g., 10 salvages in 1 store update) |\n| **Virtual Scrolling** | FlatList technique that only renders visible items, enabling 100k+ item lists |\n| **Server Reconciliation** | Process where server validates client state and corrects discrepancies |\n| **TDD Red-Green-Refactor** | Write failing test (RED) → implement minimal code (GREEN) → improve code quality (REFACTOR) |\n| **MSW (Mock Service Worker)** | Tool for mocking API requests in tests using service worker pattern |\n\n### B. Reference Architecture\n\n- **Idle Game Pattern**: Cookie Clicker, Adventure Capitalist (manual → automation progression)\n- **Hybrid Engagement**: Melvor Idle, NGU Idle (manual actions remain valuable at max automation)\n- **React Native State**: Zustand examples from project `/frontend/stores/`\n- **Animation Performance**: Reanimated v3 best practices (use worklets, avoid bridge crossing)\n\n### C. Proof of Concepts\n\n#### POC 1: Particle Performance (Week 1)\nCreate isolated test app:\n- Spawn 30 particles every 0.5s (60 particles/second burst)\n- Measure FPS with React DevTools Profiler\n- Test on: iPhone X, Samsung Galaxy S10, Pixel 4\n- **Success Criteria**: >55fps average during 10-second burst\n\n#### POC 2: Queue Processing at 100/sec (Week 3)\nCreate isolated test:\n- Queue of 10,000 items\n- Process 100 items/sec using RAF batching\n- Measure: CPU usage, memory, UI responsiveness\n- **Success Criteria**: <10% CPU, <20MB memory increase, UI remains interactive\n\n### D. Related Documents\n\n- **Product Requirements Document**: `/docs/specs/salvage-tinkering-system/prd_salvage_tinkering_progressive_automation_20251024.md`\n- **Lean Task Generation Guide**: `/docs/guides/lean-task-generation-guide.md`\n- **React Native Testing Library Guide**: `/docs/research/react_native_testing_library_guide_20250918_184418.md`\n- **Project CLAUDE.md**: `/CLAUDE.md` (Expo + React Native setup, rules)\n\n---\n\n**Generated from PRD**: `prd_salvage_tinkering_progressive_automation_20251024.md`\n**Generation Date**: 2025-10-24\n**Next Review**: 2025-11-07 (2 weeks post-creation)\n**Approval Required From**: Engineering Lead, QA Lead, Product Lead\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":124,"cache_read_input_tokens":50781,"cache_creation":{"ephemeral_5m_input_tokens":124,"ephemeral_1h_input_tokens":0},"output_tokens":16356,"service_tier":"standard"}},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"58939322-c14e-4057-8d20-e44761196d40"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Claude requested permissions to write to /mnt/c/dev/class-one-rapids/docs/specs/salvage-tinkering-system/tdd_salvage_tinkering_progressive_automation_20251024.md, but you haven't granted it yet.","is_error":true,"tool_use_id":"toolu_01N7g3zi94nyx3KiiR6Eg3WU"}]},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"5cf04c60-80ce-43a4-801e-d9d6bdcef7ed"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01GCoaHhQ87jr1YNgeC1KRyo","type":"message","role":"assistant","content":[{"type":"text","text":"I've generated a comprehensive Technical Design Document for the Salvage & Tinkering Progressive Automation System. The document includes:\n\n## Key Highlights:\n\n### **Complete Technical Architecture**\n- System architecture with React Native + Zustand + Reanimated v3\n- 6 core components (SalvageService, AutomationEngine, TinkeringService, ParticleSystem, OfflineProgressionService, PrestigeService)\n- Detailed data models and API designs\n\n### **TDD-First Implementation Strategy**\n- Strict Red-Green-Refactor cycles for all features\n- Comprehensive test examples using React Native Testing Library\n- Test categories: Unit (85% coverage target) → Integration (75%) → E2E\n- Real test code examples for manual salvage, automation, and offline progression\n\n### **8-Week Implementation Plan**\nFollowing lean task generation principles (no infrastructure-only tasks):\n- **Week 1-2**: Manual salvaging + tinkering (user-visible features first)\n- **Week 3-5**: Automation progression (Level 10 → 26)\n- **Week 6-7**: Full automation + offline + prestige\n- **Week 8**: Integration testing + performance optimization\n\n### **Performance & Security**\n- 60fps animation targets with Reanimated particle pooling\n- 100 items/second processing at Level 26 using RAF batching\n- Server validation for offline progression (±2% accuracy)\n- Rate limiting and anti-cheat measures\n\n### **Technical Decisions Documented**\n- Zustand for state (lightweight, simple)\n- Reanimated v3 for animations (UI thread, 60fps capable)\n- AsyncStorage for persistence (sufficient for <10MB game state)\n- Client-side RNG with server reconciliation (instant feedback)\n\nThe TDD is ready to save to `/docs/specs/salvage-tinkering-system/tdd_salvage_tinkering_progressive_automation_20251024.md`\n\nWould you like me to save this document?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":16348,"cache_read_input_tokens":50905,"cache_creation":{"ephemeral_5m_input_tokens":16348,"ephemeral_1h_input_tokens":0},"output_tokens":467,"service_tier":"standard"}},"parent_tool_use_id":null,"session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","uuid":"0797fd27-af45-4da0-84d8-e627817f4d70"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":328027,"duration_api_ms":330334,"num_turns":11,"result":"I've generated a comprehensive Technical Design Document for the Salvage & Tinkering Progressive Automation System. The document includes:\n\n## Key Highlights:\n\n### **Complete Technical Architecture**\n- System architecture with React Native + Zustand + Reanimated v3\n- 6 core components (SalvageService, AutomationEngine, TinkeringService, ParticleSystem, OfflineProgressionService, PrestigeService)\n- Detailed data models and API designs\n\n### **TDD-First Implementation Strategy**\n- Strict Red-Green-Refactor cycles for all features\n- Comprehensive test examples using React Native Testing Library\n- Test categories: Unit (85% coverage target) → Integration (75%) → E2E\n- Real test code examples for manual salvage, automation, and offline progression\n\n### **8-Week Implementation Plan**\nFollowing lean task generation principles (no infrastructure-only tasks):\n- **Week 1-2**: Manual salvaging + tinkering (user-visible features first)\n- **Week 3-5**: Automation progression (Level 10 → 26)\n- **Week 6-7**: Full automation + offline + prestige\n- **Week 8**: Integration testing + performance optimization\n\n### **Performance & Security**\n- 60fps animation targets with Reanimated particle pooling\n- 100 items/second processing at Level 26 using RAF batching\n- Server validation for offline progression (±2% accuracy)\n- Rate limiting and anti-cheat measures\n\n### **Technical Decisions Documented**\n- Zustand for state (lightweight, simple)\n- Reanimated v3 for animations (UI thread, 60fps capable)\n- AsyncStorage for persistence (sufficient for <10MB game state)\n- Client-side RNG with server reconciliation (instant feedback)\n\nThe TDD is ready to save to `/docs/specs/salvage-tinkering-system/tdd_salvage_tinkering_progressive_automation_20251024.md`\n\nWould you like me to save this document?","session_id":"c937a7b6-9120-459a-aae7-eca5c232071c","total_cost_usd":0.49828005,"usage":{"input_tokens":22,"cache_creation_input_tokens":50985,"cache_read_input_tokens":164171,"output_tokens":17026,"server_tool_use":{"web_search_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":50985}},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":1349,"outputTokens":206,"cacheReadInputTokens":0,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.002379,"contextWindow":200000},"claude-sonnet-4-5-20250929":{"inputTokens":22,"outputTokens":17026,"cacheReadInputTokens":164171,"cacheCreationInputTokens":50985,"webSearchRequests":0,"costUSD":0.49590104999999995,"contextWindow":200000}},"permission_denials":[{"tool_name":"Write","tool_use_id":"toolu_01N7g3zi94nyx3KiiR6Eg3WU","tool_input":{"file_path":"/mnt/c/dev/class-one-rapids/docs/specs/salvage-tinkering-system/tdd_salvage_tinkering_progressive_automation_20251024.md","content":"# Salvage & Tinkering Progressive Automation - Technical Design Document\n\n## Document Control\n| Version | Author | Date | Status | Changes |\n|---------|--------|------|--------|---------|\n| v1.0 | Generated from PRD | 2025-10-24 | Draft | Initial TDD from PRD v1.0 |\n\n## Executive Summary\nThis Technical Design Document defines the implementation architecture for a three-phase progressive automation system that transforms manual item salvaging and equipment tinkering into an automated idle game mechanic. The system leverages React Native with Zustand for state management, React Native Reanimated v3 for 60fps animations, and a Test-Driven Development approach to ensure each progression phase (Manual → Hybrid → Automation) delivers measurable engagement improvements while maintaining <3s app launch times and processing up to 100 items/second.\n\n## 1. Overview & Context\n\n### Problem Statement\nFrom a technical perspective, implementing idle game automation presents three core challenges:\n1. **Animation Performance**: Maintaining 60fps particle effects while processing 1-100 items/second on mid-range devices\n2. **State Synchronization**: Managing offline progression calculations with server validation while providing instant client-side feedback\n3. **Progression Calibration**: Dynamically adjusting automation unlock timing based on actual player behavior without hardcoded assumptions\n\n### Solution Approach\nWe implement a modular component architecture where:\n- **Phase 1 (Manual)**: Direct user interactions trigger immediate state updates with reanimated particle animations, teaching system mechanics through tactile feedback\n- **Phase 2 (Hybrid)**: Introduction of background workers using setInterval with configurable speeds, maintaining manual bonuses through dual code paths (manual vs automated)\n- **Phase 3 (Automation)**: Queue-based processing system with rule engine for filters, prestige calculation service, and offline accumulation with server reconciliation\n\n### Success Criteria\nTechnical metrics aligned with PRD business goals:\n- Animation frame rate: >55fps average during salvage bursts (60 items in 10 seconds)\n- State update latency: <16ms from user tap to UI feedback\n- Queue processing efficiency: 100 items/second with <10% CPU usage\n- Offline calculation accuracy: ±2% of server-calculated values\n- Test coverage: >80% for all new components\n- App bundle size increase: <5MB for complete feature\n\n## 2. Requirements Analysis\n\n### Functional Requirements\n\n#### FR1: Manual Salvaging (Phase 1)\n- **User Action**: Tap item → 0.5s animation → material burst → auto-collect at 0.5s\n- **Technical Need**: Event-driven animation system, particle spawner, material inventory state management\n- **Acceptance**: 60fps animations, <50ms tap-to-feedback latency\n\n#### FR2: Manual Tinkering (Phase 1)\n- **User Action**: Drag materials → hold 2s button → success animation → stat increase\n- **Technical Need**: Gesture recognizer, hold-to-activate component, equipment state store\n- **Acceptance**: 100% success rate for levels 1-10, visual progress circle during channel\n\n#### FR3: Automation Progression (Levels 10-26)\n- **User Action**: Unlock automation tiers → configure settings → view queue status\n- **Technical Need**: Unlock state machine, configurable interval workers, queue management system\n- **Acceptance**: 6 automation tiers with speeds: 3s, 2s, 1s, 0.33s, 0.1s, 0.01s per item\n\n#### FR4: Hybrid Manual Bonuses (Phase 2)\n- **User Action**: Manual clicks yield 2x materials, combos, critical hits\n- **Technical Need**: Dual calculation paths, combo detection (10 clicks in 5s), RNG for crits (5%)\n- **Acceptance**: Statistics tracking manual vs auto contribution\n\n#### FR5: Automation Controls (Phase 2-3)\n- **User Action**: Set filters, priorities, queue management\n- **Technical Need**: Rule engine for filters, priority sorting algorithm, queue data structure\n- **Acceptance**: Filter preview before enable, drag-to-reorder queue\n\n#### FR6: Offline Progression (Level 26+)\n- **User Action**: Close app → reopen → receive accumulated resources\n- **Technical Need**: Timestamp tracking, rate calculation, server validation service\n- **Acceptance**: 4-hour max accumulation, ±2% accuracy vs server\n\n#### FR7: Prestige System (Level 35+)\n- **User Action**: Reach milestone → choose bonus → apply temporary multiplier\n- **Technical Need**: Milestone counter, bonus selection modal, temporary effect timer\n- **Acceptance**: 3-choice system, 1-hour effect duration tracking\n\n### Non-Functional Requirements\n\n#### NFR1: Performance\n- **Animation Frame Rate**: 60fps target, >55fps acceptable during particle bursts\n- **Processing Throughput**: 100 items/second at Level 26 without UI stutter\n- **Queue Operations**: Add/remove/reorder in <50ms\n- **App Launch**: <3 seconds to interactive state on 4G (Expo requirement)\n- **Memory Footprint**: <50MB increase for feature (particle textures, queue data)\n\n#### NFR2: Scalability\n- **Inventory Size**: Support 100,000+ items with FlatList virtualization\n- **Material Counters**: Number.MAX_SAFE_INTEGER (9 quadrillion) with scientific notation\n- **Automation Processing**: O(1) performance from 1/sec to 100/sec using batch processing\n- **State Store Size**: <10MB for full game state with compression\n\n#### NFR3: Security\n- **Client Validation**: All salvage/tinker operations validated locally for instant feedback\n- **Server Authority**: Material balances reconciled server-side every 30s\n- **Rate Limiting**: Max 10 manual clicks/second to prevent automation exploits\n- **Offline Validation**: Server recalculates offline progression on reconnect, client shows estimate\n\n#### NFR4: Accessibility\n- **Color + Shape**: Materials have distinct shapes (circle, square, diamond, star) for colorblind users\n- **Haptics**: Expo Haptics feedback on tap, hold, success events\n- **Screen Readers**: All buttons/counters have accessibilityLabel props\n- **Touch Targets**: Minimum 44x44pt per iOS Human Interface Guidelines\n\n#### NFR5: Platform Support\n- **iOS**: 14+ (React Native 0.70+ compatibility)\n- **Android**: API 26+ (Android 8.0)\n- **Offline-First**: AsyncStorage for local state, background sync\n- **Cloud Save**: Sync to backend every 5 minutes or on app background\n\n## 3. System Architecture\n\n### High-Level Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     React Native App                         │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              Presentation Layer                       │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │  Inventory  │ │  Equipment   │ │  Automation  │  │  │\n│  │  │  Screen     │ │  Screen      │ │  Dashboard   │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  └───────────────────────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              State Management (Zustand)               │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │ Inventory   │ │  Materials   │ │  Automation  │  │  │\n│  │  │   Store     │ │    Store     │ │    Store     │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │ Equipment   │ │   Player     │ │   Prestige   │  │  │\n│  │  │   Store     │ │    Store     │ │    Store     │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  └───────────────────────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              Business Logic Layer                     │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │  Salvage    │ │  Tinkering   │ │  Automation  │  │  │\n│  │  │  Service    │ │  Service     │ │  Engine      │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │  Material   │ │  Offline     │ │  Prestige    │  │  │\n│  │  │  Calculator │ │  Progression │ │  Service     │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  └───────────────────────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              Animation Layer                          │  │\n│  │  ┌─────────────┐ ┌──────────────┐ ┌──────────────┐  │  │\n│  │  │  Particle   │ │  Number      │ │  Equipment   │  │  │\n│  │  │  System     │ │  Popup       │ │  Glow        │  │  │\n│  │  └─────────────┘ └──────────────┘ └──────────────┘  │  │\n│  └───────────────────────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │              Persistence Layer                        │  │\n│  │  ┌─────────────┐ ┌──────────────┐                    │  │\n│  │  │ AsyncStorage│ │  API Client  │                    │  │\n│  │  │  (Local)    │ │  (Backend)   │                    │  │\n│  │  └─────────────┘ └──────────────┘                    │  │\n│  └───────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Component Design\n\n#### Component 1: SalvageService\n- **Purpose**: Orchestrates salvaging operations for both manual and automated flows\n- **Responsibilities**:\n  - Process manual salvage with instant feedback\n  - Calculate materials with rarity RNG\n  - Trigger particle animations\n  - Apply manual bonuses (2x, combo, critical)\n  - Track statistics (manual vs auto counts)\n- **Interfaces**:\n  ```typescript\n  interface SalvageService {\n    salvageItem(itemId: string, isManual: boolean): SalvageResult;\n    salvageBatch(itemIds: string[], isManual: false): SalvageResult[];\n    calculateMaterials(item: Item, bonusMultiplier: number): Material[];\n    checkCritical(): boolean; // 5% chance\n  }\n  ```\n- **Dependencies**: MaterialsStore, InventoryStore, ParticleSystem\n\n#### Component 2: AutomationEngine\n- **Purpose**: Manages automation workers at different progression levels\n- **Responsibilities**:\n  - Start/stop automation workers based on unlock level\n  - Process queue at configured speeds (3s → 0.01s per item)\n  - Apply filters and rules before processing\n  - Maintain queue data structure (max 10,000 items)\n  - Emit events for UI updates\n- **Interfaces**:\n  ```typescript\n  interface AutomationEngine {\n    start(level: AutomationLevel): void;\n    stop(): void;\n    addToQueue(items: Item[]): void;\n    removeFromQueue(itemId: string): void;\n    reorderQueue(fromIndex: number, toIndex: number): void;\n    setFilters(filters: SalvageFilter[]): void;\n    getQueueStatus(): QueueStatus;\n  }\n  ```\n- **Dependencies**: SalvageService, InventoryStore, AutomationStore\n\n#### Component 3: TinkeringService\n- **Purpose**: Handles equipment upgrades with materials\n- **Responsibilities**:\n  - Validate material requirements\n  - Calculate success rate (100% for Phase 1, variable later)\n  - Apply upgrades to equipment\n  - Calculate power level increases\n  - Handle manual vs auto tinkering cost difference (50% reduction manual)\n- **Interfaces**:\n  ```typescript\n  interface TinkeringService {\n    tinkerEquipment(equipmentId: string, isManual: boolean): TinkerResult;\n    calculateCost(equipment: Equipment, isManual: boolean): MaterialCost;\n    calculateSuccessRate(playerLevel: number): number;\n    applyUpgrade(equipment: Equipment, bonusLevel: number): Equipment;\n  }\n  ```\n- **Dependencies**: MaterialsStore, EquipmentStore, PlayerStore\n\n#### Component 4: ParticleSystem\n- **Purpose**: Renders high-performance particle animations using Reanimated\n- **Responsibilities**:\n  - Spawn particles on salvage (10-30 particles per salvage)\n  - Color-code particles by rarity\n  - Animate particle trajectories (burst → collect)\n  - Pool particle objects for performance (max 300 active)\n  - Maintain 60fps during multi-salvage bursts\n- **Interfaces**:\n  ```typescript\n  interface ParticleSystem {\n    spawnParticles(x: number, y: number, material: Material, count: number): void;\n    animateCollection(particles: Particle[], targetX: number, targetY: number): void;\n    clearParticles(): void;\n    setPoolSize(size: number): void;\n  }\n  ```\n- **Dependencies**: react-native-reanimated, MaterialsStore (for target coordinates)\n\n#### Component 5: OfflineProgressionService\n- **Purpose**: Calculates and validates offline resource accumulation\n- **Responsibilities**:\n  - Store exit timestamp when app backgrounds\n  - Calculate elapsed time on return (capped at 4 hours)\n  - Compute materials based on automation rates at exit\n  - Request server validation\n  - Show welcome-back modal with results\n- **Interfaces**:\n  ```typescript\n  interface OfflineProgressionService {\n    recordAppExit(): Promise<void>;\n    calculateOfflineRewards(): OfflineRewards;\n    validateWithServer(clientCalculation: OfflineRewards): Promise<OfflineRewards>;\n    applyOfflineRewards(rewards: OfflineRewards): void;\n  }\n  ```\n- **Dependencies**: AutomationStore, MaterialsStore, API Client\n\n#### Component 6: PrestigeService\n- **Purpose**: Manages prestige milestones and bonus selection\n- **Responsibilities**:\n  - Track salvage count toward 1,000-item milestones\n  - Trigger prestige choice modal\n  - Apply temporary bonuses (1hr +10% materials, etc.)\n  - Maintain bonus timers\n  - Calculate prestige point accumulation\n- **Interfaces**:\n  ```typescript\n  interface PrestigeService {\n    checkMilestone(): boolean;\n    applyPrestigeBonus(choice: PrestigeChoice): void;\n    getActiveBonus(): PrestigeBonus | null;\n    calculatePrestigePoints(totalSalvages: number): number;\n  }\n  ```\n- **Dependencies**: MaterialsStore, PrestigeStore, PlayerStore\n\n### Data Flow\n\n#### Critical Flow 1: Manual Salvage\n```\nUser taps item\n  ↓\n[InventoryScreen] onPress handler\n  ↓\n[SalvageService] salvageItem(itemId, isManual=true)\n  ↓\n[MaterialCalculator] calculateMaterials(item, 2x multiplier)\n  ↓\n[ParticleSystem] spawnParticles(x, y, materials, count)\n  ↓ (parallel)\n[MaterialsStore] addMaterials(materials)\n  ↓\n[ParticleSystem] animateCollection(particles, targetCoords)\n  ↓ (0.5s delay)\n[MaterialsStore] triggers UI update → number popup animation\n  ↓\n[InventoryStore] removeItem(itemId)\n```\n\n#### Critical Flow 2: Automation Processing\n```\n[AutomationEngine] interval tick (speed based on level)\n  ↓\n[AutomationEngine] getNextItemFromQueue()\n  ↓\n[AutomationEngine] applyFilters(item) → allow/skip\n  ↓\n[SalvageService] salvageItem(itemId, isManual=false)\n  ↓\n[MaterialCalculator] calculateMaterials(item, 1x multiplier)\n  ↓\n[MaterialsStore] addMaterials(materials) → NO particle animation\n  ↓\n[AutomationEngine] updateQueueStatus() → UI shows progress\n```\n\n#### Critical Flow 3: Offline Progression\n```\nApp moves to background\n  ↓\n[OfflineProgressionService] recordAppExit()\n  ↓\n[AsyncStorage] save { exitTime, automationRate, queueSize }\n  ↓\nApp returns to foreground\n  ↓\n[OfflineProgressionService] calculateOfflineRewards()\n  ↓\nCalculate: min(elapsed, 4hrs) × automationRate → materials\n  ↓ (parallel)\n[OfflineProgressionService] validateWithServer(clientCalc)\n  ↓\n[API Client] POST /offline-validate → server recalculates\n  ↓\nUse server result if different by >2%\n  ↓\n[MaterialsStore] addMaterials(offlineRewards)\n  ↓\n[WelcomeBackModal] show summary\n```\n\n## 4. API Design\n\n### Internal APIs\n\n#### Salvage Module\n| Function | Purpose | Input | Output |\n|----------|---------|-------|--------|\n| `salvageItem(itemId, isManual)` | Process single item salvage | itemId: string, isManual: boolean | SalvageResult: { materials: Material[], isCritical: boolean } |\n| `salvageBatch(itemIds)` | Process multiple items (automation) | itemIds: string[] | SalvageResult[] |\n| `calculateMaterials(item, multiplier)` | Determine materials from item | item: Item, multiplier: number | Material[] |\n\n#### Automation Module\n| Function | Purpose | Input | Output |\n|----------|---------|-------|--------|\n| `startAutomation(level)` | Begin automation at tier | level: 10\\|13\\|15\\|18\\|22\\|26 | void |\n| `setSpeed(itemsPerSecond)` | Configure processing rate | itemsPerSecond: number | void |\n| `addFilter(filter)` | Add automation filter | filter: SalvageFilter | void |\n| `getQueue()` | Retrieve current queue | none | QueueItem[] |\n\n#### Tinkering Module\n| Function | Purpose | Input | Output |\n|----------|---------|-------|--------|\n| `tinker(equipId, isManual)` | Upgrade equipment | equipId: string, isManual: boolean | TinkerResult: { success: boolean, newLevel: number } |\n| `getCost(equipId, isManual)` | Calculate material cost | equipId: string, isManual: boolean | MaterialCost |\n| `setPriority(equipId, priority)` | Set auto-tinker priority | equipId: string, priority: 1-5 | void |\n\n### External Integrations\n\n#### Backend API Endpoints\n| Endpoint | Method | Purpose | Request | Response |\n|----------|--------|---------|---------|----------|\n| `/api/player/state` | GET | Fetch player state | Auth token | PlayerState (inventory, materials, equipment) |\n| `/api/player/state` | POST | Save player state | PlayerState | { success: boolean, timestamp: number } |\n| `/api/offline/validate` | POST | Validate offline calc | { exitTime, returnTime, clientMaterials } | { validatedMaterials: Material[], serverTimestamp: number } |\n| `/api/prestige/record` | POST | Record prestige milestone | { salvageCount, choiceId } | { prestigePoints: number } |\n\n## 5. Data Model\n\n### Entity Design\n\n#### Item Entity\n```typescript\ninterface Item {\n  id: string;\n  name: string;\n  rarity: 'common' | 'rare' | 'epic' | 'legendary';\n  salvageValue: number; // Base material multiplier\n  iconUrl: string;\n  acquiredAt: number; // Timestamp\n}\n```\n\n#### Material Entity\n```typescript\ninterface Material {\n  type: 'common' | 'rare' | 'epic' | 'legendary';\n  amount: number;\n  shape: 'circle' | 'square' | 'diamond' | 'star'; // For accessibility\n  color: string; // Hex color\n}\n```\n\n#### Equipment Entity\n```typescript\ninterface Equipment {\n  id: string;\n  slot: 'weapon' | 'armor' | 'accessory';\n  level: number; // Upgrade level\n  powerLevel: number; // Calculated stat\n  tinkerCost: MaterialCost; // Current upgrade cost\n  autoPriority: number; // 1-5, for auto-tinker\n}\n```\n\n#### AutomationState Entity\n```typescript\ninterface AutomationState {\n  isActive: boolean;\n  currentLevel: 10 | 13 | 15 | 18 | 22 | 26;\n  itemsPerSecond: number;\n  queue: QueueItem[];\n  filters: SalvageFilter[];\n  statistics: {\n    totalProcessed: number;\n    manualCount: number;\n    autoCount: number;\n    manualMaterials: number;\n    autoMaterials: number;\n  };\n}\n```\n\n#### PrestigeState Entity\n```typescript\ninterface PrestigeState {\n  totalSalvages: number;\n  nextMilestone: number; // Next 1000 mark\n  prestigePoints: number;\n  activeBonus: {\n    type: 'material_boost' | 'guaranteed_rare' | 'tinker_speed';\n    multiplier: number;\n    expiresAt: number; // Timestamp\n  } | null;\n  milestoneHistory: PrestigeChoice[];\n}\n```\n\n### Database Schema\n\n#### AsyncStorage Keys (Local)\n```\nplayer_state: PlayerState (JSON)\ninventory_items: Item[] (JSON)\nmaterials: { [type]: amount } (JSON)\nequipment: Equipment[] (JSON)\nautomation_state: AutomationState (JSON)\nprestige_state: PrestigeState (JSON)\noffline_exit_timestamp: number\noffline_automation_rate: number\n```\n\n#### Backend Schema (Conceptual)\n```sql\n-- Players table\nCREATE TABLE players (\n  id UUID PRIMARY KEY,\n  username VARCHAR(255),\n  level INTEGER,\n  created_at TIMESTAMP,\n  last_sync TIMESTAMP\n);\n\n-- Player inventory\nCREATE TABLE player_inventory (\n  player_id UUID REFERENCES players(id),\n  item_id UUID,\n  acquired_at TIMESTAMP,\n  PRIMARY KEY (player_id, item_id)\n);\nCREATE INDEX idx_player_inventory ON player_inventory(player_id);\n\n-- Player materials\nCREATE TABLE player_materials (\n  player_id UUID REFERENCES players(id),\n  material_type VARCHAR(50),\n  amount BIGINT,\n  PRIMARY KEY (player_id, material_type)\n);\n\n-- Player equipment\nCREATE TABLE player_equipment (\n  player_id UUID REFERENCES players(id),\n  equipment_id UUID,\n  level INTEGER,\n  power_level INTEGER,\n  PRIMARY KEY (player_id, equipment_id)\n);\n\n-- Offline progression logs\nCREATE TABLE offline_progression_log (\n  player_id UUID REFERENCES players(id),\n  exit_timestamp TIMESTAMP,\n  return_timestamp TIMESTAMP,\n  client_materials JSONB,\n  server_materials JSONB,\n  logged_at TIMESTAMP\n);\nCREATE INDEX idx_offline_log ON offline_progression_log(player_id, logged_at);\n```\n\n### Data Access Patterns\n\n#### Common Queries\n1. **Load Player State**: Read all AsyncStorage keys on app launch → hydrate Zustand stores\n2. **Save Player State**: Debounced write to AsyncStorage every 5s during active play\n3. **Sync to Backend**: POST to `/api/player/state` every 5 minutes or on app background\n4. **Queue Operations**: Array operations (push, splice, swap) on in-memory queue (max 10,000)\n\n#### Caching Strategy\n- **Local First**: All game state lives in Zustand stores (in-memory)\n- **AsyncStorage**: Persistent cache synced every 5s\n- **Backend**: Source of truth, synced every 5min + on app close\n- **Conflict Resolution**: Server timestamp wins on conflicts\n\n#### Data Consistency\n- **Optimistic Updates**: UI updates immediately on user actions\n- **Server Reconciliation**: Backend validates on sync, client accepts server corrections\n- **Offline Queue**: Actions queued locally, replayed to server on reconnect\n\n## 6. Security Design\n\n### Authentication & Authorization\n- **Authentication**: JWT tokens issued by backend auth service (not part of this feature)\n- **Authorization**: Player can only modify their own inventory/materials (enforced server-side)\n- **Session Management**: JWT stored in SecureStore (Expo), 7-day expiry with refresh\n\n### Data Security\n- **Encryption at Rest**: AsyncStorage data not encrypted (game state, not PII)\n- **Encryption in Transit**: All API calls over HTTPS/TLS 1.3\n- **PII Handling**: No PII in salvage/tinkering data (player ID only)\n- **Audit Logging**: Server logs all state changes with timestamps for anti-cheat\n\n### Security Controls\n\n#### Input Validation\n```typescript\n// Client-side validation (instant feedback)\nfunction validateSalvage(itemId: string): boolean {\n  const item = inventoryStore.getItem(itemId);\n  if (!item) return false; // Item doesn't exist\n  if (item.salvageValue <= 0) return false; // Invalid item\n  return true;\n}\n\n// Server-side validation (authority)\nfunction validateSalvageServer(playerId: string, itemId: string): boolean {\n  // Check player owns item\n  // Check item not already salvaged\n  // Check timestamps for rate limiting\n  return true;\n}\n```\n\n#### Rate Limiting\n- **Client**: Max 10 manual salvages/second (enforced by debouncing tap handler)\n- **Server**: Max 100 salvages/minute per player (prevents automation bots)\n- **Automation**: Server validates automation rate matches player's unlock level\n\n#### Anti-Cheat Measures\n- **Material Balance Checks**: Server recalculates expected materials based on logged salvages\n- **Offline Progression Validation**: Server independently calculates offline rewards, flags >5% discrepancies\n- **Queue Integrity**: Server validates queue operations against player's inventory state\n\n## 7. Test-Driven Development (TDD) Strategy\n\n### TDD Approach (MANDATORY)\nAll implementation follows strict Red-Green-Refactor cycle using React Native Testing Library.\n\n### Testing Framework & Tools\n- **Framework**: React Native Testing Library + Jest\n- **Reference**: `/docs/research/react_native_testing_library_guide_20250918_184418.md`\n- **Test Runner**: Jest with React Native preset (already configured in project)\n- **Mocking**:\n  - API calls: MSW (Mock Service Worker)\n  - Animations: Mock `react-native-reanimated` with `reanimated-jest`\n  - AsyncStorage: `@react-native-async-storage/async-storage/jest/async-storage-mock`\n  - Timers: Jest fake timers for interval testing\n\n### TDD Implementation Process\n\n#### RED Phase Example: Manual Salvage\n```typescript\n// SalvageService.test.ts\nimport { render, fireEvent, screen, waitFor } from '@testing-library/react-native';\nimport { InventoryScreen } from '../screens/InventoryScreen';\nimport { setupTestStores } from '../test-utils/storeSetup';\n\ndescribe('Manual Salvage', () => {\n  beforeEach(() => {\n    setupTestStores({\n      inventory: [{ id: 'item1', name: 'Rusty Sword', rarity: 'common' }],\n      materials: { common: 0 }\n    });\n  });\n\n  test('should salvage item and add materials on tap', async () => {\n    render(<InventoryScreen />);\n\n    // Arrange\n    const item = screen.getByText('Rusty Sword');\n    expect(screen.getByText('Common: 0')).toBeTruthy();\n\n    // Act\n    fireEvent.press(item);\n\n    // Assert\n    await waitFor(() => {\n      expect(screen.queryByText('Rusty Sword')).toBeNull(); // Item removed\n      expect(screen.getByText(/Common: 1[0-9]/)).toBeTruthy(); // Materials added (10-15 range)\n    }, { timeout: 1000 });\n  });\n\n  test('should apply 2x multiplier for manual salvage', async () => {\n    render(<InventoryScreen />);\n\n    const item = screen.getByText('Rusty Sword');\n    fireEvent.press(item);\n\n    await waitFor(() => {\n      // Base salvage = 10 common, manual = 2x = 20 common\n      expect(screen.getByText('Common: 20')).toBeTruthy();\n    });\n  });\n\n  test('should trigger combo after 10 clicks in 5 seconds', async () => {\n    const { inventory } = setupTestStores({\n      inventory: Array(15).fill(null).map((_, i) => ({\n        id: `item${i}`, name: `Item ${i}`, rarity: 'common'\n      }))\n    });\n\n    render(<InventoryScreen />);\n\n    // Click 10 items rapidly\n    for (let i = 0; i < 10; i++) {\n      fireEvent.press(screen.getByText(`Item ${i}`));\n      await waitFor(() => {}, { timeout: 10 }); // Small delay to allow state update\n    }\n\n    // Assert combo triggered\n    await waitFor(() => {\n      expect(screen.getByText(/Combo Burst!/)).toBeTruthy();\n    });\n  });\n});\n```\n\n#### GREEN Phase: Minimal Implementation\n```typescript\n// SalvageService.ts\nexport class SalvageService {\n  salvageItem(itemId: string, isManual: boolean): SalvageResult {\n    const item = inventoryStore.getItem(itemId);\n    if (!item) throw new Error('Item not found');\n\n    // Calculate materials\n    const baseMaterials = item.salvageValue; // e.g., 10\n    const multiplier = isManual ? 2 : 1;\n    const materialAmount = baseMaterials * multiplier;\n\n    // Add to materials store\n    materialsStore.addMaterial('common', materialAmount);\n\n    // Remove from inventory\n    inventoryStore.removeItem(itemId);\n\n    return {\n      materials: [{ type: 'common', amount: materialAmount }],\n      isCritical: false\n    };\n  }\n}\n```\n\n#### REFACTOR Phase: Improve Implementation\n```typescript\n// Extract material calculation\nclass MaterialCalculator {\n  calculate(item: Item, bonusMultiplier: number): Material[] {\n    const base = item.salvageValue;\n    const amount = Math.floor(base * bonusMultiplier);\n\n    // Add rarity RNG\n    const materials: Material[] = [{ type: 'common', amount }];\n\n    if (Math.random() < this.getRareChance(item.rarity)) {\n      materials.push({ type: 'rare', amount: Math.floor(amount / 3) });\n    }\n\n    return materials;\n  }\n\n  private getRareChance(rarity: string): number {\n    return { common: 0.25, rare: 0.50, epic: 0.75, legendary: 1.0 }[rarity] || 0;\n  }\n}\n\n// Refactored SalvageService\nexport class SalvageService {\n  constructor(private calculator: MaterialCalculator) {}\n\n  salvageItem(itemId: string, isManual: boolean): SalvageResult {\n    const item = inventoryStore.getItem(itemId);\n    if (!item) throw new Error('Item not found');\n\n    const multiplier = isManual ? 2 : 1;\n    const materials = this.calculator.calculate(item, multiplier);\n\n    materials.forEach(m => materialsStore.addMaterial(m.type, m.amount));\n    inventoryStore.removeItem(itemId);\n\n    return { materials, isCritical: false };\n  }\n}\n```\n\n### Test Categories (in order of implementation)\n\n#### Unit Testing (TDD First Layer)\n\n**Components to Test**:\n1. **SalvageService**: All salvage logic\n   - [ ] Manual salvage removes item and adds materials\n   - [ ] Manual salvage applies 2x multiplier\n   - [ ] Auto salvage applies 1x multiplier\n   - [ ] Critical salvage (5% chance) applies 5x multiplier\n   - [ ] Combo detection (10 in 5 seconds)\n\n2. **TinkeringService**: All tinkering logic\n   - [ ] Tinker consumes materials\n   - [ ] Tinker increases equipment level\n   - [ ] Manual tinker costs 50% less\n   - [ ] Success rate is 100% for levels 1-10\n\n3. **MaterialCalculator**: Material RNG\n   - [ ] Calculates base materials correctly\n   - [ ] Applies multipliers\n   - [ ] RNG rare materials based on item rarity\n\n4. **AutomationEngine**: Queue and processing\n   - [ ] Adds items to queue\n   - [ ] Processes queue at configured speed\n   - [ ] Respects filters (auto-salvage commons only)\n   - [ ] Reorders queue correctly\n\n**Coverage Target**: >85% for services\n\n#### Integration Testing (TDD Second Layer)\n\n**Integration Scenarios**:\n1. **Inventory + Salvage + Materials Flow**\n   ```typescript\n   test('complete salvage flow updates all stores', async () => {\n     // Test that tapping item updates inventory, materials, and statistics\n   });\n   ```\n\n2. **Automation + Queue + Salvage Integration**\n   ```typescript\n   test('automation processes queue and updates materials', async () => {\n     jest.useFakeTimers();\n     automationEngine.start(10); // Level 10 = 1 item/3s\n\n     // Advance 3 seconds\n     jest.advanceTimersByTime(3000);\n\n     expect(materialsStore.getCommon()).toBeGreaterThan(0);\n   });\n   ```\n\n3. **Offline Progression Calculation**\n   ```typescript\n   test('offline rewards calculated correctly', async () => {\n     offlineService.recordAppExit();\n\n     // Simulate 2 hours passing\n     jest.setSystemTime(Date.now() + 2 * 60 * 60 * 1000);\n\n     const rewards = offlineService.calculateOfflineRewards();\n     expect(rewards.materials.common).toBe(2 * 60 * 60 * automationRate);\n   });\n   ```\n\n**Coverage Target**: >75% for integration paths\n\n#### End-to-End Testing (TDD Third Layer)\n\n**E2E User Flows**:\n1. **Phase 1 Progression: Manual → First Automation**\n   - Start with 50 items in inventory\n   - Manually salvage 30 items\n   - Collect 500 common materials\n   - Tinker equipment to +5\n   - Reach level 10 → unlock automation\n   - Enable automation → verify queue processing\n\n2. **Phase 2: Hybrid Gameplay**\n   - Manual click 10 items → trigger combo\n   - Enable automation → verify both manual and auto contribute\n   - Set filter to auto-salvage commons only\n   - Manually salvage rare item → verify 2x bonus\n\n3. **Offline Progression Flow**\n   - Enable automation at 10 items/sec\n   - Background app for 1 hour (simulated)\n   - Return → verify welcome modal\n   - Verify materials match expected (3600 items × materials per item)\n\n### TDD Checklist for Each Component\n- [ ] Test written BEFORE implementation code\n- [ ] Test queries by user-visible content (text, accessibility labels)\n- [ ] Avoid testID unless absolutely necessary\n- [ ] Async operations use `waitFor` or `findBy`\n- [ ] Mock external dependencies (API, AsyncStorage, timers)\n- [ ] Tests are deterministic (no actual RNG, use seeded random)\n- [ ] All tests pass before committing\n- [ ] Coverage report shows >80% coverage\n\n## 8. Infrastructure & Deployment\n\n### Infrastructure Requirements\n\n| Component | Specification | Justification |\n|-----------|--------------|---------------|\n| Client App | React Native 0.70+, Expo SDK 48+ | Current project stack |\n| Animations | Reanimated v3 | 60fps requirement |\n| State | Zustand 4.x | Lightweight, performant |\n| Storage | AsyncStorage | Offline-first architecture |\n| Backend | Node.js 18+ / Express | Existing backend stack |\n| Database | PostgreSQL 14+ | Relational data, ACID guarantees |\n| Cache | Redis 7+ | Session management, rate limiting |\n\n### Deployment Architecture\n\n#### Environment Strategy\n- **Development**: Local Expo dev server, local PostgreSQL\n- **Staging**: Expo EAS Update staging channel, AWS RDS staging\n- **Production**: Expo EAS Update production channel, AWS RDS production\n\n#### CI/CD Pipeline\n```yaml\n# .github/workflows/test-and-deploy.yml\nname: Test & Deploy\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      - run: npm ci\n      - run: npm run test:coverage\n      - run: npx codecov # Upload coverage\n\n  build-ios:\n    needs: test\n    if: github.ref == 'refs/heads/main'\n    runs-on: macos-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npx expo build:ios\n\n  build-android:\n    needs: test\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npx expo build:android\n\n  deploy-ota:\n    needs: [build-ios, build-android]\n    runs-on: ubuntu-latest\n    steps:\n      - run: npx expo publish --release-channel production\n```\n\n### Monitoring & Observability\n\n#### Metrics\n- **Application Metrics**:\n  - Salvage operations per second (avg, p95, p99)\n  - Animation frame rate during bursts (target >55fps)\n  - Queue processing lag (time between item added and processed)\n  - Offline calculation accuracy (% difference from server)\n\n- **Business Metrics**:\n  - Players reaching Level 10 (first automation unlock) - target 65%\n  - Manual vs auto salvage ratio - target 40% manual\n  - Daily active users with automation enabled\n  - Prestige milestone completion rate\n\n- **Infrastructure Metrics**:\n  - App launch time (target <3s)\n  - Memory usage (target <200MB total app)\n  - API response time (target p95 <200ms)\n  - Backend CPU/memory utilization\n\n#### Logging\n```typescript\n// Centralized logger\nimport * as Sentry from '@sentry/react-native';\n\nconst logger = {\n  info: (message: string, context: object) => {\n    console.log(message, context);\n    Sentry.addBreadcrumb({ message, data: context, level: 'info' });\n  },\n\n  error: (message: string, error: Error, context: object) => {\n    console.error(message, error, context);\n    Sentry.captureException(error, { extra: context });\n  },\n\n  performance: (operation: string, duration: number) => {\n    Sentry.addBreadcrumb({\n      message: `${operation} took ${duration}ms`,\n      level: 'info',\n      category: 'performance'\n    });\n  }\n};\n\n// Usage\nlogger.info('Manual salvage', { itemId, materials, isCritical });\nlogger.performance('salvage_animation', animationDuration);\n```\n\n#### Alerting\n\n| Alert | Condition | Priority | Action |\n|-------|-----------|----------|--------|\n| High crash rate | >2% of sessions crash | P0 | Rollback OTA update, investigate Sentry errors |\n| Animation perf degradation | Avg FPS <50 for 10min | P1 | Review particle pooling, check for memory leaks |\n| Offline calc divergence | >10% of offline validations fail | P1 | Check rate calculation logic, review server logs |\n| API latency spike | p95 >500ms for 5min | P2 | Check backend CPU, investigate slow queries |\n| Low automation adoption | <50% of L10+ players enable automation | P2 | Review unlock messaging, check for UX friction |\n\n## 9. Scalability & Performance\n\n### Performance Requirements\n\nFrom PRD, translated to technical targets:\n\n| Requirement | Technical Target | Measurement |\n|-------------|-----------------|-------------|\n| Animation frame rate | >55fps avg during 60-item/10s burst | React DevTools Profiler |\n| Salvage processing | 100 items/sec at Level 26 | Performance.now() timing |\n| Queue operations | Add/remove/reorder in <50ms | Performance.now() timing |\n| App launch | <3s to interactive (Expo requirement) | Time to First Interaction metric |\n| Memory footprint | <50MB increase for feature | Xcode Instruments / Android Profiler |\n\n### Scalability Strategy\n\n#### Client-Side Scalability\n\n**Challenge**: Processing 100 items/second while maintaining 60fps\n**Solution**: Batch processing with requestAnimationFrame\n\n```typescript\nclass AutomationEngine {\n  private processingQueue: Item[] = [];\n  private batchSize = 10; // Process 10 items per frame at 60fps = 600/sec capacity\n\n  start(level: AutomationLevel) {\n    const itemsPerSecond = this.getSpeedForLevel(level);\n    const frameInterval = Math.ceil(60 / itemsPerSecond); // e.g., process every 1 frame for 60/sec\n\n    let frameCount = 0;\n    const processFrame = () => {\n      frameCount++;\n\n      if (frameCount % frameInterval === 0) {\n        this.processBatch(this.batchSize);\n      }\n\n      this.animationFrameId = requestAnimationFrame(processFrame);\n    };\n\n    processFrame();\n  }\n\n  private processBatch(count: number) {\n    const batch = this.processingQueue.splice(0, count);\n    const results = salvageService.salvageBatch(batch.map(i => i.id));\n    // Update materials in single store update (batched re-render)\n    materialsStore.addMaterialsBatch(results.flatMap(r => r.materials));\n  }\n}\n```\n\n**Challenge**: Inventory with 100,000+ items\n**Solution**: Virtual scrolling with React Native FlatList\n\n```typescript\n<FlatList\n  data={inventory}\n  renderItem={({ item }) => <InventoryItemCard item={item} />}\n  keyExtractor={(item) => item.id}\n  windowSize={5} // Render 5 screens worth of content\n  maxToRenderPerBatch={10}\n  updateCellsBatchingPeriod={50}\n  removeClippedSubviews={true}\n  getItemLayout={(data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index,\n  })}\n/>\n```\n\n#### Backend Scalability\n\n**Challenge**: Supporting 1M concurrent users\n**Solution**: Horizontal scaling with stateless API servers\n\n- **API Servers**: Auto-scaling group (2-10 instances) behind ALB\n- **Database**: PostgreSQL with read replicas (1 primary, 2 replicas)\n- **Caching**: Redis cluster for session data and rate limiting\n- **Queue**: Background job queue for async operations (offline validation)\n\n### Performance Optimization\n\n#### Animation Optimization\n```typescript\n// Particle pooling to avoid allocation overhead\nclass ParticlePool {\n  private pool: Particle[] = [];\n  private active: Set<Particle> = new Set();\n\n  constructor(poolSize = 300) {\n    for (let i = 0; i < poolSize; i++) {\n      this.pool.push(this.createParticle());\n    }\n  }\n\n  acquire(): Particle {\n    const particle = this.pool.pop() || this.createParticle();\n    this.active.add(particle);\n    return particle;\n  }\n\n  release(particle: Particle) {\n    this.active.delete(particle);\n    particle.reset();\n    this.pool.push(particle);\n  }\n}\n```\n\n#### Query Optimization\n```sql\n-- Optimize player state loading\nCREATE INDEX idx_player_materials ON player_materials(player_id);\nCREATE INDEX idx_player_inventory_acquired ON player_inventory(player_id, acquired_at DESC);\n\n-- Optimize offline progression query\nCREATE INDEX idx_offline_log_recent ON offline_progression_log(player_id, logged_at DESC);\n```\n\n#### Code-Level Optimizations\n- **Zustand selectors**: Use shallow equality checks to prevent unnecessary re-renders\n- **React.memo**: Memoize InventoryItemCard, MaterialCounter components\n- **useCallback**: Memoize event handlers to prevent child re-renders\n- **useMemo**: Memoize expensive calculations (material totals, power level)\n\n## 10. Risk Assessment & Mitigation\n\n### Technical Risks\n\n| Risk | Impact | Probability | Mitigation | Owner |\n|------|--------|-------------|------------|-------|\n| Reanimated v3 performance issues on Android | High | Medium | Early prototype (Week 1), fallback to React Native Animated, reduce particle count on low-end devices | Engineering |\n| Queue processing causes UI jank at 100/sec | High | Medium | Implement batching with RAF, throttle UI updates to 10fps for counters, use web workers if needed | Engineering |\n| Offline calc exploits (client manipulation) | High | Low | Server-side validation on every sync, flag accounts with >5% discrepancies, ban repeat offenders | Backend + Security |\n| State sync conflicts (multiple devices) | Medium | Medium | Server timestamp wins, show conflict modal to user, provide manual merge option | Engineering |\n| AsyncStorage size limits (some devices cap at 6MB) | Medium | Low | Implement state compression (gzip), archive old data, prompt user to clear old items | Engineering |\n| Complex state causing test brittleness | Medium | Medium | Use factory functions for test data, avoid mocking Zustand stores (use real stores in tests), isolate test environments | QA + Engineering |\n| Battery drain from constant animation | Low | High | Reduce particle count after 10 salvages, offer \"power saver mode\", pause animations when app backgrounded | Engineering |\n\n### Dependencies\n\n#### From PRD\n| Dependency | Technical Impact | Mitigation |\n|------------|-----------------|------------|\n| React Native Reanimated v3 compatibility | Required for 60fps animations | Verify Expo SDK 48 compatibility, budget 3 days for upgrade if needed |\n\n#### Additional Technical Dependencies\n| Dependency | Impact | Mitigation |\n|------------|--------|------------|\n| Expo EAS Build service availability | Blocks deployment | Have local build fallback, monitor Expo status page |\n| Backend API availability | Breaks cloud sync, offline mode still works | Implement retry logic, queue failed requests, show offline indicator |\n| Jest + React Native Testing Library | Required for TDD approach | Already in project, reference guide exists |\n\n## 11. Implementation Plan (TDD-Driven)\n\nFollowing `@docs/guides/lean-task-generation-guide.md` principles - prioritize user-visible functionality, no infrastructure-only tasks.\n\n### Phase 1: Manual Foundation with TDD (2 weeks)\n\n#### Week 1: Manual Salvaging\n\n**Task 1.1: Basic Manual Salvage with TDD (2 days)**\n- **Day 1**: Write failing tests\n  - Test: Tap item → item removed from inventory\n  - Test: Tap item → materials added to counter\n  - Test: Material counter shows popup animation\n- **Day 2**: Implement to pass tests\n  - Create SalvageService.salvageItem()\n  - Wire tap handler in InventoryScreen\n  - Add materials to MaterialsStore\n  - Create NumberPopup component\n\n**Task 1.2: Particle Animation System (3 days)**\n- **Day 1-2**: Write failing tests + setup\n  - Test: Particles spawn at item location\n  - Test: Particles animate to materials counter\n  - Setup Reanimated mocks for testing\n  - Create ParticleSystem test harness\n- **Day 3**: Implement particle spawner\n  - ParticlePool class\n  - Burst animation (useSharedValue, withSpring)\n  - Collection animation (withTiming to target coords)\n\n**Files Created**:\n- `/frontend/services/SalvageService.ts`\n- `/frontend/components/ParticleSystem.tsx`\n- `/frontend/components/NumberPopup.tsx`\n- Test files for each\n\n#### Week 2: Manual Tinkering\n\n**Task 1.3: Basic Tinkering with TDD (2 days)**\n- **Day 1**: Write failing tests\n  - Test: Drag materials to equipment → button appears\n  - Test: Hold button 2s → equipment level increases\n  - Test: Success rate is 100% for levels 1-10\n- **Day 2**: Implement tinkering\n  - TinkeringService class\n  - HoldToChannel button component\n  - Equipment upgrade logic\n\n**Task 1.4: Equipment Display (1 day)**\n- Write test: Equipment shows current level, power, cost\n- Implement EquipmentCard component\n- Wire to EquipmentStore\n\n**Task 1.5: Integration + Polish (2 days)**\n- Write E2E test: Complete flow (salvage → tinker → power increase)\n- Add haptic feedback\n- Add sound effects (optional)\n- Tune particle visuals\n\n**Files Created**:\n- `/frontend/services/TinkeringService.ts`\n- `/frontend/components/HoldToChannel.tsx`\n- `/frontend/components/EquipmentCard.tsx`\n- `/frontend/screens/EquipmentScreen.tsx`\n\n### Phase 2: Automation & Hybrid Gameplay (3 weeks)\n\n#### Week 3: First Automation Unlock\n\n**Task 2.1: Level 10 Automation Unlock (3 days)**\n- **Day 1**: Write failing tests\n  - Test: Reach level 10 → celebration modal appears\n  - Test: Enable assistant → items process every 3s\n  - Test: Queue shows next items\n- **Day 2-3**: Implement automation engine\n  - AutomationEngine.start() with setInterval\n  - Queue data structure (array with max 10,000)\n  - CelebrationModal component\n  - AutomationPanel UI\n\n**Task 2.2: Queue Management UI (2 days)**\n- Tests: Add/remove items, reorder queue, view status\n- Implement QueueDisplay component with FlatList\n- Drag-to-reorder with react-native-draggable-flatlist\n\n**Files Created**:\n- `/frontend/services/AutomationEngine.ts`\n- `/frontend/components/AutomationPanel.tsx`\n- `/frontend/components/QueueDisplay.tsx`\n- `/frontend/components/CelebrationModal.tsx`\n\n#### Week 4: Hybrid Manual Bonuses\n\n**Task 2.3: Manual Bonuses (2 days)**\n- Tests: Manual salvage yields 2x materials\n- Tests: 10 clicks in 5s triggers combo\n- Tests: Critical clicks (5% chance) give 5x\n- Implement bonus logic in SalvageService\n- Add combo detection (track timestamps)\n- Add \"Combo Burst!\" visual\n\n**Task 2.4: Statistics Tracking (1 day)**\n- Test: UI shows manual vs auto contribution %\n- Implement StatisticsDisplay component\n- Track counts in AutomationStore\n\n**Task 2.5: Automation Tiers (2 days)**\n- Tests: Levels 13, 15, 18, 22 unlock faster speeds\n- Implement tier unlocking system\n- Update AutomationPanel to show upgrades\n\n**Files Created**:\n- `/frontend/components/ComboDisplay.tsx`\n- `/frontend/components/StatisticsDisplay.tsx`\n- `/frontend/stores/AutomationStore.ts`\n\n#### Week 5: Filters & Priority System\n\n**Task 2.6: Salvage Filters (3 days)**\n- **Day 1**: Tests for filter rules\n  - Test: \"Auto-salvage commons\" only processes commons\n  - Test: Whitelist prevents auto-salvage of specific items\n  - Test: Filter preview shows what would be salvaged\n- **Day 2**: Implement filter engine\n  - SalvageFilter types (rarity, whitelist, duplicates)\n  - FilterEngine.applyFilters(queue, filters)\n- **Day 3**: Filter configuration UI\n  - FilterSettings modal\n  - Preview mode\n\n**Task 2.7: Tinkering Priority (2 days)**\n- Tests: Materials distribute to high-priority equipment first\n- Implement priority sorting\n- Add priority UI to EquipmentCard\n\n**Files Created**:\n- `/frontend/services/FilterEngine.ts`\n- `/frontend/components/FilterSettings.tsx`\n- `/frontend/components/FilterPreview.tsx`\n\n### Phase 3: Full Automation & Prestige (2 weeks)\n\n#### Week 6: Master Automation\n\n**Task 3.1: Level 26 Master Salvager (2 days)**\n- Tests: Processes 100 items/sec\n- Tests: Queue holds 10,000 items\n- Implement batching with RAF\n- Optimize for performance\n\n**Task 3.2: Smart Tinkering AI (3 days)**\n- **Day 1**: Tests for AI suggestions\n  - Test: AI suggests optimal distribution\n  - Test: One-click accepts suggestion\n- **Day 2-3**: Implement suggestion algorithm\n  - Analyze player patterns (which equipment gets most manual tinkers)\n  - Calculate optimal distribution based on power/cost ratio\n  - SmartTinkeringModal component\n\n**Files Created**:\n- `/frontend/services/SmartTinkeringAI.ts`\n- `/frontend/components/SmartTinkeringModal.tsx`\n\n#### Week 7: Offline & Prestige\n\n**Task 3.3: Offline Progression (3 days)**\n- **Day 1**: Tests for offline calc\n  - Test: App backgrounds → timestamp saved\n  - Test: App returns → offline rewards calculated\n  - Test: Server validation corrects client calc\n- **Day 2**: Implement OfflineProgressionService\n  - recordAppExit() on AppState change\n  - calculateOfflineRewards() on return\n  - API integration for validation\n- **Day 3**: WelcomeBackModal UI\n\n**Task 3.4: Prestige System (2 days)**\n- Tests: 1,000 salvages → prestige choice modal\n- Tests: Bonus applied correctly (1hr duration)\n- Implement PrestigeService\n- PrestigeChoiceModal component\n\n**Files Created**:\n- `/frontend/services/OfflineProgressionService.ts`\n- `/frontend/services/PrestigeService.ts`\n- `/frontend/components/WelcomeBackModal.tsx`\n- `/frontend/components/PrestigeChoiceModal.tsx`\n\n### Phase 4: Polish & Testing (1 week)\n\n#### Week 8: Integration Testing & Performance\n\n**Task 4.1: Full Integration Tests (2 days)**\n- E2E test: Phase 1 → Phase 2 → Phase 3 progression\n- E2E test: Offline for 2hrs → return → validate\n- E2E test: Prestige milestone flow\n\n**Task 4.2: Performance Optimization (2 days)**\n- Profile particle animations → optimize pool size\n- Profile queue processing → tune batch size\n- Test on low-end Android device\n- Reduce particle count if FPS <55\n\n**Task 4.3: Accessibility & Polish (1 day)**\n- Add accessibility labels\n- Test with VoiceOver/TalkBack\n- Add haptic feedback to all interactions\n- Final visual polish\n\n### Technical Milestones\n\n| Milestone | Deliverable | Date | Dependencies |\n|-----------|------------|------|--------------|\n| M1 | Manual salvage + tinkering working | End Week 2 | Reanimated setup, test framework |\n| M2 | First automation unlock functional | End Week 3 | M1 complete, level progression |\n| M3 | Hybrid gameplay with bonuses | End Week 4 | M2 complete |\n| M4 | Complete automation with filters | End Week 5 | M3 complete |\n| M5 | Offline progression + prestige | End Week 7 | M4 complete, backend API ready |\n| M6 | Performance targets met, tests passing | End Week 8 | All features complete |\n\n## 12. Decision Log\n\n### Architecture Decisions\n\n| Decision | Options Considered | Choice | Rationale |\n|----------|-------------------|--------|-----------|\n| State Management | Redux, MobX, Zustand, Context API | **Zustand** | Lightweight (1KB), simple API, no boilerplate, already familiar to team, excellent TypeScript support |\n| Animation Library | React Native Animated, Reanimated v2, Reanimated v3, Lottie | **Reanimated v3** | Runs on UI thread (60fps capable), best performance for particle effects, active development, Expo compatible |\n| Queue Data Structure | Array, Linked List, Ring Buffer | **Array with splice** | Simplest implementation, max 10,000 items is small enough for O(n) operations, easier to serialize for persistence |\n| Offline Storage | AsyncStorage, SQLite, Realm | **AsyncStorage** | Already in project, sufficient for <10MB game state, simpler API, no migration complexity |\n| Testing Strategy | Unit only, E2E only, Full TDD | **Full TDD with RNTL** | Enforces quality, catches regressions early, aligns with project guide, builds confidence for refactoring |\n| Backend Stack | REST, GraphQL, gRPC | **REST** | Existing backend is REST, simpler for CRUD operations, easier to mock in tests, sufficient for sync operations |\n\n### Trade-offs\n\n#### Trade-off 1: Client-side RNG vs Server-side RNG\n- **Chose**: Client-side RNG with server validation\n- **Over**: Server-side authoritative RNG for every salvage\n- **Because**: Instant client feedback is critical for engagement, server validates material balances on sync (every 30s), acceptable risk for cheat detection\n\n#### Trade-off 2: Particle Animation Complexity\n- **Chose**: Simple particle pool with basic physics\n- **Over**: Complex particle system with collisions, trails, etc.\n- **Because**: 60fps target is strict, battery life concerns, diminishing returns on visual complexity, can enhance later if performance allows\n\n#### Trade-off 3: Queue Size Limit\n- **Chose**: Hard cap at 10,000 items\n- **Over**: Unlimited queue or pagination\n- **Because**: Prevents memory issues, forces player engagement (empty queue), 10,000 items = 100 seconds at max speed (sufficient buffer), simplifies UI\n\n#### Trade-off 4: Offline Progression Cap\n- **Chose**: 4-hour maximum accumulation\n- **Over**: Unlimited offline gains\n- **Because**: Prevents extreme imbalances, encourages daily engagement, aligns with idle game best practices, reduces server validation complexity\n\n## 13. Open Questions\n\nTechnical questions requiring resolution:\n\n- [ ] **Animation Performance**: Can we achieve 60fps with 30 particles per salvage on iPhone X (A11 chip)? Need prototype by end of Week 1.\n- [ ] **Queue Persistence**: Should queue state persist across app restarts, or rebuild from inventory on launch? (Persistence = more complexity, rebuild = potential UX hiccup)\n- [ ] **Combo Detection**: Should combo timer reset on any gap >1s, or allow small gaps? Need UX feedback.\n- [ ] **Material Counter Display**: At what point do we switch to scientific notation? (1,000? 1,000,000?)\n- [ ] **Backend Sync Frequency**: Is 30s sync sufficient, or should we sync every state change (with debouncing)? Trade-off: server load vs data freshness.\n- [ ] **Prestige Bonus Stacking**: Can multiple prestige bonuses be active simultaneously, or only one at a time? Affects game balance.\n- [ ] **Filter Rule Conflicts**: If user sets \"auto-salvage commons\" but also \"whitelist Item X\" (a common), which wins? Need clear precedence.\n- [ ] **Offline Validation Handling**: If server offline calc differs by >2%, do we show modal to user or silently accept server value?\n\n## 14. Appendices\n\n### A. Technical Glossary\n\n| Term | Definition |\n|------|------------|\n| **RAF (requestAnimationFrame)** | Browser/React Native API for 60fps rendering loop, used for batching queue processing |\n| **Zustand Store** | Lightweight state management library, stores are created with `create()` and accessed via hooks |\n| **Reanimated Shared Value** | useSharedValue() creates values that run on UI thread for 60fps animations |\n| **Particle Pool** | Pre-allocated array of particle objects to avoid allocation overhead during animations |\n| **Batching** | Processing multiple items in single operation to reduce overhead (e.g., 10 salvages in 1 store update) |\n| **Virtual Scrolling** | FlatList technique that only renders visible items, enabling 100k+ item lists |\n| **Server Reconciliation** | Process where server validates client state and corrects discrepancies |\n| **TDD Red-Green-Refactor** | Write failing test (RED) → implement minimal code (GREEN) → improve code quality (REFACTOR) |\n| **MSW (Mock Service Worker)** | Tool for mocking API requests in tests using service worker pattern |\n\n### B. Reference Architecture\n\n- **Idle Game Pattern**: Cookie Clicker, Adventure Capitalist (manual → automation progression)\n- **Hybrid Engagement**: Melvor Idle, NGU Idle (manual actions remain valuable at max automation)\n- **React Native State**: Zustand examples from project `/frontend/stores/`\n- **Animation Performance**: Reanimated v3 best practices (use worklets, avoid bridge crossing)\n\n### C. Proof of Concepts\n\n#### POC 1: Particle Performance (Week 1)\nCreate isolated test app:\n- Spawn 30 particles every 0.5s (60 particles/second burst)\n- Measure FPS with React DevTools Profiler\n- Test on: iPhone X, Samsung Galaxy S10, Pixel 4\n- **Success Criteria**: >55fps average during 10-second burst\n\n#### POC 2: Queue Processing at 100/sec (Week 3)\nCreate isolated test:\n- Queue of 10,000 items\n- Process 100 items/sec using RAF batching\n- Measure: CPU usage, memory, UI responsiveness\n- **Success Criteria**: <10% CPU, <20MB memory increase, UI remains interactive\n\n### D. Related Documents\n\n- **Product Requirements Document**: `/docs/specs/salvage-tinkering-system/prd_salvage_tinkering_progressive_automation_20251024.md`\n- **Lean Task Generation Guide**: `/docs/guides/lean-task-generation-guide.md`\n- **React Native Testing Library Guide**: `/docs/research/react_native_testing_library_guide_20250918_184418.md`\n- **Project CLAUDE.md**: `/CLAUDE.md` (Expo + React Native setup, rules)\n\n---\n\n**Generated from PRD**: `prd_salvage_tinkering_progressive_automation_20251024.md`\n**Generation Date**: 2025-10-24\n**Next Review**: 2025-11-07 (2 weeks post-creation)\n**Approval Required From**: Engineering Lead, QA Lead, Product Lead\n"}}],"uuid":"207f57d7-2e58-43c3-9e2f-855eae1f527b"}
