# Product Requirements Document: Shop System

**Version:** 1.0
**Date:** 2025-11-17
**Feature:** Upgrade Shop Interface
**Module:** `/frontend/modules/shop`

---

## 1. Overview

### 1.1 Executive Summary
The Shop System provides a dedicated interface for players to spend their accumulated scrap resources on upgrades that enhance their progression in the Singularity Pet feeding game. This feature creates a meaningful purpose for the scrap currency and establishes the foundation for the game's upgrade economy.

### 1.2 Background
Players currently collect scrap passively based on their AI Pet count (1 scrap per pet per second). However, there is currently no way to utilize this accumulated resource. The Shop System addresses this by providing a navigation pathway from the main screen to a dedicated shop screen where upgrades can be browsed and purchased. This implementation will focus on the shop infrastructure and UI framework without implementing specific upgrades yet.

### 1.3 Objectives
- Create a new dedicated shop screen accessible from the main game screen
- Implement navigation between the main screen and shop screen
- Establish the UI framework for displaying upgrades in a list format
- Create the foundational purchase flow (checking scrap balance, deducting costs)
- Design an extensible architecture that supports future upgrade additions
- Ensure seamless integration with existing state management and persistence systems

---

## 2. User Stories

### 2.1 Core User Stories

**US-1: Access Shop from Main Screen**
As a player, I want to navigate to a shop screen from the main game screen, so that I can view and purchase upgrades.

**Acceptance Criteria:**
- A clearly labeled button/link appears on the main screen
- Button is labeled "Shop" or "Upgrades"
- Tapping the button navigates to the shop screen
- Navigation transition is smooth and responsive
- Shop button is accessible at all times during gameplay

**US-2: Browse Available Upgrades**
As a player, I want to see a list of available upgrades in the shop, so that I can understand what I can purchase with my scrap.

**Acceptance Criteria:**
- Shop screen displays all available upgrades in a scrollable list
- Each upgrade shows: name, description, scrap cost
- Upgrades clearly indicate their effect type (scrap multiplier or pet bonus)
- List is empty initially (no upgrades defined yet) but displays appropriate messaging
- UI is prepared to render upgrades when they are added to the system

**US-3: View Upgrade Details**
As a player, I want to see detailed information about each upgrade, so that I can make informed purchasing decisions.

**Acceptance Criteria:**
- Each upgrade card displays:
  - Name (clear, descriptive title)
  - Description (explains what the upgrade does)
  - Scrap cost (prominently displayed)
  - Effect type and value
- Display format is consistent across all upgrades
- Information is clearly legible and well-organized

**US-4: Purchase Upgrades**
As a player, I want to purchase upgrades using my scrap, so that I can improve my progression rate.

**Acceptance Criteria:**
- Each upgrade has a "Buy" button
- Button is disabled if player has insufficient scrap
- Clicking "Buy" deducts the scrap cost from player's balance
- Purchase is recorded in game state (added to purchasedUpgrades array)
- Purchase persists across app sessions
- Purchased upgrades are visually distinct (grayed out or marked as "Owned")
- Purchased upgrades cannot be bought again

**US-5: View Current Scrap Balance**
As a player, I want to see my current scrap balance in the shop, so that I know how much I can spend.

**Acceptance Criteria:**
- Current scrap amount is displayed at the top of the shop screen
- Scrap display updates in real-time if scrap is gained while in shop
- Display format matches the scrap display on main screen

**US-6: Return to Main Screen**
As a player, I want to navigate back to the main screen from the shop, so that I can continue feeding my pet.

**Acceptance Criteria:**
- A "Back" button or header navigation is available
- Tapping back returns to the main screen
- Navigation preserves game state (no data loss)
- Return transition is smooth and responsive

### 2.2 Secondary User Stories

**US-7: Visual Feedback for Purchases**
As a player, I want clear visual feedback when I purchase an upgrade, so that I know the transaction was successful.

**Acceptance Criteria:**
- Button provides press feedback (opacity/scale change)
- Purchase immediately updates the UI (scrap balance, owned status)
- No loading states or delays in simple purchase flow

**US-8: Empty State Handling**
As a player, I want appropriate messaging when no upgrades are available, so that I understand the shop is not broken.

**Acceptance Criteria:**
- If upgrades array is empty, display: "No upgrades available yet. Check back soon!"
- Empty state is centered and clearly visible
- Empty state includes helpful text (not just blank screen)

---

## 3. Functional Requirements

### 3.1 Navigation System

**FR-1: Main Screen Navigation Button**
- Main screen (AttackButtonScreen) MUST display a "Shop" button
- Button MUST be positioned prominently but not obstruct primary interactions
- Button MUST follow the app's design system (similar styling to "feed" button)
- Button MUST be accessible (44x44pt minimum touch target)

**FR-2: Screen State Management**
- App MUST support toggling between main screen and shop screen
- Navigation MUST preserve all game state (petCount, scrap, upgrades)
- App MUST use React state to manage which screen is displayed
- Screen transitions MUST be instantaneous (no routing library needed for this simple case)

**FR-3: Back Navigation**
- Shop screen MUST include a "Back" or "Close" button in the header
- Back button MUST return user to main screen
- Back navigation MUST preserve all state changes made in shop

### 3.2 Shop Screen UI

**FR-4: Header Section**
- Shop screen MUST display a header with:
  - Title: "Shop" or "Upgrades"
  - Current scrap balance
  - Back/Close button
- Header MUST remain visible when scrolling (sticky or fixed)

**FR-5: Upgrades List Display**
- Shop MUST display all upgrades from the `upgrades` array in game state
- Each upgrade MUST be rendered as a distinct card or list item
- List MUST be scrollable when content exceeds screen height
- Upgrades MUST be displayed in a consistent order (array order)

**FR-6: Upgrade Card Structure**
Each upgrade card MUST display:
- Upgrade name (bold, 16-18px font)
- Upgrade description (regular, 14px font)
- Scrap cost with icon/label (e.g., "Cost: 100 scrap")
- Effect type and value (e.g., "Scrap Multiplier: x2" or "Pet Bonus: +5")
- Purchase button (when not owned)
- Owned indicator (when purchased)

**FR-7: Empty State Display**
- When `upgrades` array is empty, MUST display:
  - Centered message: "No upgrades available yet."
  - Subtext: "Check back soon for new upgrades!"
  - Friendly, non-error styling

### 3.3 Purchase Flow

**FR-8: Purchase Validation**
- Before allowing purchase, MUST check:
  - Upgrade has not already been purchased (ID not in `purchasedUpgrades`)
  - Player has sufficient scrap (scrap >= scrapCost)
- Purchase button MUST be disabled if either condition fails

**FR-9: Purchase Execution**
When player purchases an upgrade, system MUST:
1. Deduct scrap cost from `gameState$.scrap`
2. Add upgrade ID to `gameState$.purchasedUpgrades`
3. Update UI immediately to reflect changes
4. Trigger automatic state persistence (via existing onChange handler)

**FR-10: Purchase Button States**
- **Available (can purchase):** Enabled, blue/primary color, text "Buy"
- **Insufficient Scrap:** Disabled, gray, text "Not enough scrap"
- **Already Owned:** Disabled, green/success color, text "Owned" or checkmark

**FR-11: Visual Distinction for Owned Upgrades**
- Owned upgrades MUST be visually distinct:
  - Reduced opacity (0.6) or grayed out
  - "Owned" badge or checkmark icon
  - Button replaced with "Owned" indicator
- Owned upgrades SHOULD remain visible in list (not hidden)

### 3.4 State Management

**FR-12: Integration with Game State**
- Shop MUST read from existing `gameState$` observable
- Shop MUST use `gameState$.upgrades` for available upgrades
- Shop MUST use `gameState$.scrap` for current balance
- Shop MUST use `gameState$.purchasedUpgrades` for ownership tracking
- All state updates MUST use Legend State's reactive patterns

**FR-13: Reactive UI Updates**
- Shop screen MUST use `observer` from `@legendapp/state/react`
- UI MUST reactively update when:
  - Scrap balance changes
  - Upgrades are purchased
  - Upgrades array is modified (future)
- No manual re-render triggers required

**FR-14: Persistence Integration**
- All purchases MUST automatically persist via existing debounced save mechanism
- No additional persistence logic required in shop module
- Shop MUST load persisted purchases on app restart

---

## 4. Technical Requirements

### 4.1 Architecture

**TR-1: Component Structure**
```
/frontend/modules/shop/
â”œâ”€â”€ ShopScreen.tsx          # Main shop UI component
â”œâ”€â”€ ShopScreen.test.tsx     # Component tests
â””â”€â”€ specs/
    â”œâ”€â”€ feature-shop.md
    â””â”€â”€ prd_shop_20251117.md
```

**TR-2: Navigation Pattern**
- Use conditional rendering based on React state (no router needed)
- App.tsx or AttackButtonScreen manages navigation state
- Pattern example:
```typescript
const [currentScreen, setCurrentScreen] = useState<'main' | 'shop'>('main');
// Render ShopScreen or AttackButtonScreen based on currentScreen
```

**TR-3: State Management**
- Use existing `gameState$` observable from `@legendapp/state`
- Import and use existing hook pattern or direct observable access:
```typescript
import { gameState$ } from '../../shared/store/gameStore';
const upgrades = gameState$.upgrades.get();
const scrap = gameState$.scrap.get();
const purchasedUpgrades = gameState$.purchasedUpgrades.get();
```

**TR-4: Component Patterns**
- ShopScreen MUST be wrapped with `observer()` for reactivity
- Use React Native core components (View, Text, Pressable, ScrollView)
- Follow existing code style from AttackButtonScreen

### 4.2 Purchase Logic Implementation

**TR-5: Purchase Function**
```typescript
const handlePurchase = (upgrade: Upgrade) => {
  const currentScrap = gameState$.scrap.get();
  const purchased = gameState$.purchasedUpgrades.get();

  // Validation
  if (purchased.includes(upgrade.id)) return;
  if (currentScrap < upgrade.scrapCost) return;

  // Execute purchase
  gameState$.scrap.set(currentScrap - upgrade.scrapCost);
  gameState$.purchasedUpgrades.set([...purchased, upgrade.id]);
};
```

**TR-6: Ownership Check**
```typescript
const isOwned = (upgradeId: string): boolean => {
  return gameState$.purchasedUpgrades.get().includes(upgradeId);
};

const canPurchase = (upgrade: Upgrade): boolean => {
  const scrap = gameState$.scrap.get();
  return !isOwned(upgrade.id) && scrap >= upgrade.scrapCost;
};
```

### 4.3 UI/UX Implementation

**TR-7: Layout Structure**
```tsx
<SafeAreaView>
  <View style={styles.header}>
    {/* Back button, title, scrap display */}
  </View>
  <ScrollView style={styles.upgradesList}>
    {upgrades.length === 0 ? (
      <EmptyState />
    ) : (
      upgrades.map(upgrade => <UpgradeCard key={upgrade.id} upgrade={upgrade} />)
    )}
  </ScrollView>
</SafeAreaView>
```

**TR-8: Styling Requirements**
- Use React Native StyleSheet for consistency with existing code
- Follow accessibility guidelines (44x44pt touch targets)
- Use existing color scheme from AttackButtonScreen:
  - Background: #FFFFFF
  - Text: #000000
  - Primary button: #007AFF
  - Disabled: #CCCCCC or reduced opacity
- Consistent spacing: 10-20px margins and padding

**TR-9: Accessibility**
- All buttons MUST have `accessibilityRole="button"`
- All text MUST have `accessibilityRole="text"`
- Purchase buttons MUST have descriptive labels:
  - `accessibilityLabel="Buy {upgradeName} for {cost} scrap"`
  - `accessibilityHint="Double tap to purchase"`
- Disabled buttons MUST indicate why:
  - `accessibilityLabel="Not enough scrap to purchase {upgradeName}"`

### 4.4 Testing Requirements

**TR-10: Component Tests**
- Test shop screen renders correctly
- Test empty state displays when no upgrades
- Test upgrade cards render with correct data
- Test back navigation works
- Test scrap balance displays correctly

**TR-11: Purchase Flow Tests**
- Test purchase button disabled when insufficient scrap
- Test purchase button disabled when already owned
- Test successful purchase deducts scrap
- Test successful purchase adds to purchasedUpgrades
- Test UI updates after purchase
- Test cannot purchase same upgrade twice

**TR-12: Integration Tests**
- Test purchased upgrades persist across app restarts
- Test shop state syncs with main screen scrap changes
- Test navigation preserves all state

**TR-13: Test Environment**
- Run tests using cmd.exe (per project guidelines)
- Use Jest with React Native Testing Library
- Mock Legend State observables where needed
- Follow existing test patterns from gameStore.test.ts

---

## 5. Design Specifications

### 5.1 Shop Screen Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â† Back        Shop     Scrap: XXX  â”‚ â† Header (sticky)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Upgrade Name              ğŸ”§  â”‚ â”‚
â”‚  â”‚ Description of what this      â”‚ â”‚
â”‚  â”‚ upgrade does goes here.       â”‚ â”‚
â”‚  â”‚                               â”‚ â”‚
â”‚  â”‚ Effect: Scrap Multiplier x2   â”‚ â”‚
â”‚  â”‚ Cost: 100 scrap               â”‚ â”‚
â”‚  â”‚                               â”‚ â”‚
â”‚  â”‚          [ Buy ]              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Another Upgrade           ğŸ¯  â”‚ â”‚
â”‚  â”‚ Another description...        â”‚ â”‚
â”‚  â”‚                               â”‚ â”‚
â”‚  â”‚ Effect: Pet Bonus +5          â”‚ â”‚
â”‚  â”‚ Cost: 250 scrap               â”‚ â”‚
â”‚  â”‚                               â”‚ â”‚
â”‚  â”‚        [ Owned âœ“ ]            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚
â”‚  (scrollable list continues)        â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 Typography

**Header:**
- Title: 20px, bold (600)
- Scrap balance: 16px, regular (400)
- Back button: 16px, regular (400)

**Upgrade Cards:**
- Name: 18px, bold (600), #000000
- Description: 14px, regular (400), #666666
- Effect label: 14px, medium (500), #007AFF
- Cost label: 14px, medium (500), #FF9500 (orange)
- Button text: 16px, medium (500), #FFFFFF

### 5.3 Color Palette

- **Primary Background:** #FFFFFF (white)
- **Card Background:** #F8F8F8 (light gray)
- **Primary Text:** #000000 (black)
- **Secondary Text:** #666666 (gray)
- **Accent/Primary:** #007AFF (blue)
- **Success:** #34C759 (green) - for "Owned" state
- **Warning:** #FF9500 (orange) - for costs
- **Disabled:** #CCCCCC (light gray)

### 5.4 Spacing

- Screen padding: 20px horizontal
- Header padding: 16px vertical, 20px horizontal
- Card padding: 16px all sides
- Card margin: 12px bottom (between cards)
- Element spacing within cards: 8px vertical
- Button margin top: 12px

### 5.5 Interactive States

**Purchase Button:**
- **Default (can buy):**
  - Background: #007AFF, Text: #FFFFFF
  - Active opacity: 0.7, Scale: 0.98
- **Disabled (insufficient scrap):**
  - Background: #CCCCCC, Text: #999999
  - Opacity: 0.6, No press effect
- **Owned:**
  - Background: #34C759, Text: #FFFFFF
  - Icon: âœ“ checkmark
  - No press effect (non-interactive)

**Back Button:**
- Default: Text color #007AFF
- Pressed: Opacity 0.7

### 5.6 Responsive Behavior

- Header remains fixed at top (sticky)
- ScrollView fills remaining vertical space
- Cards take full width minus 40px (20px padding each side)
- Minimum height: 120px per card
- Content scales appropriately on small and large screens

---

## 6. Success Metrics

### 6.1 Technical Metrics

**SM-1: Performance**
- Screen navigation < 100ms response time
- No frame drops during scrolling
- Purchase action < 50ms from tap to UI update
- State persistence remains debounced (1 save per second max)

**SM-2: Reliability**
- 100% purchase accuracy (correct scrap deduction)
- Zero double-purchase bugs
- 100% persistence success rate
- Zero crashes related to shop functionality

**SM-3: Test Coverage**
- Minimum 90% code coverage for ShopScreen component
- 100% coverage for purchase logic functions
- All user flows tested (navigation, purchase, back)

### 6.2 User Experience Metrics

**SM-4: Usability**
- Navigation flow is immediately intuitive (no tutorial needed)
- Purchase feedback is instant and clear
- Owned vs. available upgrades are easily distinguished
- Scrap costs are clearly visible before purchase

**SM-5: Visual Feedback**
- Purchase updates UI within one render cycle
- No visual glitches or UI jumps
- Smooth scroll performance with many upgrades (10+ items)

---

## 7. Dependencies and Assumptions

### 7.1 Dependencies

**DP-1: Existing Systems**
- Legend State (`@legendapp/state`) for reactive state management
- Existing `gameState$` observable with `upgrades`, `scrap`, `purchasedUpgrades`
- Existing GameState interface with Upgrade type definition
- Existing persistence layer (auto-save via onChange)
- React Native core libraries (View, Text, Pressable, ScrollView, SafeAreaView)

**DP-2: Type Definitions**
- `Upgrade` interface already defined in `/frontend/shared/types/game.ts`
- `GameState` interface already includes necessary properties
- No new types required for MVP implementation

**DP-3: Navigation**
- Simple state-based navigation (no react-navigation dependency)
- Parent component (App.tsx) manages screen state

### 7.2 Assumptions

**AS-1: Upgrade System Scope**
- Upgrades array will initially be empty (defined but unpopulated)
- Shop will display empty state until upgrades are added
- Upgrade definitions will be added in future PR/update
- Upgrade effects will NOT be applied in this implementation (display only)

**AS-2: User Behavior**
- Players will navigate to shop intentionally (no automatic prompts)
- Players understand upgrade effects from descriptions alone
- No tutorial or onboarding required for shop concept
- Players are familiar with shop mechanics from similar games

**AS-3: Technical Assumptions**
- Simple two-screen navigation is sufficient (no deep routing)
- All upgrades can be displayed in a single scrollable list
- No pagination required (upgrade count expected < 50)
- No search or filter functionality needed initially

**AS-4: Future Scope**
- Upgrade effects will be implemented in separate feature
- Upgrade definitions will be managed centrally (not hardcoded in shop)
- Shop UI is extensible for future features (categories, sorting, search)

### 7.3 Constraints

**CS-1: Scope Limitations**
- NO upgrade effect implementation (effects won't actually apply)
- NO upgrade definitions/data (shop displays from `upgrades` array only)
- NO upgrade creation or management UI
- NO shop animations or transitions (beyond button press feedback)
- NO sound effects or haptic feedback
- NO analytics or tracking

**CS-2: Technical Constraints**
- MUST use existing state management patterns (Legend State)
- MUST NOT create new persistence mechanisms
- MUST NOT add new external dependencies
- MUST maintain backward compatibility with existing save data
- MUST use cmd.exe for running tests (per CLAUDE.md)

**CS-3: Design Constraints**
- MUST follow existing design patterns from AttackButtonScreen
- MUST maintain accessibility standards (WCAG 2.1 AA)
- MUST support minimum 44x44pt touch targets
- MUST use React Native core components (no UI library)

---

## 8. Open Questions and Decisions

**Q-1:** Should upgrades be sorted/ordered in any specific way?
**Decision:** Display upgrades in array order for MVP. Future: add sorting (by cost, by type, etc.)

**Q-2:** Should there be visual categories for upgrade types (scrapMultiplier vs petBonus)?
**Decision:** No categories for MVP. Simple flat list. Display effect type in each card.

**Q-3:** Should the shop show a preview of how upgrades will affect the player's stats?
**Decision:** No stat preview for MVP. Just show static effect values. Future: add "After purchase: X â†’ Y"

**Q-4:** How should we handle upgrades with the same ID appearing in the array?
**Decision:** Assume upgrades have unique IDs (data validation handled elsewhere). Use ID as React key.

**Q-5:** Should scrap continue to accumulate while in the shop screen?
**Decision:** Yes, scrap timer runs in background (AttackButtonScreen component stays mounted). Shop displays live scrap updates via reactive state.

**Q-6:** Should there be a confirmation dialog for purchases?
**Decision:** No confirmation for MVP. Purchases are intentional (disabled states prevent accidents). Future: add confirmation for expensive upgrades.

**Q-7:** What happens if player tries to buy an upgrade that costs exactly their current scrap?
**Decision:** Purchase succeeds. Scrap goes to 0. This is valid and allowed.

---

## 9. Out of Scope

The following items are explicitly excluded from this implementation:

1. **Upgrade Definitions:** No hardcoded or initial upgrades will be created (future feature)
2. **Upgrade Effects:** Purchased upgrades will not modify game behavior (future feature)
3. **Upgrade Management:** No admin/developer UI for creating upgrades
4. **Multiple Purchase:** No "buy multiple" or quantity selection
5. **Refunds/Selling:** No way to sell or refund upgrades
6. **Upgrade Levels:** No upgrade tiers or level-up mechanics
7. **Shop Animations:** No fancy transitions, particles, or celebrations
8. **Sound/Haptics:** No audio or vibration feedback
9. **Categories/Tabs:** No categorization or filtering of upgrades
10. **Search:** No search functionality
11. **Favorites/Wishlist:** No way to mark upgrades for later
12. **Notifications:** No alerts or badges for affordable upgrades
13. **Statistics:** No tracking of purchase history or spending
14. **Recommendations:** No suggested or featured upgrades

---

## 10. Implementation Plan

### 10.1 Development Phases

**Phase 1: Navigation Setup (Priority: High)**
- Add "Shop" button to AttackButtonScreen
- Implement screen state management in App.tsx
- Create basic ShopScreen component skeleton
- Verify navigation works both directions

**Phase 2: Shop UI Implementation (Priority: High)**
- Implement shop header with scrap display and back button
- Create upgrade card component
- Implement empty state display
- Style components to match design specs

**Phase 3: Purchase Logic (Priority: High)**
- Implement ownership checking
- Implement purchase validation (scrap balance)
- Implement purchase execution (deduct scrap, add to purchased)
- Wire up purchase button states

**Phase 4: Testing (Priority: High)**
- Write component tests for ShopScreen
- Write purchase flow tests
- Test navigation flows
- Test persistence integration
- Manual testing on device

**Phase 5: Polish (Priority: Medium)**
- Refine accessibility labels
- Optimize performance (minimize re-renders)
- Add press feedback animations
- Ensure responsive layout on various screen sizes

**Phase 6: Documentation (Priority: Low)**
- Document component API and props
- Add JSDoc comments to functions
- Update project documentation if needed

### 10.2 Testing Strategy

**Unit Tests:**
- ShopScreen component renders correctly
- Empty state displays when upgrades array is empty
- Upgrade cards display correct data from props
- Purchase button states based on ownership and scrap balance
- Purchase function logic (deduction, adding to purchased array)

**Integration Tests:**
- Navigation between screens preserves state
- Purchases persist across app restarts
- Scrap balance syncs between screens
- Multiple purchases work correctly

**Manual Tests:**
- Visual verification of layout and spacing
- Accessibility testing (VoiceOver/TalkBack)
- Touch target sizes feel correct
- Scroll performance with many upgrades
- Test on both iOS and Android if applicable

**Test Data:**
- Create mock upgrades for testing purposes
- Test with 0 upgrades (empty state)
- Test with 1 upgrade
- Test with 10+ upgrades (scroll behavior)
- Test with various scrap balances (0, low, high)

---

## 11. Risks and Mitigations

### 11.1 Technical Risks

**RISK-001: Navigation State Complexity**
- **Risk:** Simple state-based navigation may not scale for future screens
- **Mitigation:** Implementation is simple enough to refactor later if needed
- **Likelihood:** Low
- **Impact:** Low

**RISK-002: Concurrent State Updates**
- **Risk:** Scrap balance updated while in shop (from main screen timer)
- **Mitigation:** Legend State handles reactivity automatically; shop displays live updates
- **Likelihood:** Low (expected behavior)
- **Impact:** Low (beneficial, not a bug)

**RISK-003: Performance with Many Upgrades**
- **Risk:** Scroll performance degrades with 100+ upgrades
- **Mitigation:** Use FlatList if needed; initial implementation uses ScrollView (sufficient for <50 items)
- **Likelihood:** Low (unlikely to have 100+ upgrades)
- **Impact:** Medium

### 11.2 User Experience Risks

**RISK-004: Unclear Purpose of Upgrades**
- **Risk:** Players don't understand what upgrades do (no upgrades exist yet)
- **Mitigation:** Empty state messaging; descriptions will be clear when upgrades added
- **Likelihood:** Low (empty state is self-explanatory)
- **Impact:** Low

**RISK-005: Accidental Purchases**
- **Risk:** Players accidentally purchase wrong upgrade
- **Mitigation:** No confirmation dialog, but button press requires intentional tap
- **Likelihood:** Low
- **Impact:** Low (purchase is permanent but not catastrophic)

**RISK-006: Navigation Confusion**
- **Risk:** Players don't know how to return to main screen
- **Mitigation:** Prominent "Back" button in header; standard navigation pattern
- **Likelihood:** Low
- **Impact:** Low

---

## 12. Future Enhancements

### 12.1 Potential Features (Post-MVP)

**Future Enhancement 1: Upgrade Categories**
- Group upgrades by type (Scrap Boosts, Pet Boosts, Special)
- Tab-based navigation or collapsible sections
- Filter/sort controls

**Future Enhancement 2: Purchase Confirmation**
- Optional confirmation dialog for expensive upgrades
- Preview of stat changes before purchasing
- "Are you sure?" prompt

**Future Enhancement 3: Upgrade Previews**
- Show "before and after" effect calculations
- Preview how upgrade affects current stats
- Cost-benefit analysis display

**Future Enhancement 4: Visual Enhancements**
- Purchase animations (particles, glow effects)
- Screen transition animations
- Category icons and colors
- Rarity tiers (common, rare, epic)

**Future Enhancement 5: Upgrade Bundles**
- Package deals (buy multiple upgrades at discount)
- Theme-based upgrade sets
- Limited-time offers

**Future Enhancement 6: Shop Notifications**
- Badge on shop button when affordable upgrades exist
- "New upgrade available" alerts
- Wishlist/reminder system

**Future Enhancement 7: Purchase History**
- View past purchases
- Spending statistics
- Upgrade timeline

**Future Enhancement 8: Advanced UI**
- Search/filter functionality
- Sort by cost, type, owned status
- Comparison tool (compare two upgrades)

### 12.2 Scalability Considerations

**Data Management:**
- If upgrade count exceeds 50, consider pagination or lazy loading
- If upgrade data becomes complex, consider separate upgrade service/store
- If categories needed, extend Upgrade interface with category property

**Performance Optimization:**
- Replace ScrollView with FlatList for virtualization (if needed)
- Memoize upgrade cards to prevent unnecessary re-renders
- Debounce scrap display updates if high-frequency changes cause jank

**State Management:**
- If shop state becomes complex, consider separate shop slice
- If undo/redo needed, implement action history
- If multiplayer/sync needed, add conflict resolution

---

## 13. Acceptance Criteria

### 13.1 Feature Completion Checklist

**Must Have:**
- [ ] Shop button visible on main screen
- [ ] Tapping shop button navigates to shop screen
- [ ] Shop screen displays header with title, scrap balance, and back button
- [ ] Back button returns to main screen
- [ ] Empty state displays when no upgrades exist
- [ ] Upgrade cards render correctly with all required fields
- [ ] Purchase button disabled when insufficient scrap
- [ ] Purchase button disabled when upgrade already owned
- [ ] Purchasing an upgrade deducts scrap correctly
- [ ] Purchasing an upgrade adds ID to purchasedUpgrades array
- [ ] Owned upgrades display "Owned" indicator
- [ ] Purchased upgrades persist across app restarts
- [ ] Component tests achieve 90%+ coverage
- [ ] All tests pass in cmd.exe environment
- [ ] Accessibility labels present on all interactive elements

**Should Have:**
- [ ] Purchase button provides visual press feedback
- [ ] Scrap balance updates reactively in shop
- [ ] Upgrade cards styled consistently with design specs
- [ ] ScrollView performs smoothly with 10+ items
- [ ] Layout is responsive on different screen sizes

**Nice to Have:**
- [ ] Smooth press animations on buttons
- [ ] Distinct visual styling for different upgrade types
- [ ] Helpful empty state messaging

---

## 14. Acceptance Testing Scenarios

### 14.1 Happy Path Tests

**Test Case 1: Navigate to Shop**
1. User opens app (main screen displays)
2. User taps "Shop" button
3. Expected: Shop screen appears, showing scrap balance and back button

**Test Case 2: View Upgrades (when available)**
1. User navigates to shop (upgrade data exists in state)
2. Expected: List of upgrade cards displays, each showing name, description, cost, effect

**Test Case 3: Purchase Upgrade**
1. User has 100 scrap
2. User views upgrade that costs 50 scrap (not owned)
3. User taps "Buy" button
4. Expected: Scrap balance becomes 50, upgrade shows "Owned", purchase persists

**Test Case 4: Return to Main Screen**
1. User is on shop screen
2. User taps "Back" button
3. Expected: Main screen displays, all state preserved (petCount, scrap)

### 14.2 Edge Case Tests

**Test Case 5: Empty Shop**
1. User navigates to shop (upgrades array is empty)
2. Expected: Empty state displays with message "No upgrades available yet."

**Test Case 6: Insufficient Scrap**
1. User has 10 scrap
2. User views upgrade that costs 100 scrap
3. Expected: Buy button is disabled, shows "Not enough scrap"

**Test Case 7: Already Owned Upgrade**
1. User has purchased upgrade with ID "upgrade-1"
2. User views upgrade "upgrade-1" in shop
3. Expected: Upgrade shows "Owned" indicator, buy button disabled or replaced

**Test Case 8: Exact Scrap Amount**
1. User has 100 scrap
2. User purchases upgrade that costs 100 scrap
3. Expected: Purchase succeeds, scrap becomes 0

**Test Case 9: Multiple Purchases**
1. User has 1000 scrap
2. User purchases upgrade A (cost 100)
3. User purchases upgrade B (cost 200)
4. Expected: Scrap becomes 700, both upgrades marked as owned

**Test Case 10: Persistence**
1. User purchases upgrade
2. User closes app
3. User reopens app and navigates to shop
4. Expected: Purchased upgrade still shows as owned

---

## 15. Appendix

### 15.1 Glossary

- **Shop:** The dedicated screen where players browse and purchase upgrades
- **Upgrade:** An item that can be purchased with scrap to enhance gameplay
- **Scrap:** The currency used to purchase upgrades
- **Owned/Purchased:** Indicates an upgrade has been bought by the player
- **scrapMultiplier:** Upgrade type that increases scrap generation rate
- **petBonus:** Upgrade type that increases pets gained when feeding

### 15.2 Related Documents

- Feature Description: `/mnt/c/dev/class-one-rapids/frontend/modules/shop/specs/feature-shop.md`
- Game State Types: `/mnt/c/dev/class-one-rapids/frontend/shared/types/game.ts`
- Game Store Implementation: `/mnt/c/dev/class-one-rapids/frontend/shared/store/gameStore.ts`
- Persistence Layer: `/mnt/c/dev/class-one-rapids/frontend/shared/store/persistence.ts`
- Main App Component: `/mnt/c/dev/class-one-rapids/frontend/App.tsx`
- Attack Button Screen: `/mnt/c/dev/class-one-rapids/frontend/modules/attack-button/AttackButtonScreen.tsx`
- Scrap System PRD: `/mnt/c/dev/class-one-rapids/frontend/modules/scrap/specs/prd_scrap_system_20251117.md`

### 15.3 Code References

#### Relevant Type Definitions

```typescript
// From /frontend/shared/types/game.ts

export interface Upgrade {
  id: string;
  name: string;
  description: string;
  scrapCost: number;
  effectType: 'scrapMultiplier' | 'petBonus';
  effectValue: number;
}

export interface GameState {
  petCount: number;
  scrap: number;
  upgrades: Upgrade[];              // â† Used by shop to display available upgrades
  purchasedUpgrades: string[];      // â† Used by shop to track ownership
}
```

#### State Access Patterns

```typescript
// Reading shop-relevant state
import { gameState$ } from '../../shared/store/gameStore';

const upgrades = gameState$.upgrades.get();
const scrap = gameState$.scrap.get();
const purchasedUpgrades = gameState$.purchasedUpgrades.get();

// Purchasing an upgrade
const purchaseUpgrade = (upgrade: Upgrade) => {
  // Deduct scrap
  gameState$.scrap.set((prev) => prev - upgrade.scrapCost);

  // Add to purchased list
  gameState$.purchasedUpgrades.set((prev) => [...prev, upgrade.id]);
};
```

#### Component Pattern

```typescript
import { observer } from '@legendapp/state/react';
import { gameState$ } from '../../shared/store/gameStore';

export const ShopScreen = observer(() => {
  const upgrades = gameState$.upgrades.get();
  const scrap = gameState$.scrap.get();
  const purchasedUpgrades = gameState$.purchasedUpgrades.get();

  // Component logic...

  return (
    // JSX...
  );
});
```

### 15.4 Revision History

| Version | Date       | Author  | Changes                        |
|---------|------------|---------|--------------------------------|
| 1.0     | 2025-11-17 | Claude  | Initial PRD creation for shop  |

---

**Document Status:** Final - Ready for Implementation
**Next Steps:**
1. Review and approve PRD
2. Create Technical Design Document (TDD)
3. Generate task list for implementation
4. Begin development with navigation setup
