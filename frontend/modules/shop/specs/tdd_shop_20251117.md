# Technical Design Document: Shop System

**Version:** 1.0
**Date:** 2025-11-17
**Feature:** Upgrade Shop Interface
**Module:** `/frontend/modules/shop`
**Related PRD:** `prd_shop_20251117.md`

---

## 1. Executive Summary

This Technical Design Document (TDD) provides a comprehensive implementation blueprint for the Shop System feature. The shop provides a dedicated interface for players to browse and purchase upgrades using scrap currency. This document translates the product requirements into concrete technical specifications, component designs, data structures, and implementation guidelines.

### 1.1 Goals

- Design a scalable, maintainable shop system architecture
- Integrate seamlessly with existing Legend State reactive patterns
- Provide clear component specifications for implementation
- Ensure testability and code quality
- Support future extensibility for additional upgrade types and features

### 1.2 Non-Goals

- Implementation of upgrade effects (display only)
- Creation of upgrade definitions (infrastructure only)
- Animation or complex visual effects
- Sound or haptic feedback
- Analytics or tracking systems

---

## 2. Architecture Overview

### 2.1 System Architecture

```
┌─────────────────────────────────────────────────────────┐
│                        App.tsx                          │
│  ┌─────────────────────────────────────────────────┐   │
│  │   Navigation State: 'main' | 'shop'             │   │
│  │   - useState for screen management               │   │
│  │   - Conditional rendering of screens             │   │
│  └─────────────────────────────────────────────────┘   │
│                         │                               │
│         ┌───────────────┴───────────────┐              │
│         │                               │              │
│  ┌──────▼──────┐                 ┌──────▼──────┐      │
│  │  Attack     │                 │   Shop      │      │
│  │  Button     │◄───────────────►│   Screen    │      │
│  │  Screen     │  Navigation     │             │      │
│  └──────┬──────┘                 └──────┬──────┘      │
│         │                               │              │
│         │                               │              │
└─────────┼───────────────────────────────┼──────────────┘
          │                               │
          └───────────┬───────────────────┘
                      │
          ┌───────────▼────────────┐
          │   gameState$ (Legend)  │
          │  ┌─────────────────┐  │
          │  │ petCount        │  │
          │  │ scrap           │  │
          │  │ upgrades[]      │  │
          │  │ purchasedUpgrades[]│
          │  └─────────────────┘  │
          │                        │
          │  Auto-persistence      │
          │  (debounced 1s)        │
          └────────────────────────┘
```

### 2.2 Component Hierarchy

```
App
└── SafeAreaProvider
    ├── AttackButtonScreen (when currentScreen === 'main')
    │   └── Navigation Button → setCurrentScreen('shop')
    │
    └── ShopScreen (when currentScreen === 'shop')
        ├── ShopHeader
        │   ├── BackButton → setCurrentScreen('main')
        │   ├── Title
        │   └── ScrapDisplay
        │
        └── UpgradesList
            ├── EmptyState (when upgrades.length === 0)
            │
            └── UpgradeCard[] (when upgrades.length > 0)
                ├── UpgradeInfo
                │   ├── Name
                │   ├── Description
                │   ├── Effect Display
                │   └── Cost Display
                │
                └── PurchaseButton
                    ├── State: Available
                    ├── State: Insufficient Scrap
                    └── State: Owned
```

### 2.3 Data Flow

```
User Action: Purchase Upgrade
       │
       ▼
handlePurchase(upgrade)
       │
       ├─► Validation
       │   ├─► Check if owned (purchasedUpgrades.includes(id))
       │   └─► Check scrap balance (scrap >= scrapCost)
       │
       ├─► Execute Purchase
       │   ├─► gameState$.scrap.set(prev => prev - scrapCost)
       │   └─► gameState$.purchasedUpgrades.set(prev => [...prev, id])
       │
       ├─► Reactive Update (automatic)
       │   ├─► Observer re-renders ShopScreen
       │   ├─► Button state updates (owned)
       │   └─► Scrap display updates
       │
       └─► Auto-persistence (automatic)
           └─► Debounced save to AsyncStorage (1s delay)
```

---

## 3. Component Specifications

### 3.1 App.tsx Modifications

**Purpose:** Manage navigation between main screen and shop screen.

**Changes Required:**

```typescript
import { useState, useEffect } from "react";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { AttackButtonScreen } from "./modules/attack-button/AttackButtonScreen";
import { ShopScreen } from "./modules/shop/ShopScreen";
import { initializeGameState } from "./shared/store/gameStore";

type Screen = 'main' | 'shop';

export default function App() {
  const [currentScreen, setCurrentScreen] = useState<Screen>('main');

  useEffect(() => {
    initializeGameState();
  }, []);

  return (
    <SafeAreaProvider>
      {currentScreen === 'main' ? (
        <AttackButtonScreen onNavigateToShop={() => setCurrentScreen('shop')} />
      ) : (
        <ShopScreen onNavigateBack={() => setCurrentScreen('main')} />
      )}
    </SafeAreaProvider>
  );
}
```

**Props Added to AttackButtonScreen:**
- `onNavigateToShop: () => void` - Callback to navigate to shop

**Key Points:**
- Simple React state for navigation (no routing library)
- Conditional rendering preserves component lifecycle
- Both components stay in memory briefly during transitions
- State is preserved in gameState$ observable

---

### 3.2 AttackButtonScreen Updates

**Purpose:** Add navigation button to access the shop.

**Changes Required:**

Add prop interface:
```typescript
interface AttackButtonScreenProps {
  onNavigateToShop: () => void;
}

export const AttackButtonScreen = observer(({ onNavigateToShop }: AttackButtonScreenProps) => {
  // ... existing code ...
});
```

Add shop button in JSX (after scrap display, before feed button):
```typescript
<Pressable
  onPress={onNavigateToShop}
  accessibilityRole="button"
  accessibilityLabel="Shop"
  accessibilityHint="Tap to browse and purchase upgrades"
  style={({ pressed }) => [
    styles.shopButton,
    pressed && styles.buttonPressed,
  ]}
>
  <Text style={styles.shopButtonText}>Shop</Text>
</Pressable>
```

Add styles:
```typescript
shopButton: {
  minWidth: 44,
  minHeight: 44,
  paddingHorizontal: 24,
  paddingVertical: 12,
  backgroundColor: '#34C759', // Green to distinguish from feed button
  borderRadius: 8,
  marginBottom: 12, // Space above feed button
  shadowColor: '#000',
  shadowOffset: { width: 0, height: 2 },
  shadowOpacity: 0.1,
  shadowRadius: 4,
  elevation: 3,
},
shopButtonText: {
  fontSize: 16,
  color: '#FFFFFF',
  fontWeight: '600',
},
```

---

### 3.3 ShopScreen Component

**File:** `/frontend/modules/shop/ShopScreen.tsx`

**Purpose:** Main shop interface for browsing and purchasing upgrades.

**Component Signature:**

```typescript
import React from 'react';
import { View, Text, Pressable, ScrollView, StyleSheet } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { observer } from '@legendapp/state/react';
import { useGameState } from '../../shared/hooks/useGameState';
import { Upgrade } from '../../shared/types/game';

interface ShopScreenProps {
  onNavigateBack: () => void;
}

export const ShopScreen = observer(({ onNavigateBack }: ShopScreenProps) => {
  // Component implementation
});
```

**State Access:**

```typescript
const { scrap$, upgrades$, purchasedUpgrades$ } = useGameState();
const scrap = scrap$.get();
const upgrades = upgrades$.get();
const purchasedUpgrades = purchasedUpgrades$.get();
```

**Helper Functions:**

```typescript
/**
 * Checks if an upgrade has been purchased.
 */
const isOwned = (upgradeId: string): boolean => {
  return purchasedUpgrades.includes(upgradeId);
};

/**
 * Checks if an upgrade can be purchased (not owned and sufficient scrap).
 */
const canPurchase = (upgrade: Upgrade): boolean => {
  return !isOwned(upgrade.id) && scrap >= upgrade.scrapCost;
};

/**
 * Handles upgrade purchase.
 */
const handlePurchase = (upgrade: Upgrade): void => {
  // Validation
  if (isOwned(upgrade.id)) {
    console.warn('Upgrade already owned:', upgrade.id);
    return;
  }

  if (scrap < upgrade.scrapCost) {
    console.warn('Insufficient scrap for upgrade:', upgrade.id);
    return;
  }

  // Execute purchase
  scrap$.set((prev) => prev - upgrade.scrapCost);
  purchasedUpgrades$.set((prev) => [...prev, upgrade.id]);
};

/**
 * Gets button label based on upgrade state.
 */
const getButtonLabel = (upgrade: Upgrade): string => {
  if (isOwned(upgrade.id)) {
    return 'Owned';
  }
  if (scrap < upgrade.scrapCost) {
    return 'Not enough scrap';
  }
  return 'Buy';
};
```

**JSX Structure:**

```typescript
return (
  <SafeAreaView style={styles.container}>
    {/* Header */}
    <View style={styles.header}>
      <Pressable
        onPress={onNavigateBack}
        accessibilityRole="button"
        accessibilityLabel="Back to main screen"
        style={({ pressed }) => [
          styles.backButton,
          pressed && styles.backButtonPressed,
        ]}
      >
        <Text style={styles.backButtonText}>← Back</Text>
      </Pressable>

      <Text style={styles.title}>Shop</Text>

      <View style={styles.scrapContainer}>
        <Text style={styles.scrapLabel}>Scrap:</Text>
        <Text style={styles.scrapValue}>{scrap}</Text>
      </View>
    </View>

    {/* Upgrades List or Empty State */}
    <ScrollView
      style={styles.scrollView}
      contentContainerStyle={styles.scrollContent}
    >
      {upgrades.length === 0 ? (
        <EmptyState />
      ) : (
        upgrades.map((upgrade) => (
          <UpgradeCard
            key={upgrade.id}
            upgrade={upgrade}
            isOwned={isOwned(upgrade.id)}
            canPurchase={canPurchase(upgrade)}
            onPurchase={() => handlePurchase(upgrade)}
            buttonLabel={getButtonLabel(upgrade)}
          />
        ))
      )}
    </ScrollView>
  </SafeAreaView>
);
```

---

### 3.4 EmptyState Subcomponent

**Purpose:** Display when no upgrades are available.

**Implementation:**

```typescript
const EmptyState: React.FC = () => (
  <View style={styles.emptyState}>
    <Text style={styles.emptyStateTitle}>
      No upgrades available yet.
    </Text>
    <Text style={styles.emptyStateSubtitle}>
      Check back soon for new upgrades!
    </Text>
  </View>
);
```

**Styles:**

```typescript
emptyState: {
  flex: 1,
  justifyContent: 'center',
  alignItems: 'center',
  paddingVertical: 60,
  paddingHorizontal: 40,
},
emptyStateTitle: {
  fontSize: 18,
  fontWeight: '600',
  color: '#000000',
  textAlign: 'center',
  marginBottom: 8,
},
emptyStateSubtitle: {
  fontSize: 14,
  color: '#666666',
  textAlign: 'center',
},
```

---

### 3.5 UpgradeCard Subcomponent

**Purpose:** Display individual upgrade with purchase button.

**Props Interface:**

```typescript
interface UpgradeCardProps {
  upgrade: Upgrade;
  isOwned: boolean;
  canPurchase: boolean;
  onPurchase: () => void;
  buttonLabel: string;
}
```

**Implementation:**

```typescript
const UpgradeCard: React.FC<UpgradeCardProps> = ({
  upgrade,
  isOwned,
  canPurchase,
  onPurchase,
  buttonLabel,
}) => {
  const cardOpacity = isOwned ? 0.6 : 1;

  return (
    <View style={[styles.card, { opacity: cardOpacity }]}>
      {/* Upgrade Name */}
      <Text style={styles.upgradeName}>{upgrade.name}</Text>

      {/* Description */}
      <Text style={styles.upgradeDescription}>{upgrade.description}</Text>

      {/* Effect Display */}
      <View style={styles.effectContainer}>
        <Text style={styles.effectLabel}>
          Effect: {upgrade.effectType === 'scrapMultiplier'
            ? `Scrap Multiplier x${upgrade.effectValue}`
            : `Pet Bonus +${upgrade.effectValue}`
          }
        </Text>
      </View>

      {/* Cost Display */}
      <View style={styles.costContainer}>
        <Text style={styles.costLabel}>
          Cost: {upgrade.scrapCost} scrap
        </Text>
      </View>

      {/* Purchase Button */}
      <Pressable
        onPress={onPurchase}
        disabled={!canPurchase}
        accessibilityRole="button"
        accessibilityLabel={`Buy ${upgrade.name} for ${upgrade.scrapCost} scrap`}
        accessibilityHint={canPurchase ? 'Double tap to purchase' : undefined}
        accessibilityState={{ disabled: !canPurchase }}
        style={({ pressed }) => [
          styles.purchaseButton,
          isOwned && styles.purchaseButtonOwned,
          !canPurchase && !isOwned && styles.purchaseButtonDisabled,
          pressed && canPurchase && styles.purchaseButtonPressed,
        ]}
      >
        <Text
          style={[
            styles.purchaseButtonText,
            isOwned && styles.purchaseButtonTextOwned,
            !canPurchase && !isOwned && styles.purchaseButtonTextDisabled,
          ]}
        >
          {buttonLabel}
        </Text>
      </Pressable>
    </View>
  );
};
```

---

### 3.6 Complete StyleSheet

```typescript
const styles = StyleSheet.create({
  // Container
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },

  // Header
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E5E5E5',
    backgroundColor: '#FFFFFF',
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    color: '#000000',
  },
  backButton: {
    minWidth: 44,
    minHeight: 44,
    justifyContent: 'center',
  },
  backButtonPressed: {
    opacity: 0.7,
  },
  backButtonText: {
    fontSize: 16,
    color: '#007AFF',
  },
  scrapContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  scrapLabel: {
    fontSize: 14,
    color: '#666666',
    marginRight: 4,
  },
  scrapValue: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FF9500',
  },

  // ScrollView
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 20,
  },

  // Empty State
  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
    paddingHorizontal: 40,
  },
  emptyStateTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#000000',
    textAlign: 'center',
    marginBottom: 8,
  },
  emptyStateSubtitle: {
    fontSize: 14,
    color: '#666666',
    textAlign: 'center',
  },

  // Upgrade Card
  card: {
    backgroundColor: '#F8F8F8',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    // iOS shadow
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 3,
    // Android shadow
    elevation: 2,
  },
  upgradeName: {
    fontSize: 18,
    fontWeight: '600',
    color: '#000000',
    marginBottom: 8,
  },
  upgradeDescription: {
    fontSize: 14,
    color: '#666666',
    lineHeight: 20,
    marginBottom: 12,
  },
  effectContainer: {
    marginBottom: 8,
  },
  effectLabel: {
    fontSize: 14,
    fontWeight: '500',
    color: '#007AFF',
  },
  costContainer: {
    marginBottom: 12,
  },
  costLabel: {
    fontSize: 14,
    fontWeight: '500',
    color: '#FF9500',
  },

  // Purchase Button
  purchaseButton: {
    minHeight: 44,
    backgroundColor: '#007AFF',
    borderRadius: 8,
    paddingVertical: 12,
    paddingHorizontal: 24,
    alignItems: 'center',
    justifyContent: 'center',
  },
  purchaseButtonPressed: {
    opacity: 0.7,
    transform: [{ scale: 0.98 }],
  },
  purchaseButtonDisabled: {
    backgroundColor: '#CCCCCC',
  },
  purchaseButtonOwned: {
    backgroundColor: '#34C759',
  },
  purchaseButtonText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#FFFFFF',
  },
  purchaseButtonTextDisabled: {
    color: '#999999',
  },
  purchaseButtonTextOwned: {
    color: '#FFFFFF',
  },
});
```

---

## 4. Data Structures and Types

### 4.1 Existing Types (No Changes Required)

All necessary types already exist in `/frontend/shared/types/game.ts`:

```typescript
export interface Upgrade {
  id: string;
  name: string;
  description: string;
  scrapCost: number;
  effectType: 'scrapMultiplier' | 'petBonus';
  effectValue: number;
}

export interface GameState {
  petCount: number;
  scrap: number;
  upgrades: Upgrade[];
  purchasedUpgrades: string[];
}
```

### 4.2 Component Props Types (New)

```typescript
// App.tsx
type Screen = 'main' | 'shop';

// AttackButtonScreen
interface AttackButtonScreenProps {
  onNavigateToShop: () => void;
}

// ShopScreen
interface ShopScreenProps {
  onNavigateBack: () => void;
}

// UpgradeCard
interface UpgradeCardProps {
  upgrade: Upgrade;
  isOwned: boolean;
  canPurchase: boolean;
  onPurchase: () => void;
  buttonLabel: string;
}
```

### 4.3 State Management Patterns

**Reading State:**
```typescript
// Using useGameState hook (recommended)
const { scrap$, upgrades$, purchasedUpgrades$ } = useGameState();
const scrap = scrap$.get();

// Direct access (alternative)
import { gameState$ } from '../../shared/store/gameStore';
const scrap = gameState$.scrap.get();
```

**Updating State:**
```typescript
// Functional update (recommended for derived values)
scrap$.set((prev) => prev - upgrade.scrapCost);

// Direct set (for replacing values)
scrap$.set(0);

// Array updates
purchasedUpgrades$.set((prev) => [...prev, upgrade.id]);
```

**Reactive Rendering:**
```typescript
// Wrap component with observer
export const ShopScreen = observer(({ onNavigateBack }) => {
  // Component automatically re-renders when observables change
  const scrap = scrap$.get();
  return <Text>{scrap}</Text>;
});
```

---

## 5. State Management Design

### 5.1 State Flow Diagram

```
┌───────────────────────────────────────────────────────────┐
│                     gameState$ Observable                 │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ petCount: number                                    │ │
│  │ scrap: number                                       │ │
│  │ upgrades: Upgrade[]                                 │ │
│  │ purchasedUpgrades: string[]                         │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                           │
│  onChange Handler (automatic)                             │
│    ├─► Debounce (1000ms)                                 │
│    └─► saveGameState() → AsyncStorage                    │
└───────────────────────────────────────────────────────────┘
           │                           │
           │ Read                      │ Write
           ▼                           ▼
┌─────────────────────┐    ┌──────────────────────┐
│  AttackButtonScreen │    │     ShopScreen       │
│  - Read: scrap      │    │  - Read: all fields  │
│  - Write: scrap     │    │  - Write: scrap,     │
│  - Write: petCount  │    │    purchasedUpgrades │
└─────────────────────┘    └──────────────────────┘
```

### 5.2 State Lifecycle

**1. Initialization (App Startup)**
```
App.tsx useEffect
  └─► initializeGameState()
       ├─► loadGameState() from AsyncStorage
       ├─► Validate with isValidGameState()
       ├─► Sanitize with sanitizeGameState()
       └─► Set gameState$ with loaded data
```

**2. Runtime Updates**
```
User Action (feed, purchase, etc.)
  └─► Component calls gameState$.field.set()
       ├─► Observable updates immediately
       ├─► Observer components re-render
       └─► onChange triggers
            ├─► Clear existing timeout
            └─► Set new timeout (1000ms)
                 └─► saveGameState()
```

**3. Persistence**
```
saveGameState()
  ├─► Get current gameState$.get()
  ├─► Wrap in PersistedGameState { version, data, timestamp }
  ├─► JSON.stringify()
  └─► AsyncStorage.setItem()
```

### 5.3 Concurrency Considerations

**Problem:** Scrap updates while in shop (from AttackButtonScreen timer).

**Solution:** Legend State handles this automatically.
- Both screens read from same gameState$ observable
- AttackButtonScreen timer continues running (component stays mounted)
- Shop displays live scrap updates via reactive observer pattern
- No manual synchronization needed

**Example Flow:**
```
Time 0s: User opens shop (scrap: 100)
Time 1s: Timer ticks → scrap$.set(prev => prev + petCount)
         └─► ShopScreen observer re-renders with new scrap value
Time 2s: User purchases upgrade (cost: 50)
         └─► scrap$.set(prev => prev - 50)
         └─► Both screens see updated value (scrap: 50 + petCount)
```

---

## 6. Navigation Flow

### 6.1 Navigation State Diagram

```
┌──────────────┐
│     Main     │
│    Screen    │
│              │
│ [Shop Button]│
└──────┬───────┘
       │
       │ onNavigateToShop()
       │ setCurrentScreen('shop')
       ▼
┌──────────────┐
│     Shop     │
│    Screen    │
│              │
│ [Back Button]│
└──────┬───────┘
       │
       │ onNavigateBack()
       │ setCurrentScreen('main')
       ▼
┌──────────────┐
│     Main     │
│    Screen    │
└──────────────┘
```

### 6.2 Navigation Implementation

**App.tsx manages navigation state:**

```typescript
const [currentScreen, setCurrentScreen] = useState<Screen>('main');

// Pass navigation callbacks as props
<AttackButtonScreen onNavigateToShop={() => setCurrentScreen('shop')} />
<ShopScreen onNavigateBack={() => setCurrentScreen('main')} />
```

**Benefits of this approach:**
- No external routing library needed
- Simple and predictable
- Easy to test
- State preserved in gameState$ observable
- Instant transitions

**Limitations (acceptable for MVP):**
- No URL-based routing (not needed for mobile app)
- No deep linking support (not required)
- No navigation history (not needed for two screens)
- Not suitable for 5+ screens (can migrate to router later)

---

## 7. Testing Strategy

### 7.1 Test File Structure

```
/frontend/modules/shop/
├── ShopScreen.tsx
└── ShopScreen.test.tsx
```

### 7.2 Unit Tests

**File:** `ShopScreen.test.tsx`

**Setup:**

```typescript
import { render, screen, fireEvent } from '@testing-library/react-native';
import { ShopScreen } from './ShopScreen';
import { gameState$ } from '../../shared/store/gameStore';
import { Upgrade } from '../../shared/types/game';

// Mock navigation
const mockNavigateBack = jest.fn();

// Test data
const mockUpgrade: Upgrade = {
  id: 'test-upgrade-1',
  name: 'Test Upgrade',
  description: 'A test upgrade',
  scrapCost: 100,
  effectType: 'scrapMultiplier',
  effectValue: 2,
};

beforeEach(() => {
  // Reset state before each test
  gameState$.set({
    petCount: 0,
    scrap: 0,
    upgrades: [],
    purchasedUpgrades: [],
  });
  mockNavigateBack.mockClear();
});
```

**Test Cases:**

```typescript
describe('ShopScreen', () => {
  describe('Rendering', () => {
    it('should render shop header with title and scrap balance', () => {
      gameState$.scrap.set(500);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      expect(screen.getByText('Shop')).toBeTruthy();
      expect(screen.getByText('500')).toBeTruthy();
    });

    it('should render back button', () => {
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      expect(screen.getByText('← Back')).toBeTruthy();
    });

    it('should display empty state when no upgrades', () => {
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      expect(screen.getByText('No upgrades available yet.')).toBeTruthy();
      expect(screen.getByText('Check back soon for new upgrades!')).toBeTruthy();
    });

    it('should render upgrade cards when upgrades exist', () => {
      gameState$.upgrades.set([mockUpgrade]);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      expect(screen.getByText('Test Upgrade')).toBeTruthy();
      expect(screen.getByText('A test upgrade')).toBeTruthy();
      expect(screen.getByText('Cost: 100 scrap')).toBeTruthy();
    });
  });

  describe('Navigation', () => {
    it('should call onNavigateBack when back button pressed', () => {
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      const backButton = screen.getByText('← Back');
      fireEvent.press(backButton);

      expect(mockNavigateBack).toHaveBeenCalledTimes(1);
    });
  });

  describe('Purchase Flow', () => {
    it('should enable buy button when scrap is sufficient', () => {
      gameState$.scrap.set(200);
      gameState$.upgrades.set([mockUpgrade]);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      const buyButton = screen.getByText('Buy');
      expect(buyButton).toBeTruthy();
    });

    it('should disable buy button when scrap is insufficient', () => {
      gameState$.scrap.set(50);
      gameState$.upgrades.set([mockUpgrade]);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      const button = screen.getByText('Not enough scrap');
      expect(button).toBeTruthy();
    });

    it('should show owned when upgrade already purchased', () => {
      gameState$.scrap.set(200);
      gameState$.upgrades.set([mockUpgrade]);
      gameState$.purchasedUpgrades.set(['test-upgrade-1']);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      expect(screen.getByText('Owned')).toBeTruthy();
    });

    it('should deduct scrap on purchase', () => {
      gameState$.scrap.set(200);
      gameState$.upgrades.set([mockUpgrade]);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      const buyButton = screen.getByText('Buy');
      fireEvent.press(buyButton);

      expect(gameState$.scrap.get()).toBe(100);
    });

    it('should add upgrade to purchasedUpgrades on purchase', () => {
      gameState$.scrap.set(200);
      gameState$.upgrades.set([mockUpgrade]);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      const buyButton = screen.getByText('Buy');
      fireEvent.press(buyButton);

      expect(gameState$.purchasedUpgrades.get()).toContain('test-upgrade-1');
    });

    it('should prevent double purchase', () => {
      gameState$.scrap.set(200);
      gameState$.upgrades.set([mockUpgrade]);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      const buyButton = screen.getByText('Buy');
      fireEvent.press(buyButton);
      fireEvent.press(buyButton); // Try to buy again

      // Should only be purchased once
      expect(gameState$.purchasedUpgrades.get().length).toBe(1);
      expect(gameState$.scrap.get()).toBe(100); // Not 0
    });

    it('should allow purchase when scrap equals cost', () => {
      gameState$.scrap.set(100);
      gameState$.upgrades.set([mockUpgrade]);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      const buyButton = screen.getByText('Buy');
      fireEvent.press(buyButton);

      expect(gameState$.scrap.get()).toBe(0);
      expect(gameState$.purchasedUpgrades.get()).toContain('test-upgrade-1');
    });
  });

  describe('Reactive Updates', () => {
    it('should update scrap display when scrap changes', () => {
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      // Initial scrap
      expect(screen.getByText('0')).toBeTruthy();

      // Update scrap
      gameState$.scrap.set(100);

      // Should re-render with new value
      expect(screen.getByText('100')).toBeTruthy();
    });
  });

  describe('Multiple Upgrades', () => {
    it('should render multiple upgrade cards', () => {
      const upgrade1: Upgrade = { ...mockUpgrade, id: 'up1', name: 'Upgrade 1' };
      const upgrade2: Upgrade = { ...mockUpgrade, id: 'up2', name: 'Upgrade 2' };

      gameState$.upgrades.set([upgrade1, upgrade2]);
      render(<ShopScreen onNavigateBack={mockNavigateBack} />);

      expect(screen.getByText('Upgrade 1')).toBeTruthy();
      expect(screen.getByText('Upgrade 2')).toBeTruthy();
    });
  });
});
```

### 7.3 Integration Tests

**Test persistence:**

```typescript
describe('ShopScreen Persistence', () => {
  it('should persist purchases across component unmount/remount', async () => {
    gameState$.scrap.set(200);
    gameState$.upgrades.set([mockUpgrade]);

    const { unmount } = render(<ShopScreen onNavigateBack={mockNavigateBack} />);

    // Purchase upgrade
    const buyButton = screen.getByText('Buy');
    fireEvent.press(buyButton);

    // Wait for debounced save
    await new Promise(resolve => setTimeout(resolve, 1100));

    // Unmount component
    unmount();

    // Remount component
    render(<ShopScreen onNavigateBack={mockNavigateBack} />);

    // Should still show as owned
    expect(screen.getByText('Owned')).toBeTruthy();
  });
});
```

### 7.4 Test Coverage Goals

- **Minimum:** 90% code coverage for ShopScreen
- **Target:** 100% coverage for purchase logic functions
- **All user flows tested:** Navigation, browsing, purchasing, edge cases

### 7.5 Running Tests

**Command (per CLAUDE.md):**
```bash
# Run in cmd.exe (not WSL) due to performance issues
cmd.exe /c "npm test -- ShopScreen.test.tsx"
```

---

## 8. Implementation Phases

### Phase 1: Navigation Setup
**Priority:** High
**Estimated Effort:** 1-2 hours

**Tasks:**
1. Modify `App.tsx` to add navigation state management
2. Update `AttackButtonScreen.tsx` to accept `onNavigateToShop` prop
3. Add shop button to `AttackButtonScreen`
4. Create basic `ShopScreen.tsx` skeleton (just renders "Shop" text)
5. Test navigation works both directions
6. Commit: "feat: add shop navigation infrastructure"

**Acceptance Criteria:**
- [ ] Shop button visible on main screen
- [ ] Tapping shop button navigates to shop screen
- [ ] Back button returns to main screen
- [ ] No TypeScript errors
- [ ] Component compiles and runs

---

### Phase 2: Shop Header Implementation
**Priority:** High
**Estimated Effort:** 1 hour

**Tasks:**
1. Implement shop header with title, scrap display, and back button
2. Add header styling (sticky/fixed positioning)
3. Connect scrap display to gameState$ observable
4. Wire up back button to `onNavigateBack` prop
5. Test header displays correctly
6. Commit: "feat: implement shop header with scrap display"

**Acceptance Criteria:**
- [ ] Header displays "Shop" title
- [ ] Current scrap balance shown in header
- [ ] Back button functional
- [ ] Header styling matches design specs
- [ ] Scrap display updates reactively

---

### Phase 3: Empty State and Upgrade List
**Priority:** High
**Estimated Effort:** 1-2 hours

**Tasks:**
1. Implement `EmptyState` subcomponent
2. Add conditional rendering logic (empty vs. upgrades)
3. Implement `UpgradeCard` subcomponent structure
4. Add ScrollView for upgrade list
5. Test with empty upgrades array
6. Test with mock upgrades data
7. Commit: "feat: add upgrade list and empty state"

**Acceptance Criteria:**
- [ ] Empty state displays when `upgrades.length === 0`
- [ ] Upgrade cards render when upgrades exist
- [ ] ScrollView works smoothly
- [ ] Card styling matches design specs
- [ ] All upgrade data displays correctly (name, description, cost, effect)

---

### Phase 4: Purchase Logic
**Priority:** High
**Estimated Effort:** 2-3 hours

**Tasks:**
1. Implement `isOwned()` helper function
2. Implement `canPurchase()` helper function
3. Implement `handlePurchase()` function
4. Implement `getButtonLabel()` function
5. Wire up purchase button states (enabled/disabled/owned)
6. Add button press handlers
7. Test purchase flow manually
8. Commit: "feat: implement purchase logic and button states"

**Acceptance Criteria:**
- [ ] Purchase button disabled when insufficient scrap
- [ ] Purchase button disabled when already owned
- [ ] Purchasing deducts scrap correctly
- [ ] Purchasing adds to purchasedUpgrades array
- [ ] UI updates immediately after purchase
- [ ] Cannot purchase same upgrade twice

---

### Phase 5: Testing
**Priority:** High
**Estimated Effort:** 3-4 hours

**Tasks:**
1. Set up test file structure
2. Write rendering tests
3. Write navigation tests
4. Write purchase flow tests
5. Write edge case tests (exact scrap, multiple purchases, etc.)
6. Write reactive update tests
7. Run all tests in cmd.exe
8. Ensure 90%+ coverage
9. Commit: "test: add comprehensive ShopScreen tests"

**Acceptance Criteria:**
- [ ] All test cases pass
- [ ] Code coverage ≥ 90%
- [ ] Tests run successfully in cmd.exe
- [ ] No failing tests
- [ ] Edge cases covered

---

### Phase 6: Polish and Accessibility
**Priority:** Medium
**Estimated Effort:** 1-2 hours

**Tasks:**
1. Add accessibility labels to all interactive elements
2. Add accessibility hints for buttons
3. Test with screen reader (if available)
4. Optimize performance (check for unnecessary re-renders)
5. Add press feedback animations
6. Test on various screen sizes
7. Verify touch targets are 44x44pt minimum
8. Commit: "polish: improve accessibility and UX"

**Acceptance Criteria:**
- [ ] All buttons have accessibility labels
- [ ] Screen reader compatibility verified
- [ ] No performance issues
- [ ] Press animations smooth
- [ ] Responsive on different screen sizes
- [ ] Touch targets meet accessibility standards

---

### Phase 7: Documentation
**Priority:** Low
**Estimated Effort:** 1 hour

**Tasks:**
1. Add JSDoc comments to all exported functions
2. Add inline comments for complex logic
3. Update component prop interfaces with descriptions
4. Document any gotchas or edge cases
5. Commit: "docs: add documentation to ShopScreen"

**Acceptance Criteria:**
- [ ] All public functions have JSDoc comments
- [ ] Complex logic is commented
- [ ] Props have clear descriptions
- [ ] Code is self-documenting

---

## 9. File Structure

### 9.1 New Files

```
/frontend/modules/shop/
├── ShopScreen.tsx              # Main shop component (NEW)
├── ShopScreen.test.tsx         # Component tests (NEW)
└── specs/
    ├── feature-shop.md         # Feature description (existing)
    ├── prd_shop_20251117.md    # Product requirements (existing)
    └── tdd_shop_20251117.md    # This document (NEW)
```

### 9.2 Modified Files

```
/frontend/
├── App.tsx                     # Add navigation state management
└── modules/
    └── attack-button/
        └── AttackButtonScreen.tsx  # Add shop button and onNavigateToShop prop
```

### 9.3 No Changes Required

```
/frontend/shared/
├── types/
│   └── game.ts                 # Types already defined
├── store/
│   ├── gameStore.ts            # State management already set up
│   └── persistence.ts          # Persistence already implemented
└── hooks/
    └── useGameState.ts         # Hook already available
```

---

## 10. Dependencies

### 10.1 Existing Dependencies (No New Installs)

```json
{
  "@legendapp/state": "^2.x",
  "react": "^18.x",
  "react-native": "^0.x",
  "react-native-safe-area-context": "^4.x"
}
```

### 10.2 Dev Dependencies (Already Installed)

```json
{
  "@testing-library/react-native": "^x.x",
  "jest": "^x.x",
  "@types/react": "^18.x",
  "@types/react-native": "^0.x"
}
```

**No new dependencies required.**

---

## 11. Performance Considerations

### 11.1 Rendering Optimization

**Potential Issues:**
- Unnecessary re-renders when state changes
- ScrollView performance with many upgrades

**Solutions:**

1. **Use observer pattern correctly:**
   ```typescript
   // ✅ Good: Component wrapped with observer
   export const ShopScreen = observer(() => { ... });

   // ❌ Bad: Not wrapped, won't react to changes
   export const ShopScreen = () => { ... };
   ```

2. **Memoize subcomponents if needed:**
   ```typescript
   const UpgradeCard = React.memo(({ upgrade, ... }: UpgradeCardProps) => {
     // Component implementation
   });
   ```

3. **Use FlatList for large lists (future optimization):**
   ```typescript
   // If upgrades exceed 50 items
   <FlatList
     data={upgrades}
     renderItem={({ item }) => <UpgradeCard upgrade={item} ... />}
     keyExtractor={(item) => item.id}
   />
   ```

### 11.2 State Update Patterns

**Avoid:**
```typescript
// ❌ Multiple separate updates (triggers multiple saves)
scrap$.set(scrap$.get() - 100);
purchasedUpgrades$.set([...purchasedUpgrades$.get(), id]);
```

**Prefer:**
```typescript
// ✅ Functional updates (more efficient)
scrap$.set((prev) => prev - 100);
purchasedUpgrades$.set((prev) => [...prev, id]);
```

### 11.3 Debounced Saves

**Current Implementation:**
- Auto-save triggers 1000ms after last state change
- Multiple rapid purchases → single save operation
- No performance impact from persistence

**No changes needed.**

---

## 12. Security and Validation

### 12.1 Input Validation

**Purchase Validation:**
```typescript
const handlePurchase = (upgrade: Upgrade): void => {
  // Validate not owned
  if (purchasedUpgrades.includes(upgrade.id)) {
    console.warn('Upgrade already owned:', upgrade.id);
    return;
  }

  // Validate sufficient funds
  if (scrap < upgrade.scrapCost) {
    console.warn('Insufficient scrap for upgrade:', upgrade.id);
    return;
  }

  // Execute purchase
  scrap$.set((prev) => prev - upgrade.scrapCost);
  purchasedUpgrades$.set((prev) => [...prev, upgrade.id]);
};
```

### 12.2 State Sanitization

**Existing protection in gameStore.ts:**
- `sanitizeGameState()` clamps values to valid ranges
- No negative scrap or petCount possible
- Arrays default to empty if undefined

**No additional validation needed in shop.**

### 12.3 Data Integrity

**Assumptions:**
- Upgrade IDs are unique (managed by data layer)
- Upgrade data is well-formed (validated at creation)
- purchasedUpgrades array contains valid strings

**Edge Case Handling:**
- Duplicate purchase attempts prevented by ownership check
- Insufficient funds prevented by scrap check
- Invalid upgrade data causes no crashes (TypeScript type safety)

---

## 13. Accessibility

### 13.1 Screen Reader Support

**Required Labels:**

```typescript
// Back Button
accessibilityRole="button"
accessibilityLabel="Back to main screen"

// Shop Title
accessibilityRole="header"
accessibilityLabel="Shop"

// Scrap Display
accessibilityRole="text"
accessibilityLabel="Current scrap balance: {scrap}"

// Purchase Button (Available)
accessibilityRole="button"
accessibilityLabel="Buy {upgrade.name} for {upgrade.scrapCost} scrap"
accessibilityHint="Double tap to purchase"

// Purchase Button (Insufficient)
accessibilityRole="button"
accessibilityLabel="Not enough scrap to purchase {upgrade.name}"
accessibilityState={{ disabled: true }}

// Purchase Button (Owned)
accessibilityRole="button"
accessibilityLabel="{upgrade.name} already owned"
accessibilityState={{ disabled: true }}
```

### 13.2 Touch Target Sizes

**Minimum sizes:**
- All buttons: 44x44pt (iOS/Android guideline)
- Back button: 44x44pt minimum
- Purchase button: 44pt height minimum

**Implementation:**
```typescript
button: {
  minWidth: 44,
  minHeight: 44,
  // ...
}
```

### 13.3 Color Contrast

**WCAG 2.1 AA Compliance:**
- Primary text (#000000) on white (#FFFFFF): 21:1 (Pass AAA)
- Secondary text (#666666) on white: 5.74:1 (Pass AA)
- Button text (white) on blue (#007AFF): 4.5:1+ (Pass AA)
- Button text (white) on green (#34C759): 4.5:1+ (Pass AA)

**All colors meet accessibility standards.**

---

## 14. Error Handling

### 14.1 Graceful Degradation

**No upgrades available:**
- Display helpful empty state (not blank screen)
- Explain situation to user
- No error message (expected state)

**State loading fails:**
- Handled by `initializeGameState()` in gameStore
- Gracefully continues with defaults
- Logged to console but doesn't crash

**Purchase fails validation:**
- Button disabled (prevents attempt)
- Clear visual state (grayed out, "Not enough scrap")
- No error modals or alerts needed

### 14.2 Console Warnings

**Development-only warnings:**
```typescript
if (purchasedUpgrades.includes(upgrade.id)) {
  console.warn('Upgrade already owned:', upgrade.id);
  return;
}
```

**Benefits:**
- Helps debugging during development
- No user-facing impact
- Can be removed in production builds

---

## 15. Future Extensibility

### 15.1 Adding New Upgrade Types

**Current effectType values:**
- `'scrapMultiplier'`
- `'petBonus'`

**To add new type (e.g., 'autoClicker'):**

1. Update type definition:
   ```typescript
   effectType: 'scrapMultiplier' | 'petBonus' | 'autoClicker';
   ```

2. Update display logic in UpgradeCard:
   ```typescript
   const getEffectLabel = (upgrade: Upgrade): string => {
     switch (upgrade.effectType) {
       case 'scrapMultiplier':
         return `Scrap Multiplier x${upgrade.effectValue}`;
       case 'petBonus':
         return `Pet Bonus +${upgrade.effectValue}`;
       case 'autoClicker':
         return `Auto-click every ${upgrade.effectValue}s`;
       default:
         return 'Unknown effect';
     }
   };
   ```

3. No changes to purchase logic required (effect type is display-only in shop).

### 15.2 Adding Upgrade Categories

**Future enhancement: Group upgrades by category**

1. Extend Upgrade interface:
   ```typescript
   export interface Upgrade {
     // ... existing fields
     category?: 'scrap' | 'pet' | 'automation' | 'special';
   }
   ```

2. Add filtering/tabs in ShopScreen:
   ```typescript
   const [selectedCategory, setSelectedCategory] = useState<string | null>(null);

   const filteredUpgrades = selectedCategory
     ? upgrades.filter(u => u.category === selectedCategory)
     : upgrades;
   ```

3. Add category navigation UI above upgrade list.

### 15.3 Adding Search/Filter

**Future enhancement: Search upgrades by name**

1. Add search state:
   ```typescript
   const [searchQuery, setSearchQuery] = useState('');
   ```

2. Filter upgrades:
   ```typescript
   const filteredUpgrades = upgrades.filter(u =>
     u.name.toLowerCase().includes(searchQuery.toLowerCase())
   );
   ```

3. Add TextInput component in header.

### 15.4 Adding Purchase Confirmation

**Future enhancement: Confirm expensive purchases**

1. Add confirmation state:
   ```typescript
   const [confirmingUpgrade, setConfirmingUpgrade] = useState<Upgrade | null>(null);
   ```

2. Show modal before purchase:
   ```typescript
   const handlePurchasePress = (upgrade: Upgrade) => {
     if (upgrade.scrapCost > 1000) {
       setConfirmingUpgrade(upgrade);
     } else {
       handlePurchase(upgrade);
     }
   };
   ```

3. Render confirmation modal when `confirmingUpgrade` is set.

---

## 16. Known Limitations

### 16.1 Navigation

**Limitation:** Simple two-screen navigation only.

**Impact:** Not suitable for 5+ screens.

**Mitigation:** Can migrate to react-navigation if app grows.

---

### 16.2 Upgrade Effects

**Limitation:** Purchased upgrades don't actually affect gameplay.

**Impact:** Shop is display/purchase only (no functional changes to scrap generation or pet bonuses).

**Mitigation:** Upgrade effects implementation is separate feature (future PR).

---

### 16.3 No Confirmation Dialogs

**Limitation:** Purchases are immediate (no "Are you sure?").

**Impact:** Accidental purchases possible (but unlikely due to intentional button press).

**Mitigation:**
- Button states prevent most accidents (disabled when can't purchase)
- Can add confirmations in future if needed
- Purchases are permanent but not catastrophic

---

### 16.4 ScrollView Performance

**Limitation:** ScrollView renders all items at once.

**Impact:** Performance degrades with 100+ upgrades.

**Mitigation:**
- Acceptable for < 50 upgrades (expected range)
- Can migrate to FlatList if needed
- Virtualization available as optimization

---

## 17. Testing Checklist

### 17.1 Manual Testing

**Before submitting PR:**

- [ ] Shop button visible on main screen
- [ ] Tapping shop button navigates to shop
- [ ] Back button returns to main screen
- [ ] Empty state displays when no upgrades
- [ ] Upgrade cards display correctly when upgrades exist
- [ ] Scrap balance displays in header
- [ ] Scrap balance updates when purchasing
- [ ] Purchase button enabled when can afford
- [ ] Purchase button disabled when insufficient scrap
- [ ] Purchase button shows "Owned" when already purchased
- [ ] Scrap deducts correctly on purchase
- [ ] Owned upgrades marked correctly
- [ ] Cannot purchase same upgrade twice
- [ ] Multiple purchases work correctly
- [ ] ScrollView scrolls smoothly with 10+ upgrades
- [ ] Touch targets feel correct (44x44pt)
- [ ] Press feedback animations work
- [ ] Layout looks good on different screen sizes
- [ ] No console errors or warnings

### 17.2 Automated Testing

**Jest tests (run in cmd.exe):**

- [ ] All rendering tests pass
- [ ] All navigation tests pass
- [ ] All purchase flow tests pass
- [ ] All edge case tests pass
- [ ] Code coverage ≥ 90%
- [ ] No failing tests
- [ ] No TypeScript errors

### 17.3 Accessibility Testing

**If screen reader available:**

- [ ] All buttons announce correctly
- [ ] Button states announced (disabled, etc.)
- [ ] Scrap balance announced correctly
- [ ] Navigation flows work with screen reader

---

## 18. Acceptance Criteria Summary

**Must Have (Blocking):**

- [ ] Shop button on main screen navigates to shop
- [ ] Shop displays scrap balance in header
- [ ] Back button returns to main screen
- [ ] Empty state displays when no upgrades
- [ ] Upgrade cards render with all data (name, description, cost, effect)
- [ ] Purchase button disabled when insufficient scrap
- [ ] Purchase button disabled when already owned
- [ ] Purchasing deducts scrap correctly
- [ ] Purchasing adds to purchasedUpgrades array
- [ ] Owned upgrades show "Owned" indicator
- [ ] Purchases persist across app restarts
- [ ] All tests pass with 90%+ coverage
- [ ] No TypeScript errors
- [ ] No console errors during normal use

**Should Have (Desired):**

- [ ] Purchase button provides press feedback
- [ ] Scrap balance updates reactively in shop
- [ ] Styling matches design specifications
- [ ] ScrollView performs smoothly
- [ ] Layout responsive on different screens
- [ ] Accessibility labels on all elements

**Nice to Have (Optional):**

- [ ] Smooth animations on button press
- [ ] Visual distinction for upgrade types
- [ ] Helpful empty state messaging

---

## 19. Revision History

| Version | Date       | Author  | Changes                              |
|---------|------------|---------|--------------------------------------|
| 1.0     | 2025-11-17 | Claude  | Initial TDD creation for shop system |

---

## 20. Appendix

### 20.1 Related Documents

- **PRD:** `/frontend/modules/shop/specs/prd_shop_20251117.md`
- **Feature Description:** `/frontend/modules/shop/specs/feature-shop.md`
- **Game Types:** `/frontend/shared/types/game.ts`
- **Game Store:** `/frontend/shared/store/gameStore.ts`
- **Persistence:** `/frontend/shared/store/persistence.ts`
- **useGameState Hook:** `/frontend/shared/hooks/useGameState.ts`
- **Attack Button Screen:** `/frontend/modules/attack-button/AttackButtonScreen.tsx`

### 20.2 Code Style Guidelines

**Follow existing patterns:**
- Use functional components with hooks
- Wrap reactive components with `observer()`
- Use TypeScript for all files
- Use StyleSheet for styling (not inline styles)
- Follow accessibility best practices
- Add JSDoc comments to exported functions
- Use descriptive variable names
- Keep functions small and focused

**Component organization:**
```typescript
// 1. Imports
import React from 'react';
import { View, Text } from 'react-native';

// 2. Types/Interfaces
interface Props { ... }

// 3. Component
export const Component = observer((props: Props) => {
  // 4. Hooks
  const { field$ } = useGameState();

  // 5. Helper functions
  const handleAction = () => { ... };

  // 6. Render
  return ( ... );
});

// 7. Styles
const styles = StyleSheet.create({ ... });
```

### 20.3 Git Commit Strategy

**Commit message format:**
```
type(scope): description

Examples:
feat(shop): add shop navigation infrastructure
feat(shop): implement shop header with scrap display
feat(shop): add upgrade list and empty state
feat(shop): implement purchase logic and button states
test(shop): add comprehensive ShopScreen tests
polish(shop): improve accessibility and UX
docs(shop): add documentation to ShopScreen
```

**Commit frequency:**
- One commit per phase (7 commits total)
- Each commit should be functional (app still runs)
- Include tests in same commit as implementation (or separate test commit)

---

**Document Status:** Final - Ready for Implementation
**Next Steps:**
1. Review and approve TDD
2. Generate task list using `/flow:tasks`
3. Begin implementation with Phase 1 (Navigation Setup)
4. Follow implementation phases sequentially
5. Run tests after each phase
6. Submit PR when all acceptance criteria met
